# Generazione codice intermedio

Abbiamo due categorie di codice intermedio storiche:
* Una basata sull'architettura di Von Neumann:
  * La più famosa è TAC (Three Address Code)
  * Le ir moderne derivano da questa (llvm-ir, GIMPLE)
* Una basata su macchine a stack
  * Antenato di P-code (pascal)
  * Un esempio notevole è il bytecode java

Vedremo tac.

## TAC

Gli elementi base delle istruzioni sono degli indirizzi, e sono:
* Program names: Identificano la sorgente del programma
  * Le sue variabili vengono allocate in un frame dello stack runtime e vanno gestite per lo scoping
* Letterali: Valori dei tipi primitivi di tac
  * Integer, float, char, boolean, nessun altro
  * Tutti i tipi primitivi del linguaggio guest devono essere implementati con questi (es: stringhe)
* Compiler-generated temporaries: valori intermedi di valutazione
  * Sono teoricamente illimitati, in una macchina vera non è così (i registri non sono infiniti), quindi vanno mappati
  * Possono contenere solo tipi primitivi di tac

Tutte le istruzioni sono fatte in modo che prendano in input al massimo *tre* di questi indirizzi.

Istruzioni:
* Assegnamenti binari: `l = r1 bop r2`
  * `bop` è una operazione binaria del processore (es: somma, sottrazione)
* Assegnamenti unari: `l = uop r`
* Assegnamenti nullari: `l = r`
* Salto incondizionato: `goto label`
* Jump condizionali booleani: `if r goto label`, `ifFalse r goto label`
* Jump condizionali relazionali: `if r1 rel r2 goto label`
* Assegnamenti indicizzati: `l = id[r]`, `id[r1] = r2`
  * Sono indici assoluti, non basati sulla dimensione del tipo
  * Non si può fare `id1[r1] = id2[r2]` perch servirebbero 4 indirizzi
* Referenziazione dereferenziazione: `l = &id`, `l1 = *l2`, `*l = r`
* Funzioni e procedure:
  * `param r` inserisco un parametro nello stack, per una funzione che devo chiamare
  * `pcall proc, n` chiamo la procedura con `n` parametri
  * `l = fcall fun, n` chiamo la funzione con `n` parametri
  * `return` chiudo una procedura
  * `return r` chiudo una funzione

Esempio `do i++ while(a[i] < max);` :

```
L1: i = i + 1
    t1 = i * 8
    t2 = a[t1]
    if t2 < max goto L1
```

## TAC come attributi sintetizzati da SDD

Vediamo dei semplici assegnamenti dove le uniche lhs sono variabili semplici.

$$
S\rightarrow id=E\\
E\rightarrow num|id|E+E|-E
$$

Consideriamo solo + binario e - unario, perché tanto sono tutte identiche.

Generiamo liste di stringhe di codice (eventualmente etichettato) e le concateniamo con `(++)`

Usiamo `newtemp()` per generare nuovo nomi di valori temporanei quando ci servono. Usiamo `gen(.)` per generare una lista di una singola istruzione, in realtà useremo rappresentazioni simboliche per risparmiare.
Usiamo `mkAddr(num)` e `getAddr(id,env)` per gestire gli indirizzi.

Usare `++` è terribile per le prestazioni, magari possiamo fare meglio. È meglio usare una sorta di stream di istruzioni, dove costruiamo la lista come side effects, a costo essenzialmente zero.
Quindi sostituiamo la funzione `gen(.)` con `out(.)` che invece che creare una lista singoletta, la inserisce nello stream.

## Gestione degli array

