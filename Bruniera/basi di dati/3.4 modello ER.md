# Modello ER

```
A causa della natura grafica di questo modello si consiglia
di visionare la registrazione.

Comunque gli esempi verranno riportati con la notazione vista in precedenza.
```

## Attributi

### Attributi composti

Alcuni attributi sono fondamentalmente formati dia più infromazioni. Ad esempio un indirizzo è composto da via, numero civico, città, cap. Graficamente si indica rappresentando l'indirizzo come una grande ellisse e collegandogi degli attributi semplici. Questa struttutra può iterata.
Negli appunti si indicherà annidando le parentesi graffe così:
```
attributo composto{
    attributi semplici
    attributo composto{
        attributi semplici
    }
}
```

Questa struttura non è presente nel modello relazionale, come parte della 1° forma normale che vieta  attributi strutturati e attributi composti da insiemi di elementi. Quindi saranno rappresentati come più attributi semplici


### Attributi multivaloree opzionali

Alcuni attributi sono fondamentalmente "multipli". Ad esempio un recapito telefonico è naturalmente multipli, nel senso che posso averne più d'uno.
Negli attributi bisognerebbe sengnare il massimo ed il minimo come per le relazioni, quando si ha un attributo multiplo il massimo è N.
Negli appunti si indicherà con un `/(min,max)` come per le relazioni:
```
entità{
    ...
    {
        attributo/(0,N)
    }
}
```

Se il massimo è finito bisogna creare MAX campi nel record per gli ipotetici MAX attributi. Nel relaizonale si cerca di evitarlo quindi cerca di tenere N quando è più di uno. Anche se volendo si possono avere numeri diversi 
Il minimo serve per indicare l'obbligatorietà dell'attributo.

Alcuni attributi sono opzionali. Si hanno quando il minimo dell'attributo è 0. Nel relazionale si avrà un campo del record che può essere lasciato vuoto.
La chiave non può essere opzionale

### Attributi derivati

Alcuni attributi non ha senso che siano valorizzati perché variano nel tempo anche senza che siano fatte operazioni di aggiornamento. Vengono calcolati al momento.
Ad esempio l'età deve essere calcolata dalla data di nascita e data corrente, perché cambierà al variare della data corrente.
Nell'er vengono indicate con un pallino tratteggiato, negli appunti userò la notazione delle funzioni
```
entità{
    ...
    {
        nascita
        età[data - nascita] 'operazione esplicita
        età(nascita) 'operazione implicita
    }
}
```

### Chiave o identifiatore interno.

La chiave è una superchiave minimale. È un insieme di attributi che identifica univocamente tutte le concretizzazioni di un'entità.
Esiste sempre almeno una superchiave, l'insieme di tutte le attributi, probabilmente non è minimale. Se non esiste ho sbagliato lo schema.

Possono essere composte, se ho un database con gli studenti di tutte le università, la matricola non basta come chiave, serve anche l'università.

Per la rappresentazione si incrociano tutti gli archi degli attributi della chiave con una linea che termina in un pallino pieno. Non è come avere due pallini neri, quello sarebbe avere più di una chiave.
Nell'er si dovrebbe indicare tutte le possibilità, ma nel relazionale no. Però posso garantire le caatteristiche d chiave anche ad altri attributi.
Negli appunti utilizzerò la notazione degli attributi composti e il nome pkN:
```
entità{
    pk1{
        matricola
        università
    }
    identificatore

    {
        ...
    }
}
```

Se le chiavi primarie sono particolarmente grandi si può scegliere di utilizzare un identificatore, seguendo la filosofia degli oggetti, anche se sarebbe contro la filosofia degli er

### Il valore NULL

Con `dom(a)` si indica il dominio di un attributo.

Supponiamo di avere un database con le province italiane. Alcune di queste saranno capoluoghi di provincia e avranno un palazzo di provincia, e la via del palazzo sarà nel database. Alcune potrebbero avere un palazzo anche se non son capoluogo, alcune possono non essere capoluogo e non averlo, e alcune potrebbero essere capoluogo ma non so dove si trova il palazzo.

In queste situazioni inserisco come valore della via il valore NULL. Questo valore indica il non sapere l'informazione, ma non mi permette di fare assunzioni, ad esempio non posso contare i capoluogo contando i NOTNULL.
Questo valore viene aggiunto a tutti i domini, perché di persé è fuori da tutti i domini e evita collisioni.

È importante non usare valori NOTNULL per indicare questa mancanza di informazioni. Se segno 0 come stipendio dei dipendendi di cui non so lo stipendio e poi calcolo la media, 0 fa media, NULL no.

## Relazioni

Le relazioni legano due o più entità tra loro da un'"azione" (e.g. cliente->possiede->cc). Il comportamento della relazione dipende dai valori `(min,max)`.

Il valore min è chiamato vincolo di relazione che può essere parziale (0) o totale (1).

Il valore max invece è chiamato rapporto di cardinalità e non è utile da solo, ma deve essere osservato insieme al rapporto dell'altra entità. I casi sono:
* (,1)-(,1) uno a uno
  * Ad ogni elemento a sinistra è legata una sola a destra
  * Ad ogni elemento a destra è legata una sola a sinistra
* (,1)-(,N) uno a molti
  * Ogni elemento a sinistra è legata a più elementi a destra
  * Ad ogni elemento a destra è legata una sola a sinistra
* (,N)-(,1) molti a uno
  * Ad ogni elemento a sinistra è legata una sola a destra
  * Ogni elemento a destra è legata a più elementi a sinistra
* (,N)-(,N) molti a molti
  * Ogni elemento a sinistra è legata a più elementi a destra
  * Ogni elemento a destra è legata a più elementi a sinistra

I casi uno a molti e molti a uno son equivalenti, cambia soltanto il verso.

### Molti a molti

La soluzione della relazione molti a molti è quella già vista nell'esempio della banca: Creo una tabella per ogni entità e una tabella per la relazione che le mette in relazione

### Uno a molto (e viceversa)

Posso mantenere l'approccio a tre tabelle volendo, ma la sua chiave sarà solo la chiave esterna dell'entità 1, escludendo l'entità N.

In genere è meglio includere attributi della relazione e la chiave esterna dell'entità N nella tabella dell'entità 1, diminuendo il numero di tabelle.

In certi casi conviene tenere la terza tabella

### Uno a uno

Fondo le tabelle delle due entità in un unica tabella con una chiave (quella di una delle due entità) ed un attributo con caratteristiche di chiave (quella dell'altra entità).

### Caso particolare: Successione di regnanti

Consideriamo il seguende database:
```
Re{
    ...
}
<succede>[
    predecessore: Re/(0,1)
    successore: Re/(0,1)
]
```

Nessuno ha più di un poredecessore e successore. Un re non ha successori, un re non ha predecessori

Questa relazione mette in relazione la stessa entità con se stessa. Nella nostra notazione lo avevamo già fatto, ma nel linguaggio er è fondamentale etichettare i due archi per indicare il ruolo delle entità.

Da questo tipo di situazioni potremmo voler calcolare una chiusura transitiva. Questo non si può fare col calcolo relazionale, il linguaggio SQL non lo permetterebbe. Sono state agginte funzionalità a SQL apposta per farlo.

Se usassimo la soluzione dell uno a uno suggerita in precedenza avremmo una tabella con colonne che incrementano. Va contro la 1° forma normale, non si può fare.

## Entità

### Entità deboli

Si tratta di entità che non possiedono attributi candidati come chiavi, ma per esere identificato deve fare riferimento ad alcune relazioni dette identificanti. Esempio:

Alberghi presenti nella città di Udine. In questo caso la città è il contesto, quindi non comparira nello schema perché ci sarebbe una sola città e tutti gli alberghi sarebbero nella stessa.

Stanze in ogni albergo

```
Albergo {
    nome
}

<in>[
    albergo: Albergo/(1,N)
    stanza: Stanza/(1,1)
]

Stanza {
    numero
}
```

La stanze non hanno abbastanza attributi per esser identificate, perché il numero è unico solo all'interno dello stesso albergo. Tuttavia, se partiziono le stanze in base all'albergo, all'interno dello stesso sottoinsieme il numero è identificante.
Nel grafico ER si incrocerebbe l'arco della relazione con quelli degli altri attributi della chiave. Nella notazione degli appunti aggiungero il nome della relazione alla chiave primaria.

Quindi modificherò l'entità stanza così:

```
Stanza {
    PK1 {
        numero
        <in>
    }
}
```

La chiave della stanza che contiene il riferimento all'albergo si chiama identificatore esterno.
Il minimo e massimo dell'identificatore esterno deve essere 1, è una chiave primaria.
In alcuni casi l'identificatore esterno può contenere solo il riferimento ed altri attributi, ma si tratta di casi particolari.

Se aggiungiamo le città anche l'albergo diventa entità debole perché possono esserci alberghi con lo stesso nome in città diverse.

```
Città {
    nome
}

<si trova in> [
    città: Città/(0,N)
    albergo: Albergo/(1,1)
]

Albergo {
    PK1 {
        nome
        <si trova in>
    }
}

<in>[
    albergo: Albergo/(1,N)
    stanza: Stanza/(1,1)
]

Stanza {
    PK1 {
        numero
        <in>
    }
}
```

Ovviamente deve esserci almeno una entità forte nello schema. Ovviamente si possono avere più riferimenti nella chiave, ma non faremo l'esempio.

Tradotto nel modello relazionale si ha le tabelle disposte come la 1-N e la chiave esterna del lato 1 è inclusa nella superchiave.

Se non ho nessuna informazione della città e mi serve solo per identificare l'albergo, non gli dedico un'entità e la includo direttamente nell'albergo. In un esercizio d'esame questa cosa non succederà, ma in casi reali si.

## Relazioni ternarie o di grado superiori

Una relazione con tre o più archi uscenti, alcuni di questi potrebbero essere diretti alla stessa entità, basterà etichettarle.

```
<fornire> [
    fornitore: Fornitore/(?,?)
    componente: Componente/(?,?)
    progetto: Progetto/(?,?)
    {
        quantità
    }
]

Fornitore {
    PKf
}

Componente {
    PKc
}

Progetto {
    PKp
}
```

Interpretiamo ogni istanza della relazione fornire come una tripla. Per i massimali e minimali ci poniamo le stessa domande che ci ponevamo prima, ma rispetto alla tripla.

Quindi, un fornitore può fornire più componenti a più progetti, quindi massimale N, e se non fornisce niente non è un fornitore, lo togliamo dalla base, quindi minimale 1. Si noti che non abbiamo informazioni sul fatto che fornisca componenti diverse allo stesso progetto o le stesse componenti a progetti diversi.
Per componente e progetto faccio gli stessi ragionamenti.

Quindi ottengo larelazione:
```
<fornire> [
    fornitore: Fornitore/(1,N)
    componente: Componente/(1,N)
    progetto: Progetto/(1,N)
    {
        quantità
    }
]
```

Se ho grado più alto funziona allo stesso modo, ma con quadruple, quintuple, eccetera. Altre notazioni non si generalizzano.

### Le relazioni di grado superiore al secondo sono veramente necessarie?

Se si allora il modello ER è strettamente più espressivo di quello reticolare. Proviamo a codificarlo con relazioni binarie.
Partiamo da uno schema in cui abbiamo aggiunto tutte le possibili relazioni binarie tra le entità iniziali.

```
Fornitore {
    PKf
}

<cf> [
    fornitore: Fornitore
    componente: Componente
]

Componente {
    PKc
}

<pc> [
    componente: Componente
    progetto: Progetto
]

Progetto {
    PKp
}

<pf> [
    progetto: Progetto
    fornitore: Fornitore
]
```

Consideriamo la seguente istanza di fornisce: i' = i(fornisce) = {(f,c,p'),(f,c',p),(f',c,p)}. Proiettiamo le triple su cf, pf e pc:
* i(cf) = {(f,c),(f,c'),(f',c)}
* i(pf) = {(f,p'),(f,p),(f',p)}
* i(pc) = {(c,p'),(c',p),(c,p)}

Proviamo a ricostuire in modo che se (a,b), (b,c) e (c,d) appartengono ciascuno ad una delle tre relazioni, allora (a,b,c) appartiene a fornisce (operazione di join): i'' = {(f,c,p'),(f,c',p),(f',c,p),(f,c,p)}.
Oh no, abbiamo trovato una tripla in più. E peggio ancora, se proietto i'' ottengo la stessa proiezione di i'. Quindi non sono equivalenti le due rappresentazioni, perdo l'informazione che differenza le due istanze i' e i''.

### Davvero davvero?

Beh, per  fare questa dimostrazione abbiamo agginto una restrizione, cioè che si facesse riferimento all'insieme iniziale di entità. E se provassi senza questa restrizione? Ci riusciamo, ecco come:<>

```
Fornitore {
    PKf
}

<ff> [
    fornitore: Fornitore/(1,N)
    fornisce: Fornisce/(1,1)
]

Componente {
    PKc
}

<cf> [
    componente: Componente/(1,N)
    fornisce: Fornisce/(1,1)
]

Progetto {
    PKp
}

<pf> [
    progetto: Progetto/(1,N)
    fornisce: Fornisce/(1,1)
]

Fornisce {
    PK1 {
        <ff>
        <cf>
        <pf>
    }
    {
        quantità
    }
}
```

Posso creare una nuova entità da qualcosa che naturalmente non sarebbe un'entità: la relazione fornisce (processo di reificazione). Quindi creo un'entità Fornisce e tre relazioni binarie verso le altre tre entità.
Le massimali e minimali delle tre entità sono le stesse, mentre quelle della nuova entità è (1,1) su tutte le relazioni.
La chiave esterna della nuova istanza sono le tre relazioni e non ha altri attributi di chiave interni, si verifica sempre nel processo di reificazione

L'implementazione come tabelle nel modello relazionale è la stessa! Quindi non abbiamo dubbi che sia equivalente alla relazione ternaria.

## Esempio

Si voglia sintetizzare uno schema ER che registri informazioni sugli impiegati, i dipartimenti ed i progetti di un'**azienda**. Si supponga di aver raccolto i sequenti requisiti:
1. L'azienda sia organizzata in dipartimenti. Ogni dipartimento abbia un unico nome. ed uno specifico impiegato che lo gestisce (manager). Si voglia tener traccia della data in cui tale impiegato ha assunto tale ruolo. Ogni dipartimento possa avere più sedi.
2. Un dipartimento controlli in certo insieme di progetti, ognuno dei quali sia contraddistinto da un unico nome, un unico numero ed una singola sede.
3. Ogni impiegato sia contraddistinto da un nome, un codice fiscale, che lo identifica univocamente, un indirizzo, uno stipendio, un sesso ed una data di nascita. Ogni impiegato afferisca ad un unico dipartimento, ma possa lavorare a più progetti, non necessariamente controllati dallo stesso pdipartimento. Si voglia tener traccia del numero di ore per settimana che un impiegato dedica ad ogni progetto. Infine, si voglia tener traccaia del supervisore diretto di ogni impiegato.
4. Si voglia tener traccia per motivi assicurativi delle persone a carico di ogni impiegato. Si voglia tener traccia del nome della persona a carico, del sesso, della data di nascita e del legame con l'impiegato (figlio, coniuge, genitore)

```
Dipartimento {
    nome
    numero
    { 'la sede non da informazioni oltre alla posizione del dipartimento, non serve un'entità
        sede/(1,N)
    }
}

Progetto {
    nome
    numero
    { 'se dovesse essere la stessa del dipartimento avrebbe senso avere un'entità sede, ma non ho motivo di crederlo.
        sede
    }
}

<controlla> [
    'tutti i dipendenti di un dipartimento potrebbero lavorare a progetti di altri dipartimenti
    dipartimento: Dipartimento/(0,N)
    progetto: Dipartimento/(1,1)
]

Impiegato {
    CF
    {
        nome {
            proprio
            cognome
        }
        indirizzo
        stipendio
        sesso
        data di nascita
    }
}

<afferisce> [
    dipartimento: Dipartimento/(1,N)
    impiegato: Impiegato/(1,1)
]

<lavora a> [
    progetto: Progetto/(1,N)
    'un impiegato potrebbe essere in un transitorio tra due progetti
    Impiegato: Impiegato/(1,N)
    {
        ore settimanali
    }
]

<gestisce> [
    dipartimento: Dipartimento/(1,1)
    manager: Impiegato/(0,1)
    {
        data
    }
]

<supervisione> [
    controllato: Impiegato/(0,1)
    controllore: Impiegato/(0,N)
]

<carico> [
    impiegato: Impiegato/(0,N)
    persona: Persona_a_carico/(1,1)
]

'entità debole
Persona_a_carico {
    PK1 {
        <carico>
        'assumiamo che se ho due figli non gli do lo stesso nome
        'assumiamo che il figlio di un mio partner non ha lo stesso nome (metti un junior o senior)
        nome {
            proprio
            cognome
        }
    }
    {
        sesso
        data di nascita
        relazione
    }
}
```

Questo schema ha un warning: dei cicli. Posso arrivare da una entità ed un altra attraverso più percorsi. Se i due percorsi sono completamente liberi non ci sono problemi. altrimenti devo aggiungere dei vincoli.

Ciclo Dipartimento-Progetto-Impiegato. Dato che un impiegato può lavorare a progetti non del proprio dipartimento questo ciclo non è un problema.

Ciclo Dipartimento-Impiegato. Questo ciclo è un problema, permetterebbe ad un impiegato di essere manager di un dipartimento a cui non afferisce. Devo aggiungere questo vincolo di integrità esplicito.