# Progettazione logica di basi di dati

Per progettare una base di dati si parte da un dominio applicativo. Si tratta di tutte le informazioni, i documenti, gli esperti, eccetera riguardanti l'applicazione del nostro database.

La progettazione concettuale parte dal dominio applicativo e produce uno schema concettuale, un ER. Per questa fase ci sono delle tecniche che vedremo a laboratorio.
Una tecnica è il top-down, in cui parto da uno schema grezzo e lo raffino fino a trovare lo schema completo. La tecnica bottom-up parte da tutte le entità e man mano aggiunge le relazioni e gli attributi. La tecnica inside-out inizia da una parte nota del database e lo estende aggiungiendo un po' per volta entità e relazioni.

Nella fase di progettazione logica, dallo schema ER si produce lo schema logico relazionale. È più facile perché è algoritmica, mentre quella concettuale no.
È praticamente una traduzione.

In alcuni casi si può avere una fase di progettazione fisica che produce uno schema fisico del database. Si arriva a questo solo se voglo specificare indici e strutture dati per applicazioni specifiche.
Se questa parte non la progettiamo noi il DBMS la produce da solo.

## Progettazione logica

È utile dividere la progettazione logica in fue fasi:
* Ristrutturazione lo schema
  * Rivediamo le entità per migliorare le prestazioni
* Traduzione dello schema
  * Effettivamente tradurre le entità

### Ottimizzazione

Uno schema ER può essere ristrutturato per ottimizzare due parametri
* Il costo delle operazioni
* Lo spazio occupato

Per valutare i due parametri ci servono due informazioni: il volume dei dati ed il tipo di operazioni.

Consideriamo il seguente schema:
```
//TODO
```

Volumi ed operazioni sono riassunte da delle tabelle che riportano informazioni. Per i volumi sono riportati concetti, tipo e quantità di tuple. Per le operazioni son riportate operazioni, tipo e frequenza giornaliera.
Ad esempio, se avessi tante operazioni di interrogazione e poche di aggiornamento, posso lasciare delle ridondanze, le operazioni di interrogazione saranno più veloci e le altre comunque avvengono poche volte.
Se invece ho tante operazioni di inserimento e poche letture mi conviene rimuovere tutte le ridondanze possibili.

//TODO tabella

Possiamo combinare queste tabelle in una tavola degli accessi che riporta: concetti, tipo dei concetti, numero di acessi e tipo di accesso.

//TODO tabella

### Ristrutturazione

La fase di ristrutturazione passa per più passaggi:
* //TODO

### Ristrutturazione: Analisi delle ridondanze

Vediamo alcuni esempi di schema con ridondanze

//TODO

C'è un altro tipo di ridondanza, in cui un dato che posso recuperare, ad esempio un conteggio di relazioni, può essere inserito come attributo.
È scomodo da gestire perché bisognatenerlo aggirnato ogni volta che viene aggiunta o rimossa una relazione. Se faccio molte letture giornaliere mi conviene perché non ho bisogno di ricalcolarla

//TODO

In generale le ridondanze sono uno svantaggio in interrogazionie e come volume, ma un vantaggio in interrogazione.

#### Esempio 1

```
Persona {}

<residenza> [
    Persona/(1,1)
    Città/(0,N)
]

Città {
    {
        numero_di_abitanti
    }
}
```

Ci conviene tenere o rimuovere il numero di abitanti?
//TODO tabelle

Notiamo che il numero di città non cambia, ma il numero di residenti si. I residenti cambiano circa 500 volte al giorno, mentre i dati delle città vengon stampati due volta al giorno.
Si potrebbe pensare di non tenere la ridondanza dato che le stampe avvengono solo due volte, ma se guardiamo i volumi notiamo che quelle due stampe sono troppo costose per non avere quel dato.

//TODO tabelle accessi

Dalla tabella degli accessi notiamo che il numero di accessi giornalieri cala considerevolmente aggiungendo la ridondanza.

Vediamo i numeri:
* In presenza di ridondanza
  * L'operazione 1 costa un totale di 1500 scritture e 500 letture per giorno
  * L'opeazione 2 costa 2 accessi in lettura
  * Contanto due volte le scritture abbiamo un totale di 3500 accessi giornalieri
* In assenza di ridondanza
  * L'operazione 1 richiede 1000 accessi al giorno.
  * L'operazione 2 richiede un totale di 10000 accessi al giorno
  * Contando due volte gli accessi in scrittura abbiamo un totale di 12000 accessi al giorno.
* Vale la pena di tenere la ridondanza

Questa analisi ha senso solo se i dati che ho sugli accessi ed il volume sono affidabili.

### Ristrutturazione: rimozione delle generalizzazioni

Le generalizzzazioni non esiston nel relazionale, quindi dobbiamotrovare un modo per rimuoverle conservanodone le proprietà.

```
E0 {}
E1 => E0 {}
E2 => E0 {}
E3 {}
E4 {}

<r1> [
    E0
    E3
]

<r2> [
    E2
    E4
]
```

Ho più alternative:
* Tengo solo il genitore
  * Devo  riportare gli attributi di tutti i figli nel genitore
* Tengo solo i figli
  * Devo riportare gli attributi del genitore in ogni figlio
* Tengo entrambi
  * Devo aggiungere unarelazione tra ogni figlio e genitore
* Tengo il genitore ed alcuni figli

Posso scegliere ad esempio in base a cosa viene interrogato normalmente. Ad esempio se la maggior parte delle interrogazioni sono dirette al genitore terrò solo quello.

La scelta più importante è in base a totalità/parzialità. Se è parziale non posso eliminare il genitore altrimenti perdo alcune informazioni. Posso aggiungere un figli che raccolga i casi mancanti per avere una generalizzazione totale da una parziale.

Posso scegliere anche in base al numero di attributi. Se i figli hanno tanti attributi, rimuovendoli la tabella del genitore diventa sparsa perché ogni istanza valorizza solo quelli di uno dei figli.

Se abbiamo una gneralizzazione non disgiunta è problematico buttare via il genitore. Posso avere delle ridondanze o delle inconsistenze perché i dati dello stesso genitore possono comparire tra i due figli.
Atzeni considera le generalizzazioni sempre disgiunte. Si possono disgiungere aggiungendo figli per ogni sovrapposizione.

//TODO schemi

Ci sono delle restrizioni allo schema prededente. no nsempre posso appplicarle tutte.

### Ristrutturazione: Fondere o spaccare entità e relazioni

//TODO schemi

Quando ho un'entità con molti attributi, se i miei programmi accedono in genere a gruppi separatu di attributi, (ad esempio dati personali e dati aziendali) conviene spaccare l'entità in due entità correlate da una relazione 1-1 per migliorare le presatazioni di accesso (devo far elaborare ed inviare meno dati).

//TODO

#### Scelta dell chiavi primarie

Criteri:
* Non possono essere nullable (sul serio?)
* Se hanno un solo attributo è meglio
* Un identificatore interno con pochi attributi è preferibile ad uno esterno
* //TODO