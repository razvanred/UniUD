# Progettazione logica di basi di dati

Per progettare una base di dati si parte da un dominio applicativo. Si tratta di tutte le informazioni, i documenti, gli esperti, eccetera riguardanti l'applicazione del nostro database.

La progettazione concettuale parte dal dominio applicativo e produce uno schema concettuale, un ER. Per questa fase ci sono delle tecniche che vedremo a laboratorio.
Una tecnica è il top-down, in cui parto da uno schema grezzo e lo raffino fino a trovare lo schema completo. La tecnica bottom-up parte da tutte le entità e man mano aggiunge le relazioni e gli attributi. La tecnica inside-out inizia da una parte nota del database e lo estende aggiungiendo un po' per volta entità e relazioni.

Nella fase di progettazione logica, dallo schema ER si produce lo schema logico relazionale. È più facile perché è algoritmica, mentre quella concettuale no.
È praticamente una traduzione.

In alcuni casi si può avere una fase di progettazione fisica che produce uno schema fisico del database. Si arriva a questo solo se voglo specificare indici e strutture dati per applicazioni specifiche.
Se questa parte non la progettiamo noi il DBMS la produce da solo.

## Progettazione logica

È utile dividere la progettazione logica in fue fasi:
* Ristrutturazione lo schema
  * Rivediamo le entità per migliorare le prestazioni
* Traduzione dello schema
  * Effettivamente tradurre le entità

### Ottimizzazione

Uno schema ER può essere ristrutturato per ottimizzare due parametri
* Il costo delle operazioni
* Lo spazio occupato

Per valutare i due parametri ci servono due informazioni: il volume dei dati ed il tipo di operazioni.

Consideriamo il seguente schema:
```
Employee {
  code
  {
    surname
    salary
    age
  }
}

Project {
  name
  {
    budget
    releasedate
  }
}

Departement {
  PK1 {
    name
    <composition>
  }
  {
    phone
  }
}

Branch {
  city
  {
    address {
      number
      street
      postcode
    }
  }
}

<participation> [
  Project/(1,N)
  Employee/(0,N)
  {
    startdate
  }
]

<management> [
  Employee/(0,1)
  Departement/(1,1)
]

<membership> [
  Employee/(0,1)
  Departement/(0,1)
  {
    startdate
  }
]

<composition> [
  Departement/(1,1)
  Branch/(1,N)
]
```

Volumi ed operazioni sono riassunte da delle tabelle che riportano informazioni. Per i volumi sono riportati concetti, tipo e quantità di tuple. Per le operazioni son riportate operazioni, tipo e frequenza giornaliera.
Ad esempio, se avessi tante operazioni di interrogazione e poche di aggiornamento, posso lasciare delle ridondanze, le operazioni di interrogazione saranno più veloci e le altre comunque avvengono poche volte.
Se invece ho tante operazioni di inserimento e poche letture mi conviene rimuovere tutte le ridondanze possibili.

| Concept | Type | Volume |
| --- | --- | --- |
| Branch | E | 10 |
| Departement | E | 80 |
| Employee | E | 2000 |
| Project | E | 500 |
| Composition | R | 80 |
| Membership | R | 1900 |
| Management | R | 80 |
| Participation | R | 6000 |

| Operation | Type | Frequency |
| --- | --- | --- |
| Operation 1 | I | 50 |
| Operation 2 | I | 100 |
| Operation 3 | I | 10 |
| Operation 4 | B | 2 |

Possiamo combinare queste tabelle in una tavola degli accessi che riporta: concetti, tipo dei concetti, numero di acessi e tipo di accesso.

| Concept | Type | Accesses | Type |
| --- | --- | --- | --- |
| Employee | Entity | 1 | R |
| Membership | Relationship | 1 | R |
| Department | Entity | 1 | R |
| Participation | Relationship | 3 | R |
| Project | Entity | 3 | R |

### Ristrutturazione

La fase di ristrutturazione passa per più passaggi:
* Analisi delle ridondanze
* Rimozione delle generalizzazioni
* Fondere o spaccare entità relazioni
* Selezione delle chiavi primarie

### Ristrutturazione: Analisi delle ridondanze

Vediamo alcuni esempi di schema con ridondanze

Un attributo può essere ottenuto dagli altri della stessa entità:
```
Invoice {
  {
    netamount
    tax
    grossamount
  }
}
```

Un attrobuto può essere ottenuto dalle relazioni:
```
Purchase {
  {
    totalamount
  }
}

Product {
  {
    price
  }
}

<composition> [
  Purchase/(1,N)
  Product/(1,N)
]
```

Un attrobuto può essere contando le relazioni:
```
Person {}

Town {
  {
    number_of_inhabitants
  }
}

<residence> [
  Person/(1,1)
  town/(1,N)
]
```

Una relazione può essere ottenuta da altre relazioni
```
Student {}

course {}

Teacher {}

<teaching> [
  Student/(0,N)
  Lecturer/(1,N)
]

<attendance> [
  Student/(0,N)
  Course/(1,N)
]

<assignment> [
  Lecturer/(1,1)
  Course/(1,1)
]
```

È scomodo da gestire le ridondanze perché bisogna tenerle aggirnate ogni volta che viene aggiunta o rimossa una tupla. Se faccio molte letture giornaliere mi conviene perché non ho bisogno di ricalcolarla

In generale le ridondanze sono uno svantaggio in aggiornamenti e come volume, ma un vantaggio in interrogazione.

#### Esempio 1

```
Persona {}

<residenza> [
    Persona/(1,1)
    Città/(0,N)
]

Città {
    {
        numero_di_abitanti
    }
}
```

Ci conviene tenere o rimuovere il numero di abitanti?


| Concept | Type | Volume |
| --- | --- | --- |
| Town | E | 200 |
| Person | E | 1000000 |
| Residence | R | 1000000 |

| Operation | Type | Frequency |
| --- | --- | --- |
| Operation 1 (add a new person with town of residence) | I | 500 |
| Operation 2 (print all the town data) | I | 2 |

Notiamo che il numero di città non cambia, ma il numero di residenti si. I residenti cambiano circa 500 volte al giorno, mentre i dati delle città vengon stampati due volta al giorno.
Si potrebbe pensare di non tenere la ridondanza dato che le stampe avvengono solo due volte, ma se guardiamo i volumi notiamo che quelle due stampe sono troppo costose per non avere quel dato.

Operazione 1 con ridondanza:
| Concept | Type | Accesses | Type |
| --- | --- | --- | --- |
| Person | Entity | 1 | W |
| Residence | Relationship | 1 | W |
| Town | Entity | 1 | R |
| Town | Entity | 1 | W |

Operazione 2 con ridondanza:
| Concept | Type | Accesses | Type |
| --- | --- | --- | --- |
| Town | Entity | 1 | R |

Operazione 1 senza ridondanza:
| Concept | Type | Accesses | Type |
| --- | --- | --- | --- |
| Person | Entity | 1 | W |
| Residence | Relationship | 1 | W |

Operazione 2 senza ridondanza
| Concept | Type | Accesses | Type |
| --- | --- | --- | --- |
| Town | Entity | 1 | R |
| Residence | Relationship | 5000 | R |

Dalla tabella degli accessi notiamo che il numero di accessi giornalieri cala considerevolmente aggiungendo la ridondanza.

Vediamo i numeri:
* In presenza di ridondanza
  * L'operazione 1 costa un totale di 1500 scritture e 500 letture per giorno
  * L'opeazione 2 costa 2 accessi in lettura
  * Contanto due volte le scritture abbiamo un totale di 3500 accessi giornalieri
* In assenza di ridondanza
  * L'operazione 1 richiede 1000 accessi al giorno.
  * L'operazione 2 richiede un totale di 10000 accessi al giorno
  * Contando due volte gli accessi in scrittura abbiamo un totale di 12000 accessi al giorno.
* Vale la pena di tenere la ridondanza

Questa analisi ha senso solo se i dati che ho sugli accessi ed il volume sono affidabili.

### Ristrutturazione: rimozione delle generalizzazioni

Le generalizzzazioni non esiston nel relazionale, quindi dobbiamotrovare un modo per rimuoverle conservanodone le proprietà.

```
E0 {
  A01
  {
    A02
  }
}
E1 => E0 {
  {
    A11
  }
}
E2 => E0 {
  {
    A21
  }
}
E3 {}
E4 {}

<r1> [
    E0
    E3
]

<r2> [
    E2/(X,Y)
    E4
]
```

Ho più alternative:
* Tengo solo il genitore
  * Devo  riportare gli attributi di tutti i figli nel genitore
* Tengo solo i figli
  * Devo riportare gli attributi del genitore in ogni figlio
* Tengo entrambi
  * Devo aggiungere unarelazione tra ogni figlio e genitore
* Tengo il genitore ed alcuni figli

Posso scegliere ad esempio in base a cosa viene interrogato normalmente. Ad esempio se la maggior parte delle interrogazioni sono dirette al genitore terrò solo quello.

La scelta più importante è in base a totalità/parzialità. Se è parziale non posso eliminare il genitore altrimenti perdo alcune informazioni. Posso aggiungere un figli che raccolga i casi mancanti per avere una generalizzazione totale da una parziale.

Posso scegliere anche in base al numero di attributi. Se i figli hanno tanti attributi, rimuovendoli la tabella del genitore diventa sparsa perché ogni istanza valorizza solo quelli di uno dei figli.

Se abbiamo una gneralizzazione non disgiunta è problematico buttare via il genitore. Posso avere delle ridondanze o delle inconsistenze perché i dati dello stesso genitore possono comparire tra i due figli.
Atzeni considera le generalizzazioni sempre disgiunte. Si possono disgiungere aggiungendo figli per ogni sovrapposizione.

```
E0 {
  A01
  {
    A02
    A11
    A21
    'tipo di entità figlio
    type
  }
}

E3 {}

E4 {}

<r1> [
  E0
  E3
]

<r2> [
  E0/(0,Y)
  E4
]

```

```
E1 {
  A01
  {
    A02
    A11
  }
}

E2 {
  A01
  {
    A02
    A21
  }
}

E3 {}

E4 {}

<r11> [
  E1
  E3
]

<r12> [
  E2
  E3
]

<r2> [
  E2/(X,Y)
  E4
]
```

```
E0 {
  A01
  {
    A02
  }
}

E1 {
  <rG1>
  {
    A11
  }
}

E2 {
  <rG2>
  {
    A21
  }
}

E3 {}

E4 {}

<r1> [
  E0
  E3
]

<r2> [
  E2/(X,Y)
  E4
]

<rG1> [
  E1/(1,1)
  E0/(0,1)
]

<rG2> [
  E2/(1,1)
  E0/(0,1)
]

```

Ci sono delle restrizioni allo schema prededente. Non sempre posso appplicarle tutte.

Vediamo una soluizione mista:

```
E0 {
  A01
  {
    Type
    A02
    A11
  }
}

E2 {
  <rG2>
  {
    A21
  }
}

E3 {}

E4 {}

<r1> [
  E0
  E3
]

<r2> [
  E2/(X.Y)
  E4
]

<rG2> [
  E2/(1,1)
  E0/(0,1)
]
```

### Ristrutturazione: Fondere o spaccare entità e relazioni

```
Employee {
  number
  {
    name
    address
    date_of_birth
    level
    salaty
    tax
  }
}
```

```
PersonalData {
  number
  {
    name
    address
    date_of_birth
  }
}

<employee data> [
  PersonalData/(1,1)
  EmploymentData/(1,1)
]

EmploymentData {
  <employee data>
  {
    level
    salaty
    tax
  }
}
```

Quando ho un'entità con molti attributi, se i miei programmi accedono in genere a gruppi separatu di attributi, (ad esempio dati personali e dati aziendali) conviene spaccare l'entità in due entità correlate da una relazione 1-1 per migliorare le presatazioni di accesso (devo far elaborare ed inviare meno dati).

Ovviamente vale anche il caso opposto, se cerco spesso insieme due entità, e non hanno troppi attributi, posso unirle in una unica entità e scegliere una delle due chiavi primarie come chiave

```
Person {
  ssn
  {
    name
    address
    date_of_birth
  }
}

<owner> [
  Person/(0,1)
  Apartment/(1,1)
]

Apartment {
  PK1 {
    aptnumber
    aptaddress
  }
}
```

```
Person {
  ssn
  PK1 {
    aptnumber
    aptaddress
  }
  {
    name
    address
    date_of_birth
  }
}
```

#### Scelta dell chiavi primarie

Criteri:
* Non possono essere nullable (sul serio?)
* Se hanno un solo attributo è meglio
* Un identificatore interno con pochi attributi è preferibile ad uno esterno
* Un attributo che viene utilizzato spesso per cercare occorrenze di una entità è preferibile ad altri (sulla chiave costruisco un indice)