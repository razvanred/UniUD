# Tecnologia di un datbase server centralizzato

Abbiamo visto che funzionalità ha un database server. Ci serve sapere con che meccanismi le realizza.

Perché?
* Capiamo come conviene configurare un database in base a che funzionalità ci interessano di più
* Aiuta a scrivere comandi che possano essere eseguiti meglio
* È utile studiare come funziona
* Alcuni meccanismi vengono estratti e messi a disposizione di altri servizi

Componenti di un server:
1. Ottimizzatore (gestore delle interrogazioni)
   1. Stabilisce le strategie di accesso ai dati
2. Gestore dei metodi di accesso ai dati
   1. Trasforma le richieste dei comandi ad alto livello, in operazioni di lettura e scrittura in memoria secondaria
3. Gestore del buffer
   1. Gestisce il trasferimento delle pagine dalla memoria secondaria alla memoria principale
4. Controllore della concorrenza
   1. Gestisce gli accessi concorrenti
5. Controllore dell'affidabilità
   1. Garantisce il funzionamento in caso di guasti

## Transazioni

Definizione informale: Una unità elementare di lavoro a cui si vogliono associare particolari caratteristiche di correttezza, robustezza ed isolamento.

Un sistema (anche non DB) che mette a disposizione questi meccanismi è detto transazionale.

Si usano due comandi per incapsulare singole operazioni in una transazione:
* Begin
* End

La end è spesso implicita, si capisce dal contesto.
Se sono omesse entrambe, ogni istruzione è una transazione a se stante (modalità autocommit), è quello che accade di solito negli ambienti interattivi.

Quando raggruppiamo istruzioni in una transazione, possiamo vedere l'intera transazione come una unica istruzione.

Esistono due istruzioni speciali:
* Commit
  * Considero quello che ho fatto, definitivo
  * Viene fatta alla fine, quindi non serve la end
* Abort
  * Faccio un rollback a prima di iniziare la transazione
  * Viene fatta alla fine, quindi non serve la end

Nella stessa transazione non posso fare più di una di queste operazioni, non posso fare sia commit che abort, e non posso fare commit e poi aggiungere altri comandi e fare un'altra commit.

Posso scegliere se fare una o l'altra in base ai percorsi di esecuzione dell'applicazione.
Il sistema può forzare un abort se alcune cose vanno storte.

Eseguire il commit garantisce che i cambiamenti vengano memorizzati in modo permanente nella base di dati.

### Proprietà ACID (acide)

Proprietà
* Atomicità
  * Tutta la transazione è una sola operazione
  * O eseguo tutta la transazione, o non eseguo niente
  * Quindi devo essere in grado di disfare la transazione, se succede qualcosa per cui non posso copletarla. Facendo delle undo per annullare le operazioni già fatte
  * Non è possibile che una transazione che ha fatto la commit, non sia registrata permanentemente. A costo di dover rifare (redo) alcune operazioni
    * Il motivo dei redo viene spiegato più avanti, ha a che fare con la gestione del buffer
  * Un abort può avvenire per diversi motivi:
    * La transazione termina con un abort
    * Il sistema non è in grado di portare a termine l'operazione
      * A volte se dopo un certo tempo non riesce a completare un comando (dead lock), si considerà fallita l'operazione
    * Un guasto può abortire tutte le transazioni non completate
    * ...
  * Di norma vanno a buon fine, alcuni sistemi di gestione della concorrenza molto affidabili sono falliti proprio perché abortivano troppo spesso
  * Dopo aver abortito, di solito, l'applicazione fa ripartire la transazione, l'utente vede solo che è più lenta
* Consistenza
  * L'esecuzione non deve violare i vincoli di integrità definiti sulla base di dati
  * Eventualmente si può intervenite od annullare
  * Si può verificare la condizione ad ogni operazione
  * Si può differire il controllo alla commit
* Isolamento
  * L'esecuzione di una transazione deve essere logicamente indipendente da altre transazioni eseguite in contemporanea
  * Deve avere lo stesso effetto che avrebbe avuto se fosse stata eseguita senza altre transazioni concorrenti
  * In particolare, se una transazione fa rollback, non dovrebbero farlo anche le altre
    * Succede quando una transazione leggedati modificati da un'altra incompleta, e questa fa rollback
* Durability (persistenza)
  * È legata alla proprietà di atomicità, vengono entrambe garantite dal controllo dell'affidabilità
  * L'atomicità dice: "o tutto o niente"; la persistenza dice: "se tutto, allora per sempre"

## Gestione del buffer

Il buffer è una vasta porzione di memoria centrale preallocata al DBMS e condivisa tra le transazioni.

Visto che le memoria costano sempre di meno, i buffer diventano sempre più grandi, a volte si può anche inserire l'intera base nel buffer.

Nei casi reali, l'aumento della dimensione del buffer è stato bilanciato da un aumento della dimensione delle basi di dati.

Comunque, +grande=+meglio

Filtra i comandi del gestore dei metodi di accesso per raggiungere il suo obbiettivo.

L'obbiettivo del getore del buffer è mantenere porzioni del DB in memoria centrale per migliorare l'efficienza (il disco è lento), garantendo le proprietà di affidabilità.
Vengono definite delle politiche per garantire queste proprietà, che vengono usate per trasformare le operazioni svolte in memoria centrale (veloci) in operazioni della memoria secondaria.

I suoi compiti sono:
* Caricamento e scaricamento delle pagine
* Accesso alle pagine presenti nel buffer
  * Quando viene richiesto l'accesso ad una pagina, se è già in memoria centrale si accede. Altrimenti carica (ed eventualmente scarica qualcos'altro) e poi permette l'accesso

Deve interagire con lo scheduler per la gestione dei lock durante la concorrenza.

### Organizzazione del buffer

Il buffer è organizzato in pagine che hanno dimensione pari a uno o più blocchi di memoria secnodaria.

Il blocco è l'unità di trasferimento dei dati tra le due memorie.
In genere consideriamo una pagina del buffer grande come un blocco, ed ogni blocco grande diversi kB

### Gestione delle letture e delle scritture

Tutte le operazioni del DB si traduconoin letture e scritture.
Il gestore del buffer gestisce la tempistica delle operazioni per migliorare l'efficienza, può non essere quella richiesta.

In caso di lettura può non essre necessario accedere alla memoria secondaria.

In caso di scrittura, il gestore può ritardare la scrittura, se consintito dalle proprietà di affidabilità del sistema.

Spesso il gestore cambia gli ordini delle operazione senza avvisare i programmatori, per gestire più efficientemente la memoria.

Utilizza le stesse politiche che usa il sistema operativo per la gestione della memoria principale.

Valgono i soliti principi di località e di Pareto
* I dati acceduti di recente hanno maggiore probabilità di essere acceduti di nuovo
  * I dati adiacenti a quello acceduto di recente hanno maggiore probabilità di essere acceduti di nuovo
* L'80% degli effetti è prodotto sul 20% dei dati
  * Il 20% dei dati è acceduto dall'80% delle applicazioni
  * Quindi è più importante memorizzare in centrale questo 20% piuttosto che il  restante 80%

### Direttorio e variabili di stato

Per gestire il buffer vengono msantenute due strutture dati:
* Direttorio
  * Descrive il contenuto corrente del buffer
  * Indica per ogni pagina caricata, il file ed il blocco fisico
* Variabili di stato
  * Un contatore di programmi che usilizzano la pagina
  * Un bit di stato che specifica se è stata modificata

### Primitive per la gestione del buffer

Il buffer manager mette a disposizione delle transazioni, delle primitive di caricamento e scaricamento delle pagine:
* Fix
  * Richiede l'accesso ad una pagina e restituisce un riferimento alla pagina del buffer
* setDirty
  * Indica che la pagina è stata modificata
  * Modifica il bit di stato
* unfix
  * Indica che la pagina non è più in utilizzo
* Force
  * Forza la scrittura in modo sincrono della pagina in memoria secondaria
  * Resetta i bit di stato
  * Viene lanciata da un altro modulo del DBMS, non dalle transazioni

### Primitiva fix

Se non esiston pagine libere, ho due politiche alternative:
* Steal
  * Sottraggo una pagina ad una altra transazione vittima
  * Viene scaricata in memoria per poter caricare la nuova pagina
  * Quando la prima transazione richiederà di nuovo la pagina verrà di nuovo caricata in memoria
* No-Steal
  * Non consento di sottrarre le pagine
  * Viene sospesa la transazione che richiede la pagina finché non si liberano pagine

### Caricamento/scaricamento anticipato

Alcune transizioni dichiarano (o comunque è noto) quali pagine una transazione richiederà in futuro, alcune politiche di gestione della concorrenza prevedono alcune chiamate per questo.

Il buffer può scegliere di caricare in anticipo le pagine che saranno richieste in futuro, o non scaricare pagine libere che verranno chieste in futuro.

Se una pagina è stata liberata, il gestore può scaricarla in anticipo per rendere più efficienti fix successive (che non dovranno scaricare in secondaria la pagina).

### DBMS e file system

Il DBMS si appoggia al filesystem per alcune funzioni, poi crea una sua astrazione dei file, più efficiente pe gli scopi del db.

Primitive usate:
* Creare/Cancellare ed espandere file
* Leggere e scrivere singoli blocchi sui file
  * La gestione dei dati nei blocchi è gestita interamente dal database.
* Apertura e chiusura di un file

Modalità di accesso:
* Diretto
  * Legge un singolo blocco
  * read(fileid, block, buffer)
* Accesso seqeuenziale
  * Accede ad un numero disso di blicchi in modo sequenziale
  * read_seq(fileid, f-block, count, f-buffer)
* Operazioni di scrittura analoghe