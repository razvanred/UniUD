# Linguaggi di interrogazione

I linguaggi dei dbms si dividono in diversi tipi: dichiarazione, aggiornamento, interrogazione. A teoria faremo quelli di interrogazione.
Siamo in un contesto di relazionali, quindi useremo SQL.

Faremo sempre riferimento allo schema mutato da Elmasi-Navate del database aziendale.

## Algebra relazionale

Proprietà:
* Proprietà di chiusura
  * Le operazioni dell'algebra relazionale si applicano a relazioni e producono una relazione. Quindi possiamo iterare in sequenza più operazioni dell'algebra senza uscire dalle relazioni
  * Nel modello ER questa cosa non si può immaginare, perché dovremmo avere operazioni che partono da entità e relazioni e producono entità e relazioni. Ma nel relazionale è semplice perché sono insiemi
* L'interrogazione non cambia i contenuti della base di dati
  * In particolare non memorizza le relazioni intermedie e la relazione finale dell'interrogazione.
* Nell'algebra relazionale di base l'obbiettivo è di estrarre un'informazione dalla base di dati
  * Si limitano a selezionare informazioni, non a derivarne altre
  * Esistono operatori non dell'algebra di base che permettono di combinare le informazioni estratte per ottenerne altre.

Limiti dell'algebra relazionale:
* Le relazioni sono insiemi di ennuple **finiti**
  * L'insieme delle istanze di una tabella devono essere costruite seguendo dei vincoli, tra cui quello di dominio. Alcuni attributi hanno dominio infinito (es: $\N$)
    * Il dominio delle ennuple è il prodotto cartesiano dei domini di ogni attributo della relazione
  * Supponiamo di avere una relazione $piace(bambino, gusto\_gelato)$ in cui i domini sono finiti.
    * Se voglio ottenere i gusti che non piacciono ai bambini posso fare una operazione di complementazione rispetto all'universo del prodotto cartesiano $dom(bambino)\times dom(gusto\_gelato)$
  * Se provo fare questa complementazione su una relazione in cui anche un solo dominio non posso, perché sarebbe infinito, e devo restituire una relazione, che non può essere infinita.
  * Il sostituto della complementazione è la differenza insiemistica. Dovremo avere due relazioni, una con una porzione finita dell'universo, ed una che vogliamo complementare, ed eseguire la sottrazione.
* Non si può sempre assumere che l'informazione memorizzata sia completa
  * Posso comporre la relazione $non\_piace$ con la complementazione solo se ho la completezza delle informazioni nella relazione $piace$
  * Riportiamo il risultato di una gara podistica tra 3 atleti senza pari merito
    * La relazione avrà schema $precedenza(prima, dopo)$ dove $prima$ e $dopo$ sono due degli atleti
    * I dati riportati sono $(b,a),(c,a)$
  * Vogliamo complementare questa relazione per ottenere l'ordine invertito.
    * Otteniamo $(a,b),(a,c),(c,d),(d,c)$, che non ha senso, perché manca l'informazione sul chi è arrivato primo tra $c$ e $d$
* Nono consente di esprimere chiusure transitive
  * Pensiamo allo schema dei supervisori nell'azienda
  * Possiamo sapere chi è il supervisore diretto
  * Possiamo sapere anche chi è il supervisore del supervisore ed unire questa tabella alla precedente
  * Possiamo sapere l'ennesimo supervisore
  * Ma non possiamo sapere tutti i supervisori diretti od indiretti di un dipendente

## Operazioni di base

Elenco:
* Arietà 1
  * Selezione
  * Proiezione
* Arietà 2
  * Unione
  * Differenza
  * Fusione/Prodotto cartesiano
* Rinomina (esiste solo perché abbiamo dato il nome agliattributi)

Questo è un insieme completo delle operazioni sui modelli relazionali, ma noi non sappiamo ancora il perché (vedremo in futuro).

Non esistono altre operazioni di base, ma esistono delle operazioni derivate, come il join.
Nei linguaggi abbiamo anche delle altre funzioni, dette aggregate, che non sono ne derivate ne di base. Alcune non dovrebbero essere necessarie, ma le abbiamo per comodità. Altre sono solo in più.

Generalmente useremo $R$ come relazione argomento e $T$ come relazione risulato

### Selezione

Sintassi: $T\leftarrow\sigma_{cond}(R)$

Esempio: $T\leftarrow\sigma_{sipendio>50k}(impiegato)$ è la funzione prende la relazione degli impiegati e restituisce la relazione degli impiegati con tutti e soli gli impiegati con stipendio maggiore di 50k

Il grado di T è sempre lo stesso di R, $g(T)=g(R)$. La cardinalità di T, invece è sempre minore od uguale a quella di R, $0\leq|T|\leq|R|$

Quando abbiamo una relazione vuota l'ottimizzatore è felice, cerca di eseguire per prime le relazioni più selettive che gli permettono di lavorare con tabelle più piccole.

Si consideri $T\leftarrow\sigma_{cond1}(\sigma_{cond2}(R))$. Se la selezione $\sigma_{cond1}$ è più selettiva, l'ottimizzatore sceglierà di eseguire $T\leftarrow\sigma_{cond2}(\sigma_{cond1}(R))$ invece.
Entrambe equivalgono a $\sigma_{cond1\land cond2}(R)$, ma è meno interessante da questo punto di vista. L'ottimizzatore potrebbe anche decidere di utilizzare questa invece, ma qua dipende da come funziona l'implementazione.

In genere la condizione sarà una combinazione booleana (quindi con AND, OR, NOT, ed eventualmente parentesi) di condizioni semplici.

### Proiezione

Sintassi: $T\leftarrow\pi_{\langle i,...,j\rangle}(R)$ dove $\langle i,...,j\rangle$ è un sottoinsieme ordinato (una tupla) dello schema di $R$

A contrario della selezione, il grado $T$ cambia rispetto ad $R$, quindi $g(T)<g(R)$ (in realtà $0\leq g(T)\leq g(R)$, ma i casi uguali non sono interessanti). La cardinalità, invece, non cambia, quindi $|T|=|R|$

Esempio: $T\leftarrow\pi_{CF,stipendio}(impiegato)$ è la funzione che prende la relazione degli impiegati e restituisce la relazione dei codici fiscali e stipendi degli impiegati.

Concatenare le proiezioni, solitamente non è utile. $\pi_{a}(\pi_{b}(R))$ ha senso solo se $a\subseteq b$ ed è uquale ad $\pi_{a}(R)$.
Ha senso se vado a intervallare le proiezioni con delle altre operazioni.
Es: $T\leftarrow\pi_{CF}(\sigma_{sipendio>50k}(\pi_{CF,stipendio}(impiegato)))$

Posso intervallare e comporre qualsiasi sequenza di operazioni relazionali. È una caratteristica molto utile dell'algebra relazionale.

### Rinomina

Non è veramente un'operazione di base dell'algebra relazionale, dipende dalla nostra scelta di avere nomi per gli attributi.

Introduciamo nomi per le relazioni intermedie e nomi per la relazione finale.

Esempio: Abbiamo le operazioni: $T\leftarrow\sigma_{dipartimento=5}(impiegato)$ e $R\leftarrow\pi_{CF,stipendio}(T)$.
Vogliamo che i nomi degli attributi nella tabella $T$ siano gli stessi degli attribui iniziali, con suffisso 5.
Usiamo la notazione $T(nome5, dipartimento5, CF5, ...)\leftarrow\sigma_{dipartimento=5}(impiegato)$, $R\leftarrow\pi_{CF5, stipendio5}(T)$

Possiamo usare una notazione alternativa che non richiede di esplicitare tutti i nomi intermedi usando l'operatore $\rho$.
Quindi: $R\leftarrow\rho_{CF5, stipendio5}(\pi_{CF,stipendio}(\sigma_{dipartimento=5}(impiegato)))$

Il professore suggerisce quella verbosa.

Anche questa non è interessante da sola, ma è interessante unita ad altre operazioni.

### Unione

Per poter eseguire un unione ho bisogno che delle proiezioni delle relazioni siano compatibili rispetto all'unione, anzi, decono essere compatibili le relazioni, ma posso prima proiettarle per renderle compatibili.
Quindi compatibile rispetto all'unione significa che hanno: stesso grado, stesso nome degli attributi e con dominio e significato uguale.
Se hanno nomi diversi entra in gioco la rinomina.

In linguaggio SQL si può fare l'unione anche se i nomi sono diversi. La compatibilità rispetto all'unione si applica anche alla differenza.

Esempio: determinare il codice fiscale di tutti gli impiegati che appartengon al dipartimento 5 o sono diretti supervisori di un impiegato del dipartimento 5.
$$T1\leftarrow\pi_{CF}(\sigma_{dip=5}(impiegato))\\
T2(CF)\leftarrow\pi_{supervisore}(\sigma_{dip=5}(impiegato))\\
R\leftarrow T1\cup T2$$

Vale la proprietà commutativa e associativa. La cardinalità è al più la somma delle cardinalità, ed almeno il massimo delle due cardinalità, quindi $\max(|A|,|B|)\leq|A\cup B|\leq|A|+|B|$. Il grado, ovviamente non cambia.

### Differenza insiemistica

La usiamo come sostituto della complementazione. Richiede la compatibilità rispetto all'unione.

Sintassi: $T\leftarrow A\setminus B$

Non vale la proprietà commutativa e nemmeno associativa.

Il grado, ovviamente, non cambia. La cardinalità è al massimo quella del primo insieme, ed al minimo il massimo tra 0 e la cardinalità del primo meno quella del secondo, quindi $\max(0, |A|-|B|)\leq|A\setminus B|\leq|A|$

Si può usare per realizzare intersezioni $A\cap B=(A\cup B)\setminus((A\setminus B)\cup(B\setminus A))=A\setminus(A\setminus B)$

Esempio: CF degli impiegati senza persone a carico. In questi casi è più facile trovare al condizione complementata e poi utilizzare la differenza insiemistica (è in questo modo che implementiamo le condizioni negative)
$$Candidati\leftarrow\pi_{CF}(impiegato)\\
NoGood(CF)\leftarrow\pi_{imp}(persona\_a\_carico)\\
Good\leftarrow Candidati\setminus NoGood$$

### Prodotto cartesiano

I due schemi devono essere diversi, se ho collisioni di nomi utilizzo la rinomina per rimuoverle.

Sintassi: $T(A_1,...,A_n,B_1,...,B_n)\leftarrow R(A_1,...,A_n)\times S(B_1,...,B_n)$

Accoppio/concateno ogni tupla di $R$ con ogni tupla di $S$

Ottengo come grado la somma dei gradi e come cardinalità il prodotto delle cardinalità, quindi: $g(T)=g(R)+g(S)$ e $|T|=|R|*|S|$. Se una relazione e vuota anche il prodotto è vuoto.

Da sola non ha molto senso, si usa in combinazione con altre operazioni e così si ottengono operazioni derivate.

Esempio: Trovare l'elenco delle persone a carico degli impiegati di sesso femminile
$$imp\_fem\leftarrow\sigma_{sesso='F'}(impiegato)\\
CF\_imp\_fem\leftarrow\pi_{CF}(imp\_fem)\\
T\leftarrow CF\_imp\_fem\times persona\_a\_carico\\
R\leftarrow\pi_{CF,nome}(\sigma_{CF=imp}(T))$$

Quasi sempre vedremo prodotti cartesiani seguiti da selezione o da selezione e proiezione.
Quindi queste due (composizioni di prodotto, selezione ed eventuale proiezione) sono delle operazioni derivate che troviamo spesso nei linguaggi di interrogazione.

Se vogliamo confrontare tuple di tabelle diverse dobbiamo prima fare il prodotto cartesiano e poi una selezione su questo.

Esempio: Trovare gli impiegati che afferiscono allo stesso dipartimento, sotto forma di coppie di di impiegati, Le coppie vanno ordinate per evitare doppioni del tipo $(verdi,rossi)(rossi,verdi)$
$$impiegato1(CF1,nome1,...)\leftarrow impiegato\\
T\leftarrow impiegato\times impiegato1\\
T1\leftarrow\sigma_{dip=dip1}(T)\\
R\leftarrow\sigma_{CF<CF1}(T1)$$

Prima devo creare una copia della tabella iniziale senza clash di nomi. Adesso posso fare il prodotto cartesiano.
Dopo il prodotto cartesiano seleziono le coppie che mi interessano (quelle di impiegati nello stesso dipartimento)
E posso pulire il risultato selezionando le coppie utili ignorando i doppioni (sfrutto l'ordinamento interno alle coppie)

Esempio: Voglio un elenco di tutti gli impiegati con almeno 2 persone a carico
$$persona\_a\_carico1(imp1,...)\leftarrow persona\_a\_carico\\
T\leftarrow persona\_a\_carico\times persona\_a\_carico1\\
T1\leftarrow\sigma_{imp=imp1\land nome\neq nome1}(T)\\
R(CF)\leftarrow\pi_{imp}(T1)$$

Se volessi fare con almeno 3 persone a carico avrei seguito lo stesso procedimento ma con più copie della persona a carico
$$persona\_a\_carico1(imp1,...)\leftarrow persona\_a\_carico\\
persona\_a\_carico2(imp2,...)\leftarrow persona\_a\_carico\\
T\leftarrow persona\_a\_carico\times persona\_a\_carico1\times persona\_a\_carico2\\
T1\leftarrow\sigma_{imp=imp1\land imp=imp2\land nome\neq nome1\land nome1\neq nome2\land nome\neq nome2}(T)\\
R(CF)\leftarrow\pi_{imp}(T1)$$

Dato che le disuguaglianze non sono transitive devo aggiungere tutte le combinazioni nella selezione, mentre per le uguaglianze vale la proprietà, quindi basta aggiungere un solo controllo.

Se invece che cercare quelli con un numero minimo prestabilito di persone a carico, volessi qualcosa di più complesso, dovrei utilizzare le funzioni aggregate per contare le occorrenze di imp nella tabella persona_a_carico

## Operazioni derivate (dalle operazioni di base)

### Intersezione

Deriva da unione e sottrazione, la abbiamo già vista nella sottrazione e non c'è molto altro.

### Operazioni di Join (fusione)

Mette insieme il prodotto cartesiano e la operazione di selezione che segue

Sintassi: $R\Join_{cond}S = \sigma_{cond}(S\times R)$

Le condizioni di base che si possono usare sono del tipo {attributo1 confronto attributo2}. Spesso le condizioni vengono limitate a congiunzioni di condizioni di base.
Quando il join ha solo una condizione di base si chiama $\varTheta-Join$

Il natural join è un operazione di join in cui la condizione è sottintesa ed è un uguaglianza tra gli attributi omonimi.
Si scrive semplicemente come $A\Join B$.
Se non hanno attributi omonimi otteniamo un semplice prodotto cartesiano. In alcuni testi abbiamo il natural join come operazione di base al posto del prodotto cartesiano, dal momento che quest'ultimo è un caso particolare del natural join.

### Divisione

Esempio: Trovare gli impiegati che lavorano a tutti i progetti a cui lavora Mario Rossi.
Se l'impiegato lavora ad alcuni progetti a cui Rossi non lavora va bene comunque, se l'impiegato si perde alcuni dei progetti a cui lavora Rossi non va bene.
"Tutti" è una condizione universale, sono quelle che si basano sul per ogni: Per ogni progetto p, se Rossi lavora a p, allora ogni candidato lavora a p.
Sono condizioni difficili da esprimere in relazionale, mi riconduco a: Per escludere un candidato è suffuciente trovare un progetto a cui lavora Rossi e lui no. Adesso è una condizione esistenziale.