# Linguaggi di interrogazione

I linguaggi dei dbms si dividono in diversi tipi: dichiarazione, aggiornamento, interrogazione. A teoria faremo quelli di interrogazione.
Siamo in un contesto di relazionali, quindi useremo SQL.

Faremo sempre riferimento allo schema mutato da Elmasi-Navate del database aziendale.

## Algebra relazionale

Proprietà:
* Proprietà di chiusura
  * Le operazioni dell'algebra relazionale si applicano a relazioni e producono una relazione. Quindi possiamo iterare in sequenza più operazioni dell'algebra senza uscire dalle relazioni
  * Nel modello ER questa cosa non si può immaginare, perché dovremmo avere operazioni che partono da entità e relazioni e producono entità e relazioni. Ma nel relazionale è semplice perché sono insiemi
* L'interrogazione non cambia i contenuti della base di dati
  * In particolare non memorizza le relazioni intermedie e la relazione finale dell'interrogazione.
* Nell'algebra relazionale di base l'obbiettivo è di estrarre un'informazione dalla base di dati
  * Si limitano a selezionare informazioni, non a derivarne altre
  * Esistono operatori non dell'algebra di base che permettono di combinare le informazioni estratte per ottenerne altre.

Limiti dell'algebra relazionale:
* Le relazioni sono insiemi di ennuple **finiti**
  * L'insieme delle istanze di una tabella devono essere costruite seguendo dei vincoli, tra cui quello di dominio. Alcuni attributi hanno dominio infinito (es: $\N$)
    * Il dominio delle ennuple è il prodotto cartesiano dei domini di ogni attributo della relazione
  * Supponiamo di avere una relazione $piace(bambino, gusto\_gelato)$ in cui i domini sono finiti.
    * Se voglio ottenere i gusti che non piacciono ai bambini posso fare una operazione di complementazione rispetto all'universo del prodotto cartesiano $dom(bambino)\times dom(gusto\_gelato)$
  * Se provo fare questa complementazione su una relazione in cui anche un solo dominio non posso, perché sarebbe infinito, e devo restituire una relazione, che non può essere infinita.
  * Il sostituto della complementazione è la differenza insiemistica. Dovremo avere due relazioni, una con una porzione finita dell'universo, ed una che vogliamo complementare, ed eseguire la sottrazione.
* Non si può sempre assumere che l'informazione memorizzata sia completa
  * Posso comporre la relazione $non\_piace$ con la complementazione solo se ho la completezza delle informazioni nella relazione $piace$
  * Riportiamo il risultato di una gara podistica tra 3 atleti senza pari merito
    * La relazione avrà schema $precedenza(prima, dopo)$ dove $prima$ e $dopo$ sono due degli atleti
    * I dati riportati sono $(b,a),(c,a)$
  * Vogliamo complementare questa relazione per ottenere l'ordine invertito.
    * Otteniamo $(a,b),(a,c),(c,d),(d,c)$, che non ha senso, perché manca l'informazione sul chi è arrivato primo tra $c$ e $d$
* Nono consente di esprimere chiusure transitive
  * Pensiamo allo schema dei supervisori nell'azienda
  * Possiamo sapere chi è il supervisore diretto
  * Possiamo sapere anche chi è il supervisore del supervisore ed unire questa tabella alla precedente
  * Possiamo sapere l'ennesimo supervisore
  * Ma non possiamo sapere tutti i supervisori diretti od indiretti di un dipendente

## Operazioni di base

Elenco:
* Arietà 1
  * Selezione
  * Proiezione
* Arietà 2
  * Unione
  * Differenza
  * Fusione/Prodotto cartesiano
* Rinomina (esiste solo perché abbiamo dato il nome agliattributi)

Questo è un insieme completo delle operazioni sui modelli relazionali, ma noi non sappiamo ancora il perché (vedremo in futuro).

Non esistono altre operazioni di base, ma esistono delle operazioni derivate, come il join.
Nei linguaggi abbiamo anche delle altre funzioni, dette aggregate, che non sono ne derivate ne di base. Alcune non dovrebbero essere necessarie, ma le abbiamo per comodità. Altre sono solo in più.

Generalmente useremo $R$ come relazione argomento e $T$ come relazione risulato

### Selezione

Sintassi: $T\leftarrow\sigma_{cond}(R)$

Esempio: $T\leftarrow\sigma_{sipendio>50k}(impiegato)$ è la funzione prende la relazione degli impiegati e restituisce la relazione degli impiegati con tutti e soli gli impiegati con stipendio maggiore di 50k

Il grado di T è sempre lo stesso di R, $g(T)=g(R)$. La cardinalità di T, invece è sempre minore od uguale a quella di R, $0\leq|T|\leq|R|$

Quando abbiamo una relazione vuota l'ottimizzatore è felice, cerca di eseguire per prime le relazioni più selettive che gli permettono di lavorare con tabelle più piccole.

Si consideri $T\leftarrow\sigma_{cond1}(\sigma_{cond2}(R))$. Se la selezione $\sigma_{cond1}$ è più selettiva, l'ottimizzatore sceglierà di eseguire $T\leftarrow\sigma_{cond2}(\sigma_{cond1}(R))$ invece.
Entrambe equivalgono a $\sigma_{cond1\land cond2}(R)$, ma è meno interessante da questo punto di vista. L'ottimizzatore potrebbe anche decidere di utilizzare questa invece, ma qua dipende da come funziona l'implementazione.

In genere la condizione sarà una combinazione booleana (quindi con AND, OR, NOT, ed eventualmente parentesi) di condizioni semplici.

### Proiezione

Sintassi: $T\leftarrow\pi_{\langle i,...,j\rangle}(R)$ dove $\langle i,...,j\rangle$ è un sottoinsieme ordinato (una tupla) dello schema di $R$

A contrario della selezione, il grado $T$ cambia rispetto ad $R$, quindi $g(T)<g(R)$ (in realtà $0\leq g(T)\leq g(R)$, ma i casi uguali non sono interessanti). La cardinalità, invece, non cambia, quindi $|T|=|R|$

Esempio: $T\leftarrow\pi_{CF,stipendio}(impiegato)$ è la funzione che prende la relazione degli impiegati e restituisce la relazione dei codici fiscali e stipendi degli impiegati.

Concatenare le proiezioni, solitamente non è utile. $\pi_{a}(\pi_{b}(R))$ ha senso solo se $a\subseteq b$ ed è uquale ad $\pi_{a}(R)$.
Ha senso se vado a intervallare le proiezioni con delle altre operazioni.
Es: $T\leftarrow\pi_{CF}(\sigma_{sipendio>50k}(\pi_{CF,stipendio}(impiegato)))$

Posso intervallare e comporre qualsiasi sequenza di operazioni relazionali. È una caratteristica molto utile dell'algebra relazionale.

### Rinomina

Non è veramente un'operazione di base dell'algebra relazionale, dipende dalla nostra scelta di avere nomi per gli attributi.

Introduciamo nomi per le relazioni intermedie e nomi per la relazione finale.

Esempio: Abbiamo le operazioni: $T\leftarrow\sigma_{dipartimento=5}(impiegato)$ e $R\leftarrow\pi_{CF,stipendio}(T)$.
Vogliamo che i nomi degli attributi nella tabella $T$ siano gli stessi degli attribui iniziali, con suffisso 5.
Usiamo la notazione $T(nome5, dipartimento5, CF5, ...)\leftarrow\sigma_{dipartimento=5}(impiegato)$, $R\leftarrow\pi_{CF5, stipendio5}(T)$

Possiamo usare una notazione alternativa che non richiede di esplicitare tutti i nomi intermedi usando l'operatore $\rho$.
Quindi: $R\leftarrow\rho_{CF5, stipendio5}(\pi_{CF,stipendio}(\sigma_{dipartimento=5}(impiegato)))$

Il professore suggerisce quella verbosa.

Anche questa non è interessante da sola, ma è interessante unita ad altre operazioni.

### Unione

Per poter eseguire un unione ho bisogno che delle proiezioni delle relazioni siano compatibili rispetto all'unione, anzi, decono essere compatibili le relazioni, ma posso prima proiettarle per renderle compatibili.
Quindi compatibile rispetto all'unione significa che hanno: stesso grado, stesso nome degli attributi e con dominio e significato uguale.
Se hanno nomi diversi entra in gioco la rinomina.

In linguaggio SQL si può fare l'unione anche se i nomi sono diversi. La compatibilità rispetto all'unione si applica anche alla differenza.

Esempio: determinare il codice fiscale di tutti gli impiegati che appartengon al dipartimento 5 o sono diretti supervisori di un impiegato del dipartimento 5.
$$T1\leftarrow\pi_{CF}(\sigma_{dip=5}(impiegato))\\
T2(CF)\leftarrow\pi_{supervisore}(\sigma_{dip=5}(impiegato))\\
R\leftarrow T1\cup T2$$

Vale la proprietà commutativa e associativa. La cardinalità è al più la somma delle cardinalità, ed almeno il massimo delle due cardinalità, quindi $\max(|A|,|B|)\leq|A\cup B|\leq|A|+|B|$. Il grado, ovviamente non cambia.

### Differenza insiemistica

La usiamo come sostituto della complementazione. Richiede la compatibilità rispetto all'unione.

Sintassi: $T\leftarrow A\setminus B$

Non vale la proprietà commutativa e nemmeno associativa.

Il grado, ovviamente, non cambia. La cardinalità è al massimo quella del primo insieme, ed al minimo il massimo tra 0 e la cardinalità del primo meno quella del secondo, quindi $\max(0, |A|-|B|)\leq|A\setminus B|\leq|A|$

Si può usare per realizzare intersezioni $A\cap B=(A\cup B)\setminus((A\setminus B)\cup(B\setminus A))=A\setminus(A\setminus B)$

Esempio: CF degli impiegati senza persone a carico. In questi casi è più facile trovare al condizione complementata e poi utilizzare la differenza insiemistica (è in questo modo che implementiamo le condizioni negative)
$$Candidati\leftarrow\pi_{CF}(impiegato)\\
NoGood(CF)\leftarrow\pi_{imp}(persona\_a\_carico)\\
Good\leftarrow Candidati\setminus NoGood$$

### Prodotto cartesiano

I due schemi devono essere diversi, se ho collisioni di nomi utilizzo la rinomina per rimuoverle.

Sintassi: $T(A_1,...,A_n,B_1,...,B_n)\leftarrow R(A_1,...,A_n)\times S(B_1,...,B_n)$

Accoppio/concateno ogni tupla di $R$ con ogni tupla di $S$

Ottengo come grado la somma dei gradi e come cardinalità il prodotto delle cardinalità, quindi: $g(T)=g(R)+g(S)$ e $|T|=|R|*|S|$. Se una relazione e vuota anche il prodotto è vuoto.

Da sola non ha molto senso, si usa in combinazione con altre operazioni e così si ottengono operazioni derivate.

Esempio: Trovare l'elenco delle persone a carico degli impiegati di sesso femminile
$$imp\_fem\leftarrow\sigma_{sesso='F'}(impiegato)\\
CF\_imp\_fem\leftarrow\pi_{CF}(imp\_fem)\\
T\leftarrow CF\_imp\_fem\times persona\_a\_carico\\
R\leftarrow\pi_{CF,nome}(\sigma_{CF=imp}(T))$$

Quasi sempre vedremo prodotti cartesiani seguiti da selezione o da selezione e proiezione.
Quindi queste due (composizioni di prodotto, selezione ed eventuale proiezione) sono delle operazioni derivate che troviamo spesso nei linguaggi di interrogazione.

Se vogliamo confrontare tuple di tabelle diverse dobbiamo prima fare il prodotto cartesiano e poi una selezione su questo.

Esempio: Trovare gli impiegati che afferiscono allo stesso dipartimento, sotto forma di coppie di di impiegati, Le coppie vanno ordinate per evitare doppioni del tipo $(verdi,rossi)(rossi,verdi)$
$$impiegato1(CF1,nome1,...)\leftarrow impiegato\\
T\leftarrow impiegato\times impiegato1\\
T1\leftarrow\sigma_{dip=dip1}(T)\\
R\leftarrow\sigma_{CF<CF1}(T1)$$

Prima devo creare una copia della tabella iniziale senza clash di nomi. Adesso posso fare il prodotto cartesiano.
Dopo il prodotto cartesiano seleziono le coppie che mi interessano (quelle di impiegati nello stesso dipartimento)
E posso pulire il risultato selezionando le coppie utili ignorando i doppioni (sfrutto l'ordinamento interno alle coppie)

Esempio: Voglio un elenco di tutti gli impiegati con almeno 2 persone a carico
$$persona\_a\_carico1(imp1,...)\leftarrow persona\_a\_carico\\
T\leftarrow persona\_a\_carico\times persona\_a\_carico1\\
T1\leftarrow\sigma_{imp=imp1\land nome\neq nome1}(T)\\
R(CF)\leftarrow\pi_{imp}(T1)$$

Se volessi fare con almeno 3 persone a carico avrei seguito lo stesso procedimento ma con più copie della persona a carico
$$persona\_a\_carico1(imp1,...)\leftarrow persona\_a\_carico\\
persona\_a\_carico2(imp2,...)\leftarrow persona\_a\_carico\\
T\leftarrow persona\_a\_carico\times persona\_a\_carico1\times persona\_a\_carico2\\
T1\leftarrow\sigma_{imp=imp1\land imp=imp2\land nome\neq nome1\land nome1\neq nome2\land nome\neq nome2}(T)\\
R(CF)\leftarrow\pi_{imp}(T1)$$

Dato che le disuguaglianze non sono transitive devo aggiungere tutte le combinazioni nella selezione, mentre per le uguaglianze vale la proprietà, quindi basta aggiungere un solo controllo.

Se invece che cercare quelli con un numero minimo prestabilito di persone a carico, volessi qualcosa di più complesso, dovrei utilizzare le funzioni aggregate per contare le occorrenze di imp nella tabella persona_a_carico

## Operazioni derivate (dalle operazioni di base)

### Intersezione

Deriva da unione e sottrazione, la abbiamo già vista nella sottrazione e non c'è molto altro.

### Operazioni di Join (fusione)

Mette insieme il prodotto cartesiano e la operazione di selezione che segue

Sintassi: $R\Join_{cond}S = \sigma_{cond}(S\times R)$

Le condizioni di base che si possono usare sono del tipo {attributo1 confronto attributo2}. Spesso le condizioni vengono limitate a congiunzioni di condizioni di base.
Quando il join ha solo una condizione di base si chiama $\varTheta-Join$

Il natural join è un operazione di join in cui la condizione è sottintesa ed è un uguaglianza tra gli attributi omonimi.
Si scrive semplicemente come $A\Join B$.

Se non hanno attributi omonimi otteniamo un semplice prodotto cartesiano. In alcuni testi abbiamo il natural join come operazione di base al posto del prodotto cartesiano, dal momento che quest'ultimo è un caso particolare del natural join.

Se hanno solo attributi omonimi il join naturale è l'intersezione delle due relazioni.

### Divisione

Esempio: Trovare gli impiegati che lavorano a tutti i progetti a cui lavora Mario Rossi.
Se l'impiegato lavora ad alcuni progetti a cui Rossi non lavora va bene comunque, se l'impiegato si perde alcuni dei progetti a cui lavora Rossi non va bene.
"Tutti" è una condizione universale, sono quelle che si basano sul per ogni: Per ogni progetto p, se Rossi lavora a p, allora ogni candidato lavora a p.
Sono condizioni difficili da esprimere in relazionale, mi riconduco a: Per escludere un candidato è suffuciente trovare un progetto a cui lavora Rossi e lui no. Adesso è una condizione esistenziale.

Capiremo come fare dal [secondo esercizio](#esercizio-2)

## Operazioni addizionali

### Semi-Join

Voglio trovare le informazioni disponibili (nella tabella impiegato) sui manager.
Se dovessi riportare solo le informazioni sugli impiegati restituirei la tabella, e se dovessi trovare quelli di un dipartimento fare i una selezione.
In questo caso devo trovare i manager dalla tabella del dipartimento, ma poi le informazioni si ottengono dalla tabella impiegato.

Per fare questo si utilizza l'operazione derivata semijoin (Non c'è il simbolo su markdown, ma se $\Join$ assomiglia a |><|, il semijoin assomiglia a |><, quindi con un lato aperto. In questa sezione userò $\propto$ per indicarlo)

Quindi, se ho $R(r_1,r_1,...,r_n)$ e $S(s_1,s_2,...,s_m)$. Allora $R\propto S=\pi_{r_1,r_2,...,r_n}(R\Join S)$.

È un Join naturale in cui proietto tutti e soli gli attributi di una delle due tabelle, quella dal lato chiuso.

### Join Esterno (Outer Join)

È una variante del join.

Esempio: Vogliamo riportare le informazioni disponibili sugli impiegati (nella tabella impiegato)in più, nel caso dei manager, quelle del dipartimento che gestisco.

Il problema è che la risposta dovrebbe avere due formati diversi. Nel caso dei dei manager avrei un Join con i dipartimenti, nel caso degli impiegati normali avrei una normale selezione della tabella impiegato.

Per fare questo si fa un Join Esterno Sinistro: $R\leftarrow impiegato=\Join_{CF=Manager} dipartimento$.
Questo riporta: per tutti gli impiegati che sono manager, una tupla con anche le informazioni del dipartimento; e per tutti gli altri, una tupla con tutte le informazioni che voglio dalla tabella impiegato, e NULL su tutte le altre.
Se alcune delle tuple dipartimento non hanno un manager (che in questo caso non è possibile) non compaiono nel join.

Il grado di $R$ è la somma dei gradi delle due relazioni. La cardinalità di R è la cardinalità della relazione a sinistra.

Tipologie di Join esterno:
* Sinistro $=\Join$
  * Include anche le tuple a sinistra non in relazione a destra
* Destro $\Join=$
  * Include anche le tuple a destra non in relazione a sinistra
* Completo $=\Join=$
  * Include anche le tuple non in relazione con tuple dell'altra tabella
  * La cardinalità è come quella dell'unione (in effetti assomiglia ad un unione di relazioni non compatibili)

Capita più di frequende del semijoin. Si può implementare in modo un po' complicato. I linguaggi come SQL lo forniscono già pronto.

### Funzioni aggregate

Sono delle funzioni che eseguono delle determinate operazioni sul contenuto del labase di dati.
In tutte se operazioni che abbiamo visto finora abbiamo solo la possibilità di selezionare dati già presenti nella base, non di calcolarne di nuove.

Operazioni più comuni:
* Count
  * Necessario solo quando occorre contare in modo unbounded
  * Quindi tutti quei casi in cui dobbiamo contare in base ad una costante, non serve, infatti lo abbiamo fatto già diverse volte
* Sum
* Aerage
* ...

Operazioni che possono essere implementate con algebrea relazionale:
* Maximum
* Minimum

#### Esempio

Vogliamo recuperare il numero degl impiegati, gli stipendi massimi e minimi, la media degli stipendi, la somma degli stipendi

$R\leftarrow\mathcal{F}_{Count\space CF,Sum\space stipendio,Avg\space stipendio,Max\space stipendio,Min\space stipendio}(impiegato)$

È uno strumento molto potente, ma il risultato è poco imortante nell'algebrea relazionale, perché produce una tabella con una sola tupla.

### Partizione

Possiamo raggruppare le tuple di una relazione in delle partizioni in base al valore degli attributi, per eseguire le funzioni aggregate in ciascuno di questi e produrre più tuple.

Nei sistemi standard si può usare solo il valore di uno o più attributi, ma in teoria si potrebbero usare anche condizioni più particolari.
Non sono veramente necessarie, ma in caso possiamo produrre una relazione intermedia per produrre un nuovo attributo, ed utilizzare poi la condizione standard.

La notazione prevede di avereaggiungere gli attributi della partizione in apice davanti alla $\mathcal{F}$. Per comodità li scriveremo in apice.

Esempio: Vogliamo contare gli impiegati divisi per dipartimento e sesso, e calcolare la media dei loro stipendi.
$$R\leftarrow\mathcal{F}^{Dipartimento,Sesso}_{Count\space CF,Avg\space stipendio} impiegato$$

Avremo una tupla per ogni classe della partizione.

Count permette anche di contare i valori distinti, scrivendo `COUNT DISTINCT STIPENDIO`, in contrapposizione alla modalità standard che conta tutti gli stipendi `COUNT ALL STIPENDIO` (il `ALL` è sottinteso).
Teoricamente si possono usare anche sulle altre funzioni aggregate, ma non hanno senso.

### Massimo/Minimo

Esempio (esercizio 1 del 8/09/2017): Vogliamo l'elenco degli impiegati che percepiscono lo stipendio massimo

Abbiamo già visto che possiamo trovarli con le funzioni aggregate.
$$T\leftarrow\mathcal{F}_{Max\space stipendio}(impiegato)\\
R\leftarrow\pi_{cf}(\sigma_{Max=Stipendio}(T\Join impiegato))$$

Come lo realizziamo senza?

Il massimo è quello che non ha nessuno più grande, quindi cerchiamo tutti quelli che hanno qualcuno più grande e li escludiamo.
$$Impiegato1(CF1,...)\leftarrow Impiegato\\
NoGood\leftarrow\pi_{CF}(Impiegato\Join_{Stipendio<Stipendio1} Impiegato1)\\
R\leftarrow Impiegato\setminus NoGood$$

Ovviamente, da $Impiegato\setminus NoGood$ possiamo ottenere lo stipendio massimo selezionando una qualsiasi tupla e proiettando lo stipendio.

## Esercizio 1

Trovare gli attori con al più due film con il regista Allen (anche 0).
Trovo tutti gli attori con almeno 3 film con Allen, seleziono tutti gli attori meno questi.

$$FilmAllen\leftarrow\pi_{Film,Attore}(\sigma_{Regista="Allen"}(film)\Join_{CodiceFilm=Film}interpretazione)\\
FilmAllen1(Film1,attore1)\leftarrow FilmAllen(Film,Attore)\\
FilmAllen2(Film2,attore2)\leftarrow FilmAllen(Film,Attore)\\
T\leftarrow FilmAllen\Join_{Attore=Attore1\land Film\neq Film1} FilmAllen1\\
NoGood\leftarrow\pi_{Attore}(T\Join_{Attore=Attore2\land Film\neq Film2\land Film1\neq Film2} FilmAllen2)\\
Candidati\leftarrow\pi_{Attore}(Attore)\\
R\leftarrow Candidati\setminus NoGood$$

## Esercizio 2

Trovare tutti gli attori che hanno recitato a tutti i film di Antonioni (È lo stesso caso della divisione).
È uno dei pochi casi in cui il prodotto cartesiano è esattamente quello di cui ho bisogno.
Il prodotto cartesiano di tutti attori e film di Antonioni mi dà per ogni attore tutte le tuple che dovrei trovare nella relazione perché l'attore partecipi a tutti i film.
Con la differenza trovo quali di queste tuple non sono presenti nella vera relazione.
Tutti gli attori che compaiono in queste tuple non partecipano a tutti i film di Antonioni, posso con una differenza trovare tutti gli attori che non compaiono in queste tuple, quindi che al contrario partecipano a tutti i film.

$$FilmAnto\leftarrow\pi_{CodiceFilm}(\sigma_{Regista="Antonioni"}(film))\\
Requisiti(Film,Attore)\leftarrow FilmAnto\times \pi_{CodiceAttore}(Attore)\\
StatoDiFatto\leftarrow \pi_{Film,Attore}(Interpretazione)\\
NoGood\leftarrow \pi_{Attore}(Requisiti\setminus StatoDiFatto)\\
Candidati\leftarrow\pi_{Attore}(Attore)\\
R\leftarrow Candidati\setminus NoGood$$

Si può usare l'operatore derivato di divisione: $R\leftarrow StatoDiFatto\div FilmAnto$.
Ma il professore non lo vuole all'esame.