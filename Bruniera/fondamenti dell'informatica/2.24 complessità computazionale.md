# Complessità Computazionale

Durante il corso abbiamo analizzato proprietà di $\Sigma^*$ e di sottoinsiemi di $\N$ (tra laltro $\Sigma^*$ e $\N$ sono equicardinali)

I linguaggi erano classificati per tipo:
* Tipo 0
* Tipo 1
* CF
* Regolari

I sottoinsiemi di $\N$ erano classificati come:
* Non r.e.
* r.e.
* Ricorsivi
* Banali

In questa parte del corso analizzaremo i problemi per capire se si può trovare un algoritmo efficiente per risolverlo. Negli altri corsi ceravamo l'algoritmo e ne analizzavamo la complessità. Ora vediamo la complessità come una proprietà del problema prendendo in esame:

* Problema (generale)?
* Alfabeto?
* Decidibile?
* Decisionale vs Funzionale?

## Istanze $yes$, $no$, non-istanze

Consideriamo il problema. dato un grafo $G=\langle N,E\rangle$, il grafo è connesso? Pertanto ci saranno:
* istanze $yes$ come $G=\langle\{1,2\},\{\{1,2\}\}\rangle$
* istanze $no$ come $G=\langle\{1,2\},\emptyset\rangle$
* non-istanze come $G=pippo$

Un istanza è un caso particolare del problema. Ad esempio se il problema è la somma, un istanza è $3+6$. Un istanza è una stringa di $\Sigma^*$. Ad ogni istanza corrisponderà un output, od un'assenza di output, se è una non-istanza.

Il linguaggio associato al provlema sarà l'insieme delle istanze $yes$, ovvero $L=\{x\in\Sigma^*:x$ "verifica la condizione" del problema$\}$

Verificare se un caso particolare è una non-istanza è semplice, quando mi aspetto un grafo e trovo qualcos'altro è una non-istanza. Immaginate di scrivere un programma che somma due interi e di passargli due stringhe. A seconda del linguaggio di programmazione si bloccherà la compilazione o l'esecuzione.

## Dimensione dell'input

$x\in L$ se e solo se l'istanza del problema $(x)$ ammette una soluzione. La dimenzione dell'input è dunque la lunghezza della stringa $x$ denotata de $|x|$.

### Numeri

* $n$ in base 10 ha bisogno di $\lceil\log_{10}n\rceil$ cifre
* $n$ in base 2 ha bisogno di $\lceil\log_2n\rceil$ cifre
  * Es: $8589934592=1000000000000000000000000000000000$
* Sappiamo che: $\log_2n=\log_{10}n*\log_210\approx3.32\log_{10}n$
  * L'input differisce di una costante moltiplicativa. La notazione asintotica la ignora
* Se usassimo la base $1$ (notazione unaria) $8589934592=0000000...0000$ con $2^{33}$ zeri
  * L'input crescerebbe in modo esponenziale rispetto ad altre basi

Possiamo usare qualunque base tranne la base $1$ perché non c'è una costante moltiplicativa e la dimensione dell'input aumenterebbe troppo. Potevamo usare questa base solo per facilitare le dimostrazioni con le MdT

## Decisionale e Funzionale

Consideriamo un algoritmo $P_1$ che prende $x$ in input e restituisce $f(x)$ ed uno $P_2$ che prende $x$ in input e restituisce $yes/no$.

Usando $P_1$ so risolvere anche $P_2$

## Riassunto

* L'istanza di un problema è una stringa in $\Sigma^*$
* Un problema (un linguaggio): è un sottoinsieme di 

## Macchina di turing a $K$ nastri

**definizione**: Una K-MdT è una macchina di turing $M=\langle Q,\Sigma,q_0,P\rangle$ con $K$-nastri.

1. $Q$ è l'insieme finito degli stati e $q_0\in Q$ è lo stato iniziale
2. $\Sigma$ è l'alfabeto dei simboli presenti dul nastro. Assumiamo che i simboli $\triangleright$ (first) e $\$$ (blank) appartengano a $\Sigma$
3. L'insieme delle istruzioni $P$ rappresenta una funzione 

//TODO

La *configurazione iniziale* è del tipo: $(q_0,\varepsilon,\triangleright,x,\varepsilon,\triangleright,\varepsilon,...,\varepsilon,\triangleright,\varepsilon)$

