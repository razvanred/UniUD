# Analisi dell'errore: Il calcolatore

## Numeri reali

I numeri reali sono infiniti ed in generale sono necessarie infinite cifre $di$ per la loro rappresentazione in base $B\geq 2, B\in N$.

$R = \{0\} \cup \{\pm (d_1B^{-1}+d_2B^{-2}+...) * B^p | d_1\in N,0\leq d_i \leq B-1, d_i$ non definitivamente $=B-1, p\in Z\}$

### Numeri normalizzati

il sistema di numeri di macchina è il sottointieme $F:=F(B,t,p_{min},p_{max})$ di $R$ definito da:

$F = \{0\} \cup \{\pm (d_1B^{-1}+d_2B^{-2}+...+d_tB^{-t}) * B^p | 0\leq di\leq B-1, i=1,...,t,d_1\neq 0,-p_{min}\leq p\leq p_{max}\}$

ed è carratterizzato da 4 interi:
* $B$: base
* $t$: numero di cifre di mantissa
* $p_{min}, p_{max} > 0$: limitazioni inferiori e superiori dell'esponente

proprietà:
* l'insieme è finito e la sua cardinalità è: $1+2(B-1)B^{t-1}(pmax+pmin+1)$
* il più piccolo numero positivo normalizzato è: $realmin = B^{-p_{min}-1}$
* il più piccolo numero positivo normalizzato è: $realmax = B^{p_{max}}(1-B^{-t})$
* non sono uniformemente distribuiti
* sono equispaziati solo tra due potenze successive di $B$

### Numeri denormalizzati

l'insieme di macchina $F$ può essere eseteso includento anche i numeri denormalizzati, che sono i reali con cifra significativa principale $d_1=0$ e con esponente $p=-p_{min}$

tali numeri sono distribuiti tra $\pm realmin$ e lo $0$, e sono equispaziati con spaziatura pari a $B^{-p_{min}-t}$

### Approssimazione dei numeri reali

Solitamente i calcolatori laborano in una base $B\neq 10$, pertanto anche il numero che è rappresentabile con un numero finito di cifre decimali, può richiedere un numero infinito di cifre per la rappresentazione in base diversa

```
0.3 B10 = 0.0100110011001... B2
```

Dobbiamo definire un'applicazione $fl: R \rightarrow F$ che:
* segnala un overflow se $|x| > realmax$ 
* segnala un underflow se $|x| < realmin$. (in alcuni sistemi ) $fl(x)$ viene posto a 0
* $fl(x) = x$ se $x\in F$
* altrimenti scelgo una delle seguenti strategie:
  * troncamento: la mantissa viene troncata alla t-esima cifra
  * arrotondamento: $fl(x)$ è il numero macchina più vicino a $x$. Se è equidistante da due numeri macchina si sceglie una delle seguenti strategie
    * round away from zero: $fl(x)$ è il numero più grande dei due
    * round to even: $fl(x)$ è il numero con la cifra $d_t$ pari

### Precisione di macchina

L'accuratezza di un sistema di numeri macchian ha una definita precisione di macchina $u$

Ogni numero reale nel range di $F$ darà approssimato da $fl(x)$ con un errore relativo maggiorato dalla precisione di macchina $u$

$\epsilon x = \frac{|fl(x)-x|}{|x|} \leq u$

* $u := B^{1-t}$ nel caso di troncamento
* $u := \frac{B^{1-t}}{2}$ nel caso di arrotondamento

### Standart IEEE-DP (1985)

$F(2,53,1021,1024)$

* $realmin = 2^{-1022} \simeq 2.2251E-308$
* $realmax = 2^{1024}(1−2^{−53}) \simeq 1.7977E+308$
* $u = 2^{-53} ~=1.11E-16$ (arrotondamento alla cifra pari)

L'esponente può assumere valori speciali:
* $p=-1022, d_2...d_{53} = 0$ rappresentazione dello 0
* $p=-1022, d_2...d_{53} \neq 0$ numeri denormalizzati
* $p=1025, d_2...d_{53} = 0$ infinito
* $p=1025, d_2...d_{53} \neq 0$ NaN

### Aritmetica di macchina

Non è detto che la somma (o altre operazioni elementari) di due numeri di macchina abbia come risultato esatto un numero di macchina

* Lo shift della mantissa necessario per la somma può causare la perdita anche di tutte le cifre di mantissa
* Il prodotto di due mantisse contiene fino a $2t$ cifre è il risultato esatto può non essere rappresentabile o causare overflow
* Il quoziente di due mantisse può contenere più di $t$ cifre (anche infinite) e non essere rappresentabile

#### modello di calcolo

Per analizzare gli errori di arrotondamento servono delle assunzioni sull'accuratezza delle operazioni elementari. Utilizziamo in esame questo modello

* Tutte le operazioni elementari sono calcolate in modo da avere $err_{op} = \frac{|x_1fl(op)x_2)-(x_1(op)x_2)|}{|x_1(op)x_2|} \leq u$, $op=\pm, /, *$
* Si considera valida anche per $op=\sqrt{}$
* Il modello asserisce che il valore calcolato è "buono" quanto il valore ottenuto arrotondando il valore esatto. $x_1fl(op)x_2 = fl(x_1(op)x_2)$

#### limiti dell'aritmetica di macchina

L'aritmetica di macchian non soddisfa tutte le proprietà dell'aritmetica esatta. 

* Si conservano le proprietà commutative di somma e prodotto
* Non si conservano:
  * le proprietà associative di somma e prodotto
  * la proprietà distributiva della somma rispetto al prodotto
  * la legge di cancellazione

Pertanto, in aritmetica di macchina, **algoritmi matematicamente equivalenti possono non esserlo numericamente**

### Errore nel calcolo di una funzione $f:R\rightarrow R$

Prendiamo un esame il problema del calcolo del valore $y=f(x)$. Dove $x\in R=$ dato in input e $y\in R=$ dato in output

**Osservazione**: Tutte le definizioni che seguono di ettore possono essere estese al caso generale di $y=F(x)$ con $F:R^n\rightarrow R^m, n\geq 1, m\geq 1$ usando le norme.

Sia $g$ la funzione che rappresenta l'algoritmo sceldo per approssimare la funzione $f$ in aritmetica esatta e sia $\tilde g$ la funzione effettivamente calcolata in aritmetica di macchina

${x\rightarrow y=f(x)}\\{\updownarrow \quad\quad \updownarrow}\\{\tilde x\rightarrow\tilde g(\tilde x)}$

In prima approssimazione risulta:

$err_{totale}=\frac{f(x)-\tilde g(\tilde x)}{f(x)}=err_{inerente}+err_{analitico}+err_{algoritmico}$

$err_{inerente}=\frac{f(x)-f(\tilde x)}{f(x)}\\err_{analitico}=\frac{f(\tilde x)-g(\tilde x)}{f(\tilde x)}\\err_{algoritmico}=\frac{g(\tilde x)-\tilde g(\tilde x)}{\tilde g(\tilde x)}$

L'accuratezza viene misurata dall'errore totale e dipende da tutte le componenti.

#### Errore inerente e condizionamento

Esistono problemi tali che qualunque algoritmo venga utilizzato, l'errore generato risulta elevato e talvolta privo di significato. èp una particolarità intrinseca del problema

L'errore inerente è legato al problema assegnato e studia l'effetto degli errori. 

Il problema si dice **ben condizionato** se non amplifica gli errori nei dati. Un errore relativo nell'input provoca un errore relativo dello stesso ordine di grandezza nell'output

Il problema si dice **mal condizionato** se non se non amplifica gli errori nei dati

Il condizionamento di misura della funzione $f$:

$cond_f(x):=\frac{|errore_{risposta}|}{|errore_{dato}|}=\frac{|f(x)-f(\tilde x)||x|}{|f(x)||x-\tilde x|}$

Il problema $f$ è mal condizionato se $cond_f(x)\gggtr1$. se la funzione $f$ è differenziabile due volte in un intorno $x$, otteniamo in prima approssimazione:

$cond_f(x)=\frac{|f'(x)||x|}{|f(x)|}$

Osserviamo che il condizionamento dipende anche dal dato $x$ non solo da $f$

```
Se il problema è mal condizionato cerchiamo una riformulazione matematicamente equivalente ma con indice di condizionamento migliore
```

#### Condizionamento di una funzione $F:R^n\rightarrow R$

Usando la formula di Taylor si trova:

$\frac{F(\tilde x)-F(x)}{F(x)}=\sum\limits^n_{i=1}(\frac{x_i}{F(x)}\frac{\delta F(x)}{\delta x_i})\frac{(\tilde x_i-x_i)}{x_i}$

Dove $x=(x_1,...-x_n),\tilde x=(\tilde x_1,...,\tilde x_n)\in R^n$.

$|err_{inerente}|\leq\sum\limits^n_{i=1}|c_i(x)|\epsilon_{x_i}$

Dove $\epsilon_{x_i}$ è l'errore relatico al dato i-esimo e $c_i(x):=\frac{x_i}{F(x)}\frac{\delta F(x)}{\delta x_i}$ è il coefficiente di amplificazione ad esso relativo. I coefficienti di amplificazione forniscono una misura del condizionamento

* La somma di n numeri è ben condizionata quando i numeri sono di segno concorde. Più i numeri sono discordi più il condizionamento peggiora (cancellazione)
* Il prodotto di n numeri è sempre ben condizionato
