# Memoization e Dynamic Programming

##### (esem. 1.13)

## 13.1 Memoization

### 13.1.1 Fibonacci

```java
    public static int fib(int n){
        if(n<2){
            return 1;
        } else {
            return fib(n-1)+fib(n-2);
        }
    }
```

il nostro obbiettivo è migliorare l'efficienza di questa funzione che calcola i numeri di fibonacci

il primo metodo consiste nel salvare i valori che calcoliamo in previsione di una richiesta successiva. nel caso un valore sia gia stato calcolato non sarà più necessario ricalcolarlo ma semplicemente leggerlo.

per realizzare questa tecnica il modo più semplice è un array dove abbiamo una corrispondenza diretta tra gli argomenti della funzione e l'indice del vettore. non è obbligatorio e non sempre è la scelta migliore, ma spesso lo è.

```java pseudo
    public static int fibR(int n, h){
        if(h(n) sconosciuto){
            if(n<2){
                return 1;
            } else {
                h(n) = fibR(n-1,h)+fibR(n-2,h);
            }
        }   
        return h(n);
    } 
```
si vuole realizzare una funzione del genere dove prima di eseguire l'operazione ricorsiva si verifica che il valore non sia stato calcolato (che il risultato associato allo stato sia sconosciuto)
se è sconosciuto si calcola e si memorizza, altrimenti no
in ogni caso si restituisce il valore memorizzato (che lo fosse da prima o che fosse stato appena memorizzato)

in questo caso si vuole utilizzare un array di interi dove ogni indice corrisponde al valore dell' argomento n e il valore dell'array vale un qualsiasi valore minore di 0 se è sconosciuto, altrimenti il valore della sequenza.

un'altra soluzione sarebbe quella di usare anche un array di booleani per indicare se il valore è conosciuto o no, ma non è necessario in questo caso perché i valori di fibonacci sono sempre maggiori di 0

```java
    public static int fib(int n){
        int[] h=new int[n+1];
        for(int i=0;i<=n; 1++){
            h[i]=UNKNOWN;
        }
        return fibR(n, h);
    }
    
    private static int fibR(int n, int[] h){
        if(h[n]==UNKNOWN){
            if(n<2){
                return 1;
            } else {
                h[n]= fibR(n-1,h)+fibR(n-2,h);
            }
        }
        return h[n];
    }
```

le precedenti due funzioni risolvono il problema utilizzando la memoization, la prima funzione serve perché il programmatore non ha interesse nel sapere come la nostra funzione è resa più efficiente, ma solo che il risultato arrivi. l'array viene inizializzato ad UNKNOWN ma in java non è veramente necessario.

ora è possibile calcolare istantaneamente anche il 100° numero della sequenza, ma a questo punto gli int permettono di rappresentare solo fino al 45°. utilizzando i long si può arrivare fino a 91°. volendo si può utilizzare la classe BigInteger che permette di avere numeri interi illimitati come in scheme

### 13.1.2

``` java
    public static long manh(int i, int j){
        if(i==0||j==0){
            return 1;
        } else {
            return manh(i-1,j)+manh(i,j-1);
        }
    }
```

si vuole migliorare le prestazioni della funzione di manhattan utilizzando la memoization.

il problema da risolvere è come rappresentare in una struttura di dati tutti i possibili stati della funzione

si decide di utilizzare una matrice bidimensionale che associa ciascuno dei due argomenti ai due indici della matrice.
si può ottimizzare ulteriormente sfruttando la simmetricit della funzione e altre proprietà del coefficiente binomiale

```java
    public static long manh(int i, int j){
      long[][] h=new long[i+1][j+1];
        for(int x=0;x<i;x++){
            for(int y=0;y<j;y++){
                h[x][y]=UNKNOWN;
             }
        }
        return manhR(i,j,h);
    }
  
    private static long manhR(int i, int j, long[][] h){
        if(h[i][j]==UNKNOWN){
            if(i==0||j==0){
                h[i][j] = 1;
            } else {
                h[i][j] = manhR(i-1,j,h)+manhR(i,j-1,h);
            }
        }
        return h[i][j];
    }
```

questa è la soluzione che si ottiene ignorando le ulteriori ottimizzazioni, si nota che la ricorsione produce un ordine in cui viene compilata la tabella partendo da i valori inseriti nei passaggi precedenti e mettendo 1 nei casi base

è possibile scrivere una funzione che compili la tabella senza direttamente evitando la ricorsione

```java
    public static long manh2(int i, int j){
        long[][] h=new long[i+1][j+1];
        for(int x=0;x<=i;x++){
            h[x][0]=1;
        }
        for(int y=1;y<=j;y++){
            h[0][y]=1;
        }
        for(int x=1;x<=i;x++){
            for(int y=1;y<=j;y++){
                h[x][y]=h[x-1][y]+h[x][y-1];
            }
        }
        return h[i][j];
    }
```

la funzione così ottenutà è assolutamente equivalente alla precedente funzione ricorsiva se non leggermente più efficiente per il semplice fatto di evitare di richiamare più volte la funzione

i primi due cicli compilano i casi base mentre il terzo ciclo annidato compila una alla volta tutte le celle della tabella sommando i valori salvati nelle precedenti iterazioni.