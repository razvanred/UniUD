# Programmazione logica

Dobbiamo definire una semantica, ovvero quali passaggi servono per ottenere le risposte calcolate.

Può essere una descrizione molto logica (la semantica $S(P)$) oppure proprio la computazione da eseguire per trovare la risposta (il behaviour del programma $B[P]$).

Dipende molto da che proprietà vogliamo scoprire.

Possiamo definire $B[P]=\{(G,\theta)|G\rightarrow^\theta_P\Box\}$

Una semantica è *corretta* rispetto ad un behaviour se $S[P_1]=S[P_2]\rightarrow B[P_1]=B[P_2]$.
Fissato un comportamento che vogliamo avere, cerchiamo la semantica che concorda col comportamento.

L'implicazione è vera anche se programmi con semantica diversa hanno comportamento diverso, questo significa che la semantica ha più informazioni di quelle che servono.\
Se diventa una doppia implicazione di dice *fully abstract*.

Ovviamente possiamo prendere come semantica il behaviour stesso è sempre fully abstract, ma non serve a niente.

Una interpretazione $I\in\mathbb I$ è una funzione che va dall'insieme di tutti i predicati $MGC$ all'insieme delle sostituzioni (assegnamenti di valori alle variabili all'interno del predicato).
Otterremo una semantica un po' più generale della semantica delle conseguenze immediate

Una semantica che corretta è $T^A_P:\mathbb I\mapsto\mathbb I$, l'operatore: $T^A_P(I)=\lambda p(\overrightarrow{X}).\{$ Le sostituzioni $\theta$ tali che: Prendiamo una $p(\overrightarrow{T}):-p_1(t_1),...,p_n(t_n)$ dove $\overrightarrow{T}$ è una rinomina delle variabili con nessun nome in comune con $\overrightarrow{X}$; e prendiamo tutte le sostituzioni $\theta_i in I(p_i(\overrightarrow{X_i}))$; a questo punto prendiamo il mgu $\theta$ (most general unifier) di tutte queste $\}$.

Quindi dato un programma:

```
ap([],X,X).
ap( [X|XS], Y, [X|ZS] ) :- ap(XS, Y, ZS).
```

Partiamo con $T^A_P\uparrow0=\empty$ e costruisce prima le sostituzioni di $ap(X,Y,Z)$ in cui $X$ è la lista vuota. Poi quelle in cui è una lista singoletta, poi quando è di 2 elementi, etc.

$T^A_P$ è monotono.

Una differenza tra questo è la concatenazione ad esempio di haskell, o anche quella di ASP, è che funziona per qualsiasi variabile.
Il minimo punto fisso è l'insieme con le sostituzioni di qualsiasi lista possibile.

Perché questa semantica è sufficiente per qualunque goal? Perché per qualunque goal iniziale $G$, se esiste una mgu per $G$ costruito in questo modo, applicando questa sostituzione possiamo svuotare il goal. Quindi $G\rightarrow^\theta_P\Box$, che è il behaviour descritto prima.

Se due programmi hanno le stesse risposte calcolate hanno lo stesso grounding delle risposte, ma non necessariamente viceversa. La semantica delle conseguenze immediate che abbiamo visto ad AR calcola il grounding delle risposte calcolate.