# Tipi come interpretazione astratta

Kousou resenta al POPL un modo per vedere tutti i sistemi di tipo dei linguaggi funzionali come un caso particolare di interpretazione astratta.

Die grammatiche:
$$
e ::= x~|~\lambda x.e_1~|~e_1~e_2~|~\mu f.\lambda x.e_1~|~e_1-e_2~|~e_1?e_2:e_3\\
e::=x~|~c~|~\lambda x.e_1~|~e_1~e_2~|~\mu f.\lambda x.e~|~e_1?e_2:e_3
$$

Il secondo linguaggio è equivalente, col primo è più facile avere la turing completezza. L'if-then-else deve essere comunque parte del linguaggio e non una funzione. Perché poi chiederemo che tutte le funzioni siano strict.

Tipi:
$$
\mathbb{W}=\{\omega\}\\
\Z\\
\mathbb{B}\\
\mathbb{U}=\mathbb{W}_\bot+\Z_\bot+\mathbb{B}_\bot+[\mathbb{U}\mapsto\mathbb{U}]_\bot
$$

Quell'insieme di funzioni contiene solo le funzioni continue, bottom-strict, omega-strict.

L'environment è la funzione: $\mathbb{E}=Id\mapsto\mathbb{U}$

Il dominio della semantica è la funzione: $\mathbb{Env}\mapsto\mathbb{U},\sqsubseteq$:
* $\mathbb{D}[x]_\rho=\rho(x)$
* $\mathbb{D}[\lambda x.e]_\rho=\lambda v.\begin{cases}\bot & v=\bot\\\omega&v=\omega\\ D[e]_{\rho[x/x]}&otherwise\end{cases}$
* $\mathbb{D}[e_1~e_2]_\rho\begin{cases}\bot&f=\bot\lor x=\bot\\ f~e&\text{se i tipi coincidono}\\\omega&otherwise\end{cases}$
  * Dove $f=\mathbb{D}[e_1]_\rho$ e $x=\mathbb{D}[e_2]_\rho$
* $\mathbb{D}[\mu f.\lambda x.e]_\rho=lfp_\sqsubseteq(\lambda\varphi.\mathbb{D}[\lambda x.e]_{\rho[\varphi/f]})$
* $\mathbb{D}[c]_\rho=C[c]$
  * Dove $C[c]$ è la semantica di una costante e viene definita per ogni costante. Nota che non ha un environment.
  * Alcune costanti sono, le costanti numeriche, operazioni di base
* $\mathbb{D}[e_1?e_2:e_3]_\rho=\mathbb{D}[e_1]_\rho~?~\mathbb{D}[e_2]_\rho~:~\mathbb{D}[e_3]_\rho$

La semantica concreta è $\mathbb{C}=(\wp(\mathbb{D}),\subseteq)$.

## Church/Curry monotype semantics

Sia $\mathbb{M}$ il linguaggio generato da $L(n)$
$$
n::= int~|~bool~|~n_1\rightarrow n_2\\
\mathbb{H}::=Id\rightarrow\mathbb{M}\\
\mathbb{H\times M}~typing\\
\Pi_c::=\wp(\mathbb{H\times M})~program~typing
$$

Definiamo $\gamma_c:\Pi_c\mapsto\mathbb{C}$ per sezioni $\gamma_i$ che poi uniamo insieme:
* Tipi
  * $\gamma_1(bool)=\mathbb{B}_\bot$
  * $\gamma_1(int)=\mathbb{Z}_\bot$
  * $\gamma_1(n_1\rightarrow n_2)=\{\bot\}\cup\{\varphi|\varphi\in\mathbb{U}\mapsto\mathbb{U},\forall v\in\gamma_1(n_1).\varphi(v)\in\gamma_1(n_2)\}$
* Typing
  * $\gamma_2(H)=\{\rho\in\mathbb{Env}|\forall x\in Id.\rho(x)\in\gamma_1(H(x))\}$
  * $\gamma_3(\langle H,n\rangle)=\{\}$
* $\gamma_c(\emptyset)=\{\mathbb{D}\}$
* $\gamma_c(T)=\bigcap_{t\in T}\gamma_3(t)$

Viene fuori una connessione di Galois ma rovesciata, nel senso che è più grande se è contenuto.

$$
T_c[x]=\{\langle H,H(x)\rangle| H\in\mathbb{H}\}\\
T_c[\lambda x.e]=\{\langle H,n_1\rightarrow n_2\rangle|\langle H[n_1/x],n_2\rangle\in T_c[e]\}\\
T_c[e_1~e_2]=\{\langle H,n_2\rangle|\langle H,n_1\rightarrow n_2\rangle\in T_c[e_1],\langle H,n_2\rangle\in T_c[e_2]\}\\
T_c[\mu f.\lambda x.e]=\{\langle H,n\rangle|\langle H[n/f],n\rangle\in T_c[\lambda x.e]\}\\
T_c[k]=\{\langle H,int\rangle|\forall H\}\\
T_c[e_1+e_2]=\{\langle H,int\rangle|\langle H,int\rangle\in T_c[e_1]\cap T_c[e_2]\}\\
T_c[e_1?e_2:e_3]=\{\langle H,n\rangle|\langle H,bool\rangle T_c[e_1],\langle H,n\rangle\in T_c[e_2]\cap T_c[e_3]\}
$$