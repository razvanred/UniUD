# Sicurezza

La sicurezza è una di quelle applicazioni che scono dall'architettura a livelli, richiede che livelli diversi collaborino.

Ormai tutte le risorse sono distribuite sulla rete. Nella preistoria le risorse erano fisicamente limitate, bisognava avere accesso fisico alla macchina per accedervi.
Anche negli ambienti in cui meno sembrava richiesta la rete, ora sono connesse. Ma per questo hanno meccanismi di sicurezza poco sviluppati, perché non servivano.

Strategia generale per la messa in sicurezza:
* Identificare gli asset da proteggere
  * Tempo CPU
  * Larghezza di banda
  * Contenuto di un DB
  * Controllo di macchinari
  * ...
* Decidere dei goal di sicurezza
  * Proprietà che vogliamo che le risorse soddisfino
  * Che non vogliamo che siano modificare da chi non è autorizzato
  * ...
* Stabilire politiche di sicurezza
  * Come reggiungere il goal
  * Insiemedi regole che garantiscono l'obbiettivo
    * Esempio:
      * Goal: non fare incidenti
      * Policies: codice della strada
* Identificare le minaccie
  * Causate da un malfunzionamento
  * Intenzionali
* Sviluppare servizi di sicurezza che implementino controlli/contromisure e piani di recupero
  * Insiemi di servizi che sevono a contrastare le minaccie
  * Servizi per recuperare nel caso la minaccia diventi un attacco

"La sicurezza ha un costo, ma l'insicurezza costa di più":
* La sicurezza si ottiene implementando servizi con costi:
  * Economici
  * Computazionali
  * Risorse umane per la manutenzione ed installazione
    * Ci si può affidare a terzi e trasformarle in costi economici
  * Design ed implementazione più complessi
    * Il software deve essere sviluppato a priori con la sicurezza in mente
    * A volte bisogna rifare il sistema da capo perché l'azienda ha una rete degli anni '70
  * Fastidio degli utenti
    * Chi usa i sistemi si lamenterà sempre
    * La sicurezza è vista come un ostacolo
* Mancanza di sicurezza può costare di più
  * Perdita di assets vitali
  * Conseguenze legali

La sicurezza è un compromesso tra tre aspetti:
* Sicurezza
* Funzionalità
* Facilità d'uso

Non possiamo massimizzare tutte e tre. Alcuni sistemi industriali o militari massimizzano sicurezza, ma hanno pochissimi servisi e nessuna facilità d'uso.

## Security goal

Obbiettivi di sicurezza:
* Confidenzialità:
  * Più facile da realizzare
  * Un'organizzazione deve riguardarsi contro azioni malevole che possono mettere a rischio la confidenzialità delle informazioni
* Integrità:
  * Le funzionalità di alterazione dello stato (che devono essere implementate) devono essere eseguite solo da entità autorizzate
  * Un'organizzazione deve proteggersi contro alterazioni non autorizzate
* Disponibilità
  * Le informazini memorizzate devono essere disponibili alle entità autorizzate quando sono richieste
  * un'organizzazione in cui le informazioni cambiano sempre devono rendere le informazioni sempre disponibili al personale autorizzato

Non tutte le organizzazioni sono interessate a tutto. Ad esempio, le pubblicazioni di atti ufficiali sono integre e disponibili, ma non confidenziali.
Non tutti possono modificare e pubblicare, ma le informazioni sono disponibili a tutti.

## Minacce, attacchi, servizi, meccanismi

* Minacce di sicurezza
  * La potenziale possibilità che avvenga una violazione di un goal di sicurezza
  * Magari non si verifica mai, ma è possibile
* Attacco
  * Un assalto deliberato che compromette i goal di sicurezza
  * Se esiste la posssibilità e l'interesse, prima o poi un attacco si verifica
* Servizi di sicurezza
  * Servizi che hanno lo scopo di incrementare la sicurezza per contrastare gli attacchi
  * Aggiungono funzionalità, ma non funzionalità utili
* Meccanismi
  * Come vengono implementati i servizi di sicurezza

Esempio:
* Nel computer del professore ci sono i testi degli esami (assets)
* Alcune persone sono interessate ad accedervi (minaccia)
* Il professore a volte abbandona il computer (vulnerabilità)
* Mentre è via, una persona non autorizzata può sedersi ed usare il computer (attacco)
* Contromisura: bisogna implementare un servizio di autenticazione che garantisca l'identità degli utenti del computer
* Alcuni meccanismi per implementare il servizio:
  * Nome e password
  * Impronta
  * Carta
  * Timbro vocale
  * Scansione della retina
  * Guardia di sicurezza

## Attacchi alla confidenzialità

* Snooping: Accesso non autorizzato ai dati
  * Accesso non autorizzato al computer (hacker, virus, password stupide, ...)
  * Intercettamento dei dati (sniffing)
    * Usa la cifratura, idiota!
* Analisi del traffico: Ottenimento di metadati monitorando il traffico online
  * Dai metadati si capiscono un sacco di informazioni, si può riconoscere l'utente anche senza ossercare il payload dei messaggi

## Attacchi all'integrità

* Modificha dei messaggi
  * Anche semplici ritardi o cancellazioni dei messaggi, possono farlo i router della sottorete
  * Spesso segue un attacco di snooping
* Masquerading o spoofing
  * L'attaccante finge di essere il mittente od il destinatario di un messaggio (man in the middle)
  * Si ottiene alterando i metadati
* Replay
  * Copia un messaggio di un utente e cerca di ripeterlo più tardi
  * Ascolta la password cifrata, non sa cosa c'è scritto, ma può reinviarla per eseguire di nuovo l'accesso
* Ripudio
  * Avviene da parte delle due parti della comunicazione, non da un terzo, significa che non c'è completa fiducia tra i due
  * Uno dei due riceve od invia un messaggio di cui si pente e dichiara di non averlo mai ricevuto od inviato
  * Per impedire di ripudiare l'invio è sufficiente una firma digitale, per la ricezione è più complicato, si usa la notifica di ricezione

## Attacchi alla disponibilità

Attacchi Denial of Service (DoS):
* È il meno importante
* Non modifica o scopre dati, semplicemente impedisce a chi di dovere di accedere ai dati
* È fastidioso, è molto facile, e si usa per boicottare gli altri
* Si implementa con grandi numeri di richieste
* Può essere implementato come molti attacchi coordinati da più attaccanti (Distributed DoS, DDoS)
* Contromisure:
  * Fare in modo che il carico dell'attaccante sia non inferiore al carico del bersaglio
    * Perché il server impegni x, l'attaccante deve impegnare almeno x
    * Il TCP è vulnerabile a SYN Flooding (non ho cpaito come si collega)
  * Dirottare le richieste malevole, se possibile

## Attacchi passivi/attivi

Gli attacchi passivi sono quelli che possono essere eseguiti senza influenzare il funzionamento del sistema. Possono essere eseguiti senza che nessuno se ne accorga.
Viceversa, quelli attivi alterano il funzionamento del sistema.

Gli attachi alla confidenzialità sono passivi, gli altri attivi.

L'approccio agli attacchi è completamente diverso:
* Attacchi passivi non lterano il sistema o cambiano dati
  * Sono difficili (o impossibili) da rilevare
  * Si enfatizza la prevenzione, non il rilevamento
* Attacchi attivi modificano i dati od alterano il sistema
  * Difficili da prevenire
  * Possono essere rilevati (e si può cercare di contrastarli quando si verificano)

## Meccanismi di sicurezza

I servizi di sicurezza servono a garantire il rispetto delle politiche di sicurezza.
I servizi sono implementati dai meccanismi di sicurezza. Sono gli elementi base per realizzare le varie funzionalità richieste dalle politiche.

Non esiste un unici meccanismo che supporta tutti i servizi, bisogna mettere insieme diversi meccanismi, combinandoli in un insieme di servizi richiesti dalle politiche.
Esempio: Per implementare la confidenzialità serve la crittografia, ma non basta. Dopo avere la crittografato i dati come scambio la chiave?

Bisogna saper combinare i meccanismi opportuni per implementare i servizi che vogliamo. Spesso riflettono dei meccanismi che esistono nel mondo dei documenti fisici:
* Firme
* Protezioni dall'apertura (ceralacca)
* Testimoni
* Licenze
* ...

Alcuni meccanismi specifici:
* Cifratura
  * Matematica che purtroppo non ci interessa (a me sì)
  * Per noi sono delle funzioni di libreria da chiamare e basta
* Integrità dei dati
  * Meccanismi per rilevare che un dato è cambiato
  * Si fa con checksum ed hash
* Firma digitale
  * Garantiscono l'origine dei dati
  * mettono insieme i primi due
* Scambio di autenticazione
  * Le parti si scambiano informazioni per provare la loro identità
  * Sono complicati e complessi ancora oggi
  * Anche se la cifratura è perfetta, possono esserci errori nel protocollo di autenticazione
* Traffic Padding
  * Riempire il traffico di schifezze per evitare l'analisi del traffico
  * Si usa anche nel mondo reale, per gli spostamenti delle autorità importanti
* Controllo di routing
  * Cambiare percorsi per evitare le intercettazioni
  * Per far arrivare il presidente in un posto si fanno partire 10 macchine che seguono strade diverse, all'ultimo si sceglie su quale far salire il presidente
    * Oppure per portare Harry Potter alla tana
* Notarizzation
  * Una terza parte fidata controlla la comunicazione e si occupa dei servizi, in particolare previene il ripudio
* Controllo di accesso
  * Un meccanismo per provare che un agente ha il diritto di accedere ad una certa risorsa

Non tutti i meccanismi sono utili per tutti i servizi:
| \ | Encipherment | Digital signature | Access control | Data integrity | Authentication exchange | Padding | Routing control | Notorization |
| --- | --- | --- | --- | --- | --- | --- | --- | --- |
| Peer entity authentication | X | X |  |  | X |  |  |  |
| Data origin authentication | X | X |  |  |  |  |  |  |
| Access control |  |  | X |  |  |  |  |  |
| Confidentiality | X |  |  |  |  |  | X |  |
| Traffic flow confidentiality | X |  |  |  |  | X | X |  |
| Data integrity | X | X |  | X |  |  |  |  |
| Non-repudiation |  | X |  | X |  |  |  | X |
| Availability |  |  |  | X | X |  |  |  |

### Modello del canale insicuro (Dolev-Yao)

Abbiamo due parti, Sender e Recipient.
Devono scambiarsi un messaggio.
Il messaggio viene inviato dal sender attraverso un canale insicuro al recipient.
Esiste un Opponent che ha pieno controllo sul canale insicuro.

L'opponent può leggere il messaggio sicuro, ritardarlo, eliminarlo, analizzarlo, ripeterlo, eccetera.

Questo è il modello dell'internet, è quello che succede normalmente se non implementiamo servizi di sicurezza.

Soluzioni:
* Il messaggio viene incapsulato in un messaggio sicuro usando un informazione segreta
  * Il recipient riceve il messaggio sicuro e lo decapsula con l'informazione segreta
  * Il messaggio sicuro può essere cifrato per non essere letto
  * Il messaggio sicuro può contenere informazioni di integrità per verificare che non sia stato modificato
  * ...
* Un arbitro fidato di terza parte controlla la comunicazione
  * Spesso non è disponibile questa opzione
  * Nel mondo reale è la posta certificata

Usare questo modello di comunicazione richiede:
* Sviluppare un algoritmo per trasformare il messaggio
  * RSA
  * AES
  * ChaCha20
  * ...
* Generare le informazioni segrete (chiavi)
  * Numero casuale
  * RSA
  * Diffie-Hellman
  * ...
* Sviluppare un metodo per condividere le informazioni segrete
  * Post-it
  * Protocolli quantistici
  * TLS
  * SSL
  * Curve25519
  * ...
* Specificare un protocollo per permettere ai programmi di utilizzare i protocolli scelti per realizzare un servizio di sicurezza
  * SSL
  * TLS
  * Wireguard
  * ...

### Dove si implementano?

Ogni strato di OSI o TCP/IP realizza un canale virtuale.

I servizi di sicurezza possono essere implementati su quasi tutti questi canali con risultati diversi.
Il meglio sarebbe implementarlo su tutti, altrimenti vengono lasciate fuori alcune informazioni che non vengono protette.

Se anche il payload del livello 4 è protetto, l'IP è scoperto e anche la porta, quindi è visibile con chi stiamo parlando e che servizio stiamo utilizzando.

Più è implementato a basso livello, più diventa complesso per gli switch e più sono le informazioni protette (più trasparente per i programmatore).
Più è implementato in alto, più è intrusivo per il programmatore e meno informazione è protetta, però è protetta meglio.


Livelli:
* Livello 1
  * "Se nessuno può collegarsi alla rete, il dato è sicuro"
    * HAHAHAHAHAHAHA
  * In generale ci si può collegare sempre in qualche modo
  * Funziona per applicazioni militari specifiche
    * I cavi coassiali subaquei erano chiusi in un tubo pressurizzato, se lo si clampa (bisogna andare con un sottomarino) per arrivare al cavo, si buca il tubo e cambia la pressione, se cambia la pressione si ferma la comunicazione
    * Ovviamente non si può fare per l'ADSL, costa
    * Se si riesce ad arrivare al cavo, la comunicazione è in chiaro
    * È cifrato anche il footer
* Livello 2
  * Si cifra il frame prima di mandarlo
  * Non si può cifrare l'intestazione di livello 2, altrimenti lo switch non sa a chi mandare il messaggio
  * Un attaccante capisce che interfacce stanno comunicando
    * I MAC sono (circa) unici, sappiamo che macchina ha parlato
  * Nel wifi è implementato da WEP e WPA
  * Il programmatore non se ne accorge
  * Al livello 3 deve arrivare decifrato, quindi hanno tutte le informazioni
  * I router possono sniffare i pacchetti se non ci sono altri strati di sicurezza
* Livello 3
  * Si cifra il payload del pacchetto
  * Non si cifra l'intestazione
  * Un attaccante sa quali host comunicano
  * È implementato da IPSec
  * Viene usato dalle VPN
  * È ancora trasparente al programmatore
  * È ancora implementato dal sistema operativo
* Livello 4
  * Si cifra il payload del livello di trasporto
  * Sono protetti i dati delle applicazioni
  * Un attaccante sa tutte le intestazioni, quindi anche il servizio richiesto
  * Sono implementati da SSL e TLS (meglio questo)
  * Non garantisce confidenzialità dei meta dati
  * Non è trasparente ai programmatori, deve utilizzare altre socket
  * Sono quasi identiche alle socket normali, ma quasi
  * Per aggiungere sicurezza di livello 4 ad un applicazione serve il codice sorgente, gli altri si fanno dal sistema operativo
  * Si usa per rendere sicuri protocolli esistenti. Si realizza lo stesso protocollo, ma sostituendo le socket
    * HTTP->HTTPS
    * POP->POPS
    * FTP->FTPS
    * ...->...S
* Livelli superiori
  * Le applicazioni fanno sicurezza interna
  * Ad esempio il PGP della mail
  * L'header dell'applicazione è scoperta
  * Si sa che comunicazione è avvenuta, solo il contenuto è sconosciuto
  * Esistono molti protocolli ad hoc implementati a questo livello
  * Non sono trasparenti in nessun modo, deve essere il programmatore a realizzare il protocollo stesso
  * Non serve intervento da parte del sistema o delle
  * Si usa per i servizi di sicurezza end-to-end

## Cifratura

Non esiste un solo modo di cifrare, ci sono molte forme di meccanismi di cifratura. Se vogliamo anche le funzioni hash sono funzioni di cifratura.
Vedremo solamente delgi accenni, perché sono troppo complicate ed avrebbero bisogno di un loro corso.

A meno che non diventiamo dei crittografi non ci troveremo mai a scrivere una funzione di cifratura, ed è meglio così.

Due tipi principali di cifratura:
* Simmetrica
  * Chiamata anche "cifratura a chiave privata"
  * Quella tradizionale e più usata
* Asimmetrica
  * Chiamata anche "cifratura a chiave pubblica"
  * Sembrava che dovesse sostituire l'altra, ma viene usata solo come supporto

Terminologia:
* Plaintext: messaggio originale
* Ciphertext: messaggio cifrato (non criptato)
* Cipher: cifrario, algoritmo per cifrare il messaggio
* Key: informazione usata dal cifrario nota solo a mittente/destinatario
* Encipher: cifratura
* Decipher: decifratura
* Cryptography: studio dei metodi di cifratura
* Cryptanalysis: studio dei metodi di decifratura senza conoscere la chiave
* Cryptologia: il campo di criptografia e criptoanalisi
  * "Matematica 2: la vendetta"

### Cifratura simmetrica

Sender e recipient condividono una chiave segreta. Questa tecnica è vecchia quasi quanto la scrittura, e fino agli anni '70 era anche l'unica.

Un cifrario cifra il plaintext con una chiave, il messaggio cifrato è inviato sul canale insicuro, e il recipiente lo riceve e decifra con la stessa chiave.
Bisogna implementare un modo pe condividere la chiave privata in modo sicuro.

Una domanda potrebbe essere: se abbiamo un modo sicuro per scambiare la chiave, perché non lo usiamo per scambiare i messaggi?
Perché potrebbe essere troppo lento, o perché potrebbe non esistere al momento dello scambio di messaggi (chiave scambiata personalmente molti anni fa).

Requitisi:
* Se uno non conosce la chiave, dovrebbe essere impossibile leggere il messaggio orisinale dal messaggio cifrato.
* La chiave segreta è nota solo a mittente e recipiente

Matematicamente:
* $Y=E_K(X)$
* $X=D_K(Y)$
* $D_K(E_K(X))=X$
* $D_K(E_H(X))=\bot$ supponento che $H\neq K$

Principi:
* Kerchoff's principle: (1883) la sicurezza del messaggio deve dipendere solamente dalla segretezza della chiave, non dalla segretezza dell'algoritmo.
* Shannon's maxim: il nemico conosce il sistema.

Dato che in un modo o nell'altro il nemico scopre il cifrario, i sistemi che non fanno affidamento sulla segretezza del cifrario sono migliori.
I cifrati opensource sono migliori, perché fanno affidamento solo sulla chiave.
Ricordiamo che cambiare la chiave se viene scoperta, è facile, cambiare l'algoritmo è difficile.

#### Principio di Kerchoff

Anche se discutibile, uno può tenere segreto il cifrario, ma questo non può essere un requisito della sicurezza.

Se qualcuno dice che il suo cifrario è migliore per questo, o è un ciarlatano, od ha qualcosa da nascondere.
Qualsasi software design che non assume la massima di Shannon è da considerarsi non fidato.

Non fidatevi di algoritmi e protocolli closed source, sarebbe meglio anche compilarsi da soli i binari.
Whatsapp ora usa un protocollo opensource (quello di Signal), ma prima usava un protocollo proprietario. Però non possiamo essere sicuri che lo usi davvero, perché non abbiamo il codice. Infatti i servizi segreti non usano WA per i messaggi, se gli serve per forza un software commerciale usano Signal.

### Criptoanalisi

Il processo di scoprire il messaggio originale da un messaggio cifrato (o la chiave per decifrarli), senza che gli sia condivisa la chiave.
Esistono tanti tipi di attacchi, e la differenza sono le informazioni ed il controllo a disposizione degli attaccanti.

Attacchi:
* Ciphertext only
  * L'analista conosce solo algoritmo e messaggio cifrato
  * Vuole il messaggio e/o la chiave
  * È il più difficile, e si fa quando si hanno poche informazioni
  * Se il nostro cifrario si reisce ad attaccare con successo in questo modo, abbiamo sbagliato cifrario
* Known plaintext
  * L'analista conosce algoritmo, testo cifrato e testo originale
  * Vuole la chiave, per cifrare il resto del traffico
  * È facile che si conosca parte del traffico
    * "GET /index.html HTTP/1..."
    * "200 Ok ..."
    * "\<HTML>\<head>\<title>..."
  * Buoni cifrari devono essere studiati per resistere a questo tipo do attacco
* Chosen plaintext
  * Come il precedente, ma l'attaccante fa in modo che venga cifrato il testo che vuole
* Chosen ciphertext
  * Al contrario, si fa in modo che il recipiente decifri il messaggio che vogliamo per capire la chiave
* Chosen text
  * L'attaccante può scegliere che messaggi far cifrare o decifrare alle parti

#### Come si attacca un cifrario

In generale ci sono due strategie:
* Forza bruta: le chiavi non sono infinite, quindi le proviamo tutte
  * Purtroppo le chiavi dei cifrari moderni sono non meno di 340 miliardi di miliardi di miliardi di miliardi, quindi si cerca un modo per diminuire il numero di chiavi da provare
    * Ci vuole un miliardo di volte l'età dell'universo
    * Serve la stessa energia necessaria a bollire tutti gli oceani
    * ...
  * Ovviamente serve un modo per sapere se abbiamo avuto successo
  * Cifrari sono chiavi più piccole (come i 56 bit del DES) non sono più usati, o sono modificati per accettare chiavi più lunghe (triplo DES)
  * I cifrari a permutazione alfabetica hanno 26! combinazioni, sono abbastanza resistenti a questo attacco
* Strategie criproanalitiche
  * Si cercano debolezze matematiche del cifrario
  * Di solito non si trovano debolezze che invalidano completamente il cifrario, ma riescono a diminuire lo spazio delle chiavi
  * Una tecnica è limitare lo spazio delle chiavi sapendo che non è casuale.

### Cifrari di flusso

Processano un messaggio un byte alla volta, sono molto facili e comodi da implementare.
Viene cenerata una serie di numeri pseudorandom con la chiave come seed, questa stringa viene messa in XOR con l'intero messaggio. Per decifrare si segue esattamente lo stesso procedimento.
La casualita della stringa impedisce analisi statistiche del messaggio, distruggendo proprietà statistiche.

Se fosse veramente casuale, sarebbe la cifratura One Time Pad, unico cifrario veramente sicuro. Dato che non si può avere una stringa veramente casuale, e la chiave sarebbe l'intera stringa (quindi enorme) questo cifrario non è praticabile.

Se sue messaggi vengono cifrati con lo stesso stream di, possiamo mettere i due messaggi in xor per rimuovere la chiave ed ottenere lo xor dei messaggi originali. A questo punto è facile analizzare i messaggi, se uno è noto, è triviale.
Non bisogna mai incrociare i flussi.

Può essere sicuro come un cifrario di blocco, se utilizzato bene, richiede di prendere precauzioni (mai testo noto, mai incrociare i flussi, etc)

Uno molto comune è RC4, usato in WEP e WPA, e anche su TLS. Purtroppo, visto che veniva usato male, WEP risultava non sicuro.

### Cifrari di blocco

Sono una famiglia di cifrari più flessibili rispetto a quelli di flusso, possono essere usati più alla leggera, senza rischiare di compromettere la sicurezza.

Non cifrano un byte per volta, ma cifrano un blocco intero.

Non sono vulnerabili al trucco dello xor con la stessa chiave, perché non aggiungono rumore, semplicemente sostituiscono un blocco con un altro. Sono una specie di cifrario a permutazione parametrico, con un grande alfabeto (molto grande).

Implementarlo come una tabella (come un cifrario a permutazione) sarebbe impensabile a causa delle dimensioni. Quindi si sfruttano delle tecniche per produrre algoritmi per questo tipo di cifrari.
Le due principali sono le reti di Feistele e gli algoritmi SP (sostituzione e permutazione)

#### AES Advanced Encryption Standard

È risultato da un concorso per stabilire il successore del DES. Quello scelto è il Rijandel. Non era più sicuro di tutti, ma era un compromesso tra sicurezza e facilità di implementazione in hardware e software.

E un algoritmo SP, e per ora gli unici attacchi efficaci sono stati side-channel attacks.

Un round di AES:
* Prende 128 bit
* Sostituisce ogni byte con una tabella
* Scambia i byte con delle permutazioni fisse
* Mette in xor con l'espansione della chiave
* Ripete più volte (a seconda della lunghezza della chiave)

---

Come facciamo ad utilizzarlo per flussi di dati di lunghezza arbitraria? Nei cifrari di flusso era facile, ma per i cifrari a blocchi caso abbiamo i modi di operazione.
I modi di operazione sono indipendenti dal cifrari, e sono molto importanti, se usiamo il modo sbagliato compormettiamo la sicurezza, anche se usiamo il cifrario più avanzato del mondo.

Modi:
* ECB Electronic CodeBook
  * Separo il messaggio in blocchi e li cifriamo uno alla volta
  * È il peggiore, perché se ho blocchi uguali vengono cifrati allo stesso modo
  * Sembra una sciocchezza, ma alcuni tipi di dati, come immagini bitmap, risultano facilmente visibili se criptati in questo modo
    * Dati più complessi sono vulneraibli ad altri tipi di analisi statistiche
    * Anche dati come file HTML sono molto vulnerabili
  * Si usa solo se dobbiamo cifrare meno di un blocco
* CBC Cipher Block Chaining
  * Separo il messaggio in blocchi, prima di cifrare ogni blocco lo mettiamo in XOR con il blocco **cifrato** precedente (il primo è in XOR von un vettore di inizializzazione)
    * $C_i=E_k(B_i \oplus C_{i-1})$
    * $C_0=IV$
  * Per decifrare, ovviamente si fa il passaggio opposto
  * Anche se ci sono blocchi uguali si ottengono blocchi cifrati diversi, perché sono messi in XOR con bit diversi
  * Se modifico uno dei blocchi in chiaro, causo una catena di modifiche a tutti i blocchi successivi
  * Serve un vettore di inizializzazione
    * Non serve che sia segreto (non è la chiave)
    * Su alcuni sistemi è fisso, altri lo generano random e lo tengono segreto anche se non necessario
  * Se si altera un bit del testo cifrato, si perde anche il blocco successivo (ma solo quello)
    * A contrario dei cifrari di flusso, se si cambia un bit cambia l'intero blocco, non solo un bit
    * Il blocco successivo ha solo un bit sbagliato
    * Quello successivo ancora è a posto
  * Ottimo per cifrare file o messaggi che non saranno mai modificati
* OFB Output FeedBack
  * Serve per usare il cifrario a blocchi come fosse un cifrario a flusso
  * Cifra un vettore di inizializzazione multiple volte e lo mette in xor con il messaggio in chiaro
    * $C_i=B_i\oplus IV_i$
    * $IV_i=E_k(IV_{i-1})$
    * $IV_0=IV$
  * Se altero un bit del testo in chiaro, si altera un bit del testo cifrato
  * Non serve la funzione $D_k$
  * Soffre degli stessi problemi dei cifrari di flusso, ma ha un algoritmo di generazione del keystream più sofisticato
  * Funziona bene per cifrare i file, ma serve generare il keystream
* CTR Counter
  * Una via di mezzo ta OFB ed ECB
  * Si cifra un contatore (inizia da un valore fisso, casuale, timestamp, qualsiasi), e si mette in xor con il blocco originale
    * $C_i=B_i\oplus O_i$
    * $O_i=E_k(IV+i)$
  * Se altero un bit del testo in chiaro, si altera un bit del testo cifrato
  * Non serve la funzione $D_k$
  * Se ho un flusso troppo lungo (per AES $2^{128}$) ri ripetono le chiavi
  * Ottimo per cifrare file su disco, che saranno modificati
* Altri
  * Esistono un sacco di altri modi di operazione, ma questi sono i più utilizzati

## Integrità ed autenticazione

Per integrità si intende, verificare l'autenticità dei dati. Per autenticazione si intende verificare l'identità dell'interlocutore.

* Se si usa cifratura simmetica
  * Metodo naive
    * Si cifra il messaggio con una chiave
    * Se il recipiente decifra e trova il messaggio originale, è sicuto che il messaggio era corretto e che è stato cifrato da qualcuno che conosce la chiave
    * Non si evita la ripudiazione, perché il mittente potrebbe dire che lo abbia fabbricato il recipiente
      * Se si tratta di un contratto, questa ripudiazione può essere problematica
      * Ovviamente non evita nemmeno la fabbricazione, ma è più probabile il contrario
      * Questo si potrà fare solo con la asimmetria
    * Non risolve il problema dell'integrità (da per scontato che abbiamo un modo per sapere che è il messaggio originale)
  * MAC Message Authentication Code
    * Serve un modo per sapere se il messaggio è quello originale, magari senza costringere a cifrare l'intero messaggio
      * Se non è necessario fa perdere tempo
      * Esempio: Non è necessario che le notizie sul covid siano segrete, è necessario che si sappia da chi arrivano
    * Costruiamo una piccola informazione extra aggiunta al resto del messaggio, che può anche essere in chiaro per verificare l'integrità
    * Questa informazione si genera da un checksum, cifrato con una chiave
      * Il destinatario può decifrare il segreto e verificare il checksum
      * Se qualcuno altera il messaggio deve alterare anche il checksum, ma per farlo serve la chiave
      * Si deve usare un cifrario a blocchi, altrimenti sappiamo come alterare il MAC al variare del checksum
      * $MAC=C_k(M)$
    * Anche questa non fa signature, quindi non evita la ripudiazione
    * Il MAC è anche detto checksum crittografico
    * È una funzione molti ad uno, perché esistono molti messaggi con lo stesso MAC, quindi non si può tornare al messaggio originale

### Funzioni Hash

La funzione hash è una funzione molti ad uno che converte un messaggio di lunghezza arbitraria ad una striga di lunghezza fissa
$$h=H(M)$$

Requisiti di un hash (crittografico):
* Applicabile a messaggi di qualunque lunghezza
* Produce un output di lunghezza fissa
* Facile da calcolare per qualunque messaggio
* Resistente in tre modi (solo per quelli crittoggrafici):
  * Resistenza al preimaging
    * Data $h$ deve essere difficile trovare una $X$ tale che $H(X)=h$
    * L'unico modo è il bruteforce
    * Lo fanno i criptominer, cercano hash che abbiano particolari caratteristiche
    * Potrebbe essere usato per recuperare un segreto da un dato di integrità
  * Resistenza al secondo preimaging
    * Dato un messaggio $X_1$ deve essere difficile trovare un secondo messaggio $X_2$ tale che $H(X_1)=H(X_2)$
    * Esiste sicuramente, deve essere difficile
    * Potrebbe essere usato per sostituire il messaggio con uno con lo stesso hash senza che il recipiente/mittente lo scopra
  * Resistenza alle collisioni
    * Deve essere difficile trovare due messaggi $X_1, X_2$ tali che $H(X_1)=H(X_2)$
    * Assomiglia a quello di prima, ma stavolta possiamo scegliere anche il primo messaggio
    * Potrebber essere usato per ripudiare un messaggio dichiarando di avere inviato l'altro (programmando in anticipo il ripudio)

### Secure Hash Algoritm (SHA)

* SHA originale. Progettato da NISR & NSA nel 1993
* Revisionato nel 1995, e rinominato SHA-1
* Standard americano per lo schema di firma DSA
  * FIPS 180-1
  * RFC3174
  * L'algoritmo è SHA, lo standard è SHS
* Produce hash di 160 bit
  * Per trovare clash (la più difficile da impedire delle tre resistenze) servono in media $2^{80}=\sqrt{2^{160}}$
* Nel 2005 si è scoperto che si poteva trovare collisione in $2^{69}$ passaggi, invece che $2^{80}$
  * Sono troppo pochi, quindi si è deciso di migliorare lo standard
  * Tre nuove versioni:
    * SHA-256
    * SHA-238
    * SHA-512
* Le nuove versioni di SHA sono progettate per essere compatibili con AES e sono simili a SHA-1 ma più sicuri

Ora che abbiamo questo strumento, come lo usiamo?

### HMAC

L'hash non usa chiave, non ha segreti, quindi non possiamo usarlo per fare autenticazione. Possiamo solo usarlo per verificare che il messaggio inviato sia proprio quello.

Il modo standard per aggiungere un segreto al hash è l'HMAC (MAC con hash), si usa per costruire un'informazione di integrità da qualsiasi funzione di hash.

$$HMAC=Hash[(K^+\oplus opad)||Hash[(K^+\oplus ipad)||M]]$$

Si prende una chiave in xor con un padding (anche le Hash funzionano a blocchi), la si mette in testa al messaggio, e si calcola l'hash di tutto.
Dopo di che, si mette di nuovo la chiave in xor con un padding (diverso) e si inserisce in testa all'hash intermedio, di questo si calcola di nuovo l'hash, e questo viene condiviso al posto del MAC.
Il pad interno, chiamato ipad, corrisponde a tutti `0x36`, ovvero il carattere ASCII '6'. Il pad esterno, chiamato opad, corrisponde a tutti `0`.
L'overhead sono solo 3 round della funzione di hash, per aggiungere la segretezza di cui abbiamo bisogno

È molto sicuro, per questo si può usare anche solo MD5 se non ci serve estrema sicurezza; che è comunque buono, e più veloce di SHA-1.
A volte si trovano HMAC ad hoc, che però rischiano di essere fatti male.

### Wired Equivalent Privacy WEP

Lo standard 802.11 definisce uno schema di cifratura a chiave simmetrica (WEP) per fornire un livello di confidenzialità pari a quello della rete ethernet. In pratica, quasi nessuna, l'unica sicurezza fornita dall'ethernet è data dal fatto che bisogna essere fisicamente connessi al cavo, cosa che (per quanto minima) si perde quando si parla di reti wireless.

Si è deciso di aggiungere un messanismo di autenticazione dei pacchetti per limitare l'accesso alla rete. Chi conosce la chiave può collegarsi alla cella, gli altri no. Ma una volta che ci si collega alla cella, si possono leggere tutti i pacchetti (stesso effetto che si aveva con la connessione cablata).
Lo hanno fatto male, quindi ora vediamo cosa hanno sbagliato.

Idea:
* Una chiave è condivisa tra host ed AP
  * Può essere (è) la stessa per tutti gli host
  * Non è specificato quando bisogna cambiarla
  * Non è specificato come comunicare la chiave (etichetta sotto il router/post-it)
* Il payload ed il checksum del frame viene cifrato con una variante di RC4, e viene aggiunto un vettore di inizializzazione (ed alcune opzioni)
  * Per ricevere si prende il vettore e la chiave WEP, si genera il keystream, si mette in xor col payload, e troviamo dati e checksum
* Senza chiave WEP non si può leggere, giusto?
* Purtroppo non viene specificato come deve essere generato il IV, si suggerisce solo di cambiarlo spesso
  * Se una scheda di rete usa sempre 0 come IV, sarebbe comunque conforme allo standard
  * Dato che RC4 è un cifrario di flusso, bisognerebbe usare ogni volta un keystream diverso, quindi se non si cambia la password si dovrebbe cambiare il vettore
  * In genere le schede usano un numero autoincrementato come IV, ma ogni volta che si riavvia la scheda si azzera, quindi i numeri bassi sono più probabili
* Se il vettore di inizializzazione è pseudorandom, vale il paradosso del compleanno:
  * La probabilità di trovare collisioni è pari a 1 sulla radice dello spazio di numeri
  * Quindi ascoldando 10000 frame (un secondo) abbiamo la quasi sicurezza di trovare due frame con lo stesso IV
* Quando troviamo due frame con lo stesso IV sappiamo che hanno lo stesso keystream, e possiamo metterli in XOR e fare delle analisi statistiche per scoprire il contenuto
* Se conosco uno dei testi in chiaro e l'IV (che è in chiaro) trovo un keystream e l'IV a cui è associato. Quindi posso mandare messaggi cifrati con quel keystream, e la rete li accetta
  * Se la rete richiede che cambino spesso, o se voglio essere meno sospetto, posso accumularne un po' per usare keystream diversi

Dato che questo algoritmo era implementato in hardware, patcharlo è stato complicato. Ora le nuove versioni di WEP usano AES in modalità CBC, quindi non esiste più questo problema.

## Crittografia asimmetrica/a chiave pubblica

La più grande scoperta in tutti i 3000 anni di storia della crittografia, fino agli anni '70 non si sapeva nemmeno se fosse possibile.
Si pensava che avrebbe rimpiazzato la crittografia a chiave privata, in realtà la complementa.

Problemi che indirizza:
* Distribuzione delle chiavi
  * Finora abbiamo assunto una possibilità di condividere una chiave segreta in un canale sicuro
* Firma digitale
  * Compie quel passo finale che mancava a MAC e HMAC

Vengono usare coppie di chiavi *diverse*, una privata ed una pubblica, che sono univocamente associate tra loro ed hanno utilizzi diversi:
* Privata
  * Nota solo al suo proprietario
* Pubblica
  * Nota a tutti
* Differenza
  * Se un messaggio viene cifrato con una chiave, può essere decifrato solo con l'altra

Si dice asimmetrica perché le parti della comunicazione hanno informazioni diverse, mentre nella crittografia simmetrica avevano entrambi la stessa chiave.

Utilizzo:
* Segretezza
  * Quando Alice vuole mandare un messaggio segreto a Bob, lo cifra con la chiave pubblica di Bob
  * solo Bob può leggere il messaggio perché serve la chiave privata di Bob
* Firma digitale (autenticazione e non ripudio)
  * Quando Alice vuole mandare un messaggio autenticato a Bob, lo cifra con la sua chiave privata
  * Bob può decifrarlo con la chiave pubblica di Alice, quindi deve essere stato cifrato da Alice
  * A contrario di quando usavamo cifratura simmetrica, non può essere contraffatto da Bob, perché non ha la chiave privata

Requisiti:
* Deve essere difficile recuperare una chiave dall'altra
  * Possibilmente NP-completo, od almeno NP
* Deve essere facile creare le due chiavi insieme
  * Di classe P

Per creare queste funzioni onee-way si utilizzano moltiplicazione e fattorizzazione (RSA, DH) perché moltiplicare è facile (è banalmente polinomiale) mentre fattorizzare è difficile, anche se non è dimostrato che sia (NP-completo). Altri cifrari più moderni (ECDH) usano curve ellittiche (che non abbiamo tempo di vedere), che sono un po' più sicuri e comodi.

### RSA

Si utilizza l'aritmetica di modulo e la dunzione totiente di Eulero:
* Considerando l'insieme completo 0...n-1 dell'aritmetica modulo n
* Il set dei residui ridotti è l'insieme dei numeri che sono primi rispetto ad n
  * Esempio: n=10
  * Completo: 0,1,2,3,4,5,6,7,8,9
  * Ridotti: 1,3,7,9
  * I ridotti hanno inversi moltiplicativi (numeri che moltiplicati per il ridotto danno $1\mod\emptyset(n)$)
* La cardinalità dell'insieme ridotto è la funzione totiente $\emptyset(n)$
  * In questo caso $\emptyset(10)=4$
  * Con numeri piccoli è facile da calcolare (come appena visto) con numeri da centinaia di cifre, diventa un problema
  * Per fortuna abbiamo il teorema di Eulero che permette di calcolarlo
  * Dati $n=p*q$ abbiamo $\emptyset(n)=(p-1)(q-1)$

Generazione della chiave (senza dettagli implementativi):
* Si scelgono due numeri primi random $p,q$
* Useremo aritmetica di modulo $n=pq$
* Si sceglie random la chiave di cifratura $e$
  * Con $\gcd(e,\emptyset(n))=1$ (coprimo di $\emptyset(n)$) e $1<e<\emptyset(n)$
  * $\gcd$ è la funzione che calcola il cmd (greatest common divisor)
* Si risolve un equazione per trovare la chiave di decifratura $d$
  * Equazione: $ed=1\mod \emptyset(n)$ con $0\leq d\leq n$ (è l'inverso moltiplicativo di $e$)
* Quando generiamo le chiavi possiamo calcolare $\emptyset(n)$ con una moltiplicazione
  * Per calcolarlo da una delle chiavi serve prima fattorizzare $n$ che è un emiprimo molto grande (difficile da fattorizzare)
* Abbiamo le due chiavi:
  * Pubblica/cifratura: $PU=\{e,n\}$
  * Privata/decifratura: $PR=\{d,n\}$
  * (si possono usare entrambe per cifratura e decifratura)
* In realtà, per implementarla bisogna seguire delle precauzioni per evitare alcuni tipi di attacchi ed analisi, per questo sono stati proposti altri cifrari

Utilizzo:
* Cifratura
  * $C=M^e\mod n$ con $0\leq M<n$
  * Se serve cifrare un messaggio troppo grande lo si separa in blocchi
  * Se il messaggio è troppo piccolo si aggiunge padding, sennò funziona male (il modulo non modulizza)
* Decifratura
  * $M=C^d\mod n$
* In RSA:
  * $n=pq$
  * $\emptyset(n)=(p-1)(q-1)$
  * Scegliamo attentamente $e$ e $d$ per essere inversi moltiplicativi $\mod\emptyset(n)$
  * Quindi:
    * $C^d=M^{ed}=M^{1+k*\emptyset(n)}=M^1(M^{\emptyset(n)})^k=M^1(1)^k=M^1=M\mod n$
    * Questa formula risulta falsa secondo il teorema di eulero quando $M$ non è coprimo di $n$, ma bisognerebbe osservare anche il **Piccolo teorema di Fermat**, pe cui è ancora valida
    * Non abbiamo tempo di vedere il teorema di Fermat, fidatevi e basta

Si possono calcolare efficientemente gli esponenziali con degli algoritmi speciali (square multiply), lineare rispetto alla l'unghezza dell'esponente.

Nota: è lenta (nonostante l'algoritmo dell'esponenziale), molto lenta, ordini di grandezza più lenta della crittografia a chiave simmetrica.

Perché funziona RSA (in breve):
* Teorema di eulero
  * $a^{\emptyset(n)}\mod n=1$ con $\gcd(a,n)=1$

#### Sicurezza di RSA

Si può sempre provare il bruteforce, ma è impraticabile perché la chiave è grande e l'esponenziale è lento.

Si può fattorizzare n, ma fattorizzare numeri molto grandi è difficile. Per questo bisogna usare chiavi di almeno 1024 bit per avere la stessa sicurezza di una chiave a 64 bit (perché i primi sono pochi), si consiglia di fare chiavi da 2048 per avere una sicurezza decente, ma meglio 4096 (si, 4kb di solo chiave).

### Altri sistemi a chiave pubblica (Honorable mentions)

* ElGamal, basato sui logaritmi discreti
  * È facile calcolare un esponenziale, è difficile calcolare un logaritmo (sui numeri interi)
  * È più carino di RSA
* Curve ellittiche, basato sulle soluzioni in campi finiti della forma $y^2=x^3+ax^2+b$
  * Sta lentamente sostitunedo RSA
  * Una chiave a curva ellittica a 256 bit è sicura come una chiave RSA a 3072 bit
  * Quando leggiamo ECDSA si intende firma digitale a curva ellittica
    * Stessa cosa per ECDH (Diffie-Hellman a curva ellittica)

### Firma digitale

Alice deve avere un modo per firmare un documento e Bob deve avere un modo per verificare che sia arrivato da Alice, indipendentemente da quello che dice Alice.
Si vuole che sia un informazione di firma aggiuntiva, inviata insieme al messaggio, senza che questo sia necessariamente cifrato.

Deve essere:
* Dipendente dal messaggio
* Unica per il mittente
  * Per prevenire contraffazione
* Facile da produrre
* Facile da verificare
* Computazionalmente difficile da contraffare
  * Non si deve usare firme vecchia per messaggi falsi
  * Non si devono produrre firme false per messaggi falsi
* Comoda da memorizzare

***N.B.***: se serve possiamo cifrare tutto con un altro sistema (una chiave simmetrica, o quella pubblica del recipiente) che fornisca segretezza.

Sfruttiamo la cifratura a chiave pubblica:
* Naive
  * Viene prodotto un messaggio cifrato con la chiave privata di Alice
  * Funziona solo per messaggi piccoli (perché la cifrature è pesante), quindi di solito non si usa
* Metodo che viene usato veramente
  * Viene concatenato il messaggio con l'hash cifrato con la chiave privata di Alice
  * $M_s=M||C_{k_p}(h(M))$
  * Schema RSA
    * $M||S=M||(h(M)^d\mod n)$
    * Condizione per accettare: $h(M)==S^e\mod n$

### Certificati (distribuzione chiavi pubbliche)

Un certificato è un file che contiene la chiave pubblica e ne attesta la validità. Non esiste per la chiave privata, ovviamente.
Viene firmato da un ente certificatore (CA, certification authority) che deve garantire l'identità della persona, come funziona nella vita reale, in cui lo stato carantisce la nostra identità con la cartda di identità, che contiene nome, foto, e *firma*.
Il certificato viene affidato al possessore, non viene conservato dall'ente, hanno un ruolo one-time.

Procedimento:
* Alice genera una coppia di chiavi
* Invia la chiave pubblica, attraverso un canale sicuro, ad una CA
* La CA restituisce un documento firmato con un timestamp, l'identità di Alice, e la chiave pubblica
  * $C_A=E(PR_{auth},[Time_1||ID_A||PU_g])$
  * $C_A=$ Certificato di Alice
* Alice, ora, è un possesso di un certicicato che può usare quando vuole
* Bob, quando riceve il certificato, scopre la chiave pubblica di Alice, ed è sicuro dell'identità perché si fida dell'ente certificatore

Il timestamp serve perché, come la carta di identità, non dura per sempre.

#### X.509 Authentication Service

Sviluppato nel 1988, una decina di anni dopo RSA, ora siamo alla terza versione.

Certificato:
* Versione (1,2,3)
* Serial number
  * In riferimento al certificatore
* Algoritmo e parametri
  * Del certificatore
* Issuer (CA)
* Periodo di validità
  * Non prima di ...
  * Non dopo di ...
  * In formato UNIX
* Subject Name (proprietario)
* Algoritmo, parametri e chiave pubblica
  * Del proprietario
* Identificativo univoco del certificatore (versione 2)
  * A livello mondiale
* Identificativo univoco del proprietario (versione 2)
  * In riferimento al certificatore
* Estensioni (versione 3)
* Firma (tutte le versioni)
  * Algoritmo e parametri

Notazione: A\<\<B\>\> A possiede un certificato emesso da B

Estensioni:
* Politiche
  * Quando viene generato un certificato, vengono associati dei permessi per utilizzarlo in diverse situazioni, in base al livello di fiducia
  * Livelli:
    * 1 viene verificati nome ed emali, permesso per web browsing ed email
    * 2 viene verificati l'indirizzo, permesso per email firmate, validazione del software (per verificare lo sviluppatore)
    * 3 vengono verificati i documenti di identità, permesso per ebanking, servizi di accesso, CIE, passaporto
* Attributi del certificatore
  * Nomi alternativi
  * Email
  * Formati alternativi
* Vincoli del percorso del certificato
  * Permette di specificare vincoli circa l'uso del certificato da parte di altre CA

Ottenere un certificato:
* Qualsiasi utente che ha accesso ad una CA, può ottenere un certificato
* L'utente
  * Genera una coppia (deve essere l'utente)
  * Manda una richiesta alla CA
  * La CA firma la richiesta e rimanda indietro il certificato
* Solo la CA può generare il certificato
* Non si può falsificare, quindi può essere mantenuta in una cartella pubblica
* Può essere rinnovata prima di scadere

Quando si richiede l'attivazione della tessera sanitaria succede questo, quando l'impiegato inserisce la carta nel lettore, la carta genera le chiavi (ci mette un po') e salva la chiave privata in una memoria non accessibile, l'impiegato conferma la nostra identità (con la carta di identità) ed il sistema certifica la chiave pubblica prodotta dalla carta.
Quando mi serve firmare un documento, invio un hash alla carta (usando il lettore) che lo cifrerà e lo restituirà. I dispositivi coinvolti (carta e lettore) devono essere costruiti in base a delle regole della comunità europea per garantire la sicurezza.

Come si conferma un certificato:
* Bob controlla il timestamp del certificato
  * Se il tempo non corrisponde (magari entro una soglia di tolleranza) lo rifiuta
* Altrimenti controlla la firma
  * Controlla se è stata firmata da un ente fidato
  * Interroga l'ente certificatore (per sapere se la chiave è stata revocata)
    * L'ente mantiene un elenco di tutti i certificati non scaduti ma revocati
    * Bob dovrebbe mantenere una copia di questo elenco (in realtà controlla la revoca del singolo solo quando è sospetto)
    * La lista si sfoltisce quando i certificati scadono
    * Ovviamente questo procedimento è un vecchio retaggio, ora si usa un protocollo request reply più moderno ed efficiente (OCSP)
    * L'utente chiede la revoca del certificato quando perde la chiave privata

Gerarchia di CA:
* Se avessimo un solo ente certificatore avremmo un problema di scalabilità
* Per questo abbiamo più enti
* Ogni ente possiede una chiave privata con cui emette certificati ed un certificato che permette di emetterne altri
  * Deve essere firmato da un secondo ente certificatore
* Quando validiamo il certificato verifichiamo che il suo ente certificatore sia certificato
  * Quando qualcuno invia il suo certififcato, di solito invia i certificati di tutta la catena
* Ad un certo punto arriviamo ad una radice (non ce ne è una sola)
  * Le RCA (root certification authorities) si certificano da sole
  * In genere le root si certificano a vicenda, come le nazioni all'ONU
    * Questo *può* avvenire emettendo un certificato
    * Più spesso avviene permettendo al proprio software (in particolare l'OS) di accettare quelle root
    * Un attacco potente è modificare i certificati del sistema operativo (succede, è successo a dei sistemi Nokia pochi anni fa)
  * Ci sono leggi locali che decretano quali sono le root affidabili
    * C'è una lista dell'AGID, ci si può fidare di quella
    * Alcune applicazioni scaricano liste come quella, perché non si fidano di quelle del sistema operativo

### Certificazione delle entità (non dei messaggi):

I certificati di autenticazione sono una delle cose più difficili da fare (molti algoritmi passati erano bacati).

Differenza tra autenticazione dei messaggi e delle entità:
* L'autenticazione dei messaggi è statica, si invia il messaggio insieme alla firma
  * L'autenticazione delle entità richiede una sessione ed uno scambio di messaggi
  * Il Claimant A chiede di essere autenticato per il Verifier B (in genere significa decidere un segreto condiviso)
  * Esiste un prima e dopo della autenticazione, non dipende da un timestamp

Autenticazione a chiave asimmetrica:
* Protocollo monodirezionale
  * Si usa un sistema di challenge-response
    * "Buongiorno, Luke, sono il Professor Layton"
    * "Aaah, ma se tu sei il Professore... risolvi questo enigma"
  * Passaggi:
    * $A\rightarrow B:A$ Sono Alice
    * $B\rightarrow A:E_{K_A}(B,R_B)$ Io sono Bob, allora dimmi cosa ho cifrato con la chiave pubblica di Alice
    * $A\rightarrow B:R_B$ Hai cifrato questo
  * $R_B$ è un numero random generato al momento chiamato nonce
* Protocollo bidirezionale
  * Passaggi:
    * $A\rightarrow B:E_{K_B}(A,R_A)$ Io sono Alice, dimmi cosa ho cifrato con la chiave di Bob
    * $B\rightarrow A:E_{K_A}(R_A,R_B)$ Hai cifrato questo, dimmi cosa ho cifrato io con la chiave di Alice
    * $A\rightarrow B:R_B$ Hai cifrato questo

Questi protocolli di autenticazione sono implementati nel modello X.509 visto prima, in due forme:
* One-Way
  * Per messaggi unidirezionali
  * Passaggi (lol):
    * $A\{t_A,r_A,ID_B,sgnData,E[PU_b,K_{ab}]\}$
  * Solo Bob può leggerlo (cifrato con la sua chiave pubblica)
  * Solo Alice può generarlo (cifrato con la sua chiave privata)
  * Bisogna controllare il timestamp
* Two-Way
  * Sessioni interattive (basata su timestamp)
  * Passaggi:
    * $A\{t_A,r_A,ID_B,sgnData,E[PU_b,K_{ab}]\}$
    * $B\{t_B,r_B,ID_A,r_A,sgnData,E[PU_a,K_{ba}]\}$
  * Per assicurarmi che il messaggio non sia un messaggio vecchio riciclato da un attaccante bastacontrollare i due timestamp $t_A,t_B$, ma serve che gli orologi siano sincronizzati
* Three-Way
  * Sessioni interattive (basata su nonce)
  * Passaggi:
    * $A\{t_A,r_A,ID_B,sgnData,E[PU_b,K_{ab}]\}$
    * $B\{t_B,r_B,ID_A,r_A,sgnData,E[PU_a,K_{ba}]\}$
    * $A\{r_B\}$
  * Inizia uguale a prima, ma se gli orologi sono sincronizzati utilizzo i random, e serve anche l'ultimo messaggio

### Scambio chiavi Diffie-Hellman

Lo scopo è concordare una chiave segreta senza avere nessun segreto condiviso iniziale. Gli attaccanti riescono a vedere tutti i messaggi dello scambio, ma non riescono a recuperare il segreto.

È stata scoperta da Diffie ed Hellman nel 1976, ma si è scoperto che Wiliamson dei dervizi segreti inglesi la conosceva già.

Si usa per qualsiasi cosa, anche le password di whatsapp, e si basa sugli esponenti discreti.

Procedimento:
* Tutti gli utenti concordano (aka lo standard definisce):
  * Si concorda un grande numero primo o polinomiale $p$
    * Deve essere scelto con accuratezza
  * $g$ è la radice primitiva modulo $p$
    * $\{g^i\mod p|o\leq i\leq p-1\}=\{0...p-q\}$
    * Un valore che se viene elevato a potenza modulo $p$ ricrea tutto l'insieme dei numeri naturali modulo $p$
    * Deve essere scelto con accuratezza
* Ogni utente genera la propria chiave
  * La chiave segreta è un numero random $x<p$
    * Deve essere abbastanza grande (altrimenti si trova subito)
  * Calcola la chiave pubblica (o mezza chiave): $R_1=g^x\mod p$
  * L'altro utente allo stesso modo crea le chiavi $y,R_2$
* Gli utenti si scambiano le chiavi pubbliche $R_1,R_2$
* Gli utenti calcolano il segreto comune
  * $S=R_1^y$
  * $S=R_2^x$
  * $(g^x)^y=(g^y)^x$
  * Il segreto comune può essere usato per qualsiasi cosa: come chiave, per autenticazione, etc...
* Un attaccante ha bisogno di uno tra $x,y$ per scoprire il segreto concordato, ma per farlo deve risolvere il logaritmo discreto di una tra $R_1,R_2$
* È resistente agli attacchi passivi, ma non a quelli attivi come man-in-the-middle

Soluzione:
* La soluzione è autenticare le chiavi pubbliche DH
* In genere le chiavi sono firmate con dei certificati a chiave pubblica
  * Si usa cifratura asimmetcica e firma digitale
  * Funziona anche se l'algoritmo fornisce solo firma e non cifratura (molto sexy)
* Una soluzione simile (DH modificato) è usata in SSL e IPSec

## Email Security

La mail è sicuramente il servizio più diffuso, è più antico di Internet, ed ovviamente è completamente insicuro (inizialmente, almeno).

Funzionamento:
* Alice e Bob hanno dei programmi
  * UA user agent
  * MTA message transfer agent
  * MAA message access agent
  * (i client di mail moderni fanno tutti quanti)
* Alice, dal suo MTA invia il messaggio ad un MTA server (quello del proprio provider) con SMTP
* Il server ha un altro MTA client per inviare la mail ad un altro server (quello del provider di Bob)
* Prima di arrivare al server di Bob potrebbe attraversarne molti altri
* Bob usa il suo MAA client per chiedere al server del proprio provider se ci sono mail da leggere (lo fa con POP3 o IMAP)
* Dov'è la cifratura? Infatti. È un retaggio di quando il mondo era più educato, quindi tutto gira in chiaro
  * È sicura come una cartolina delle vacanze
  * Comunque, al giorno d'oggi, si usano pop ed imap sicuri, quindila comunicazione tra utente e provider è protetta, ma solo quella. Se i messaggi non escono dal provider, solo quest ultimo riesce a sniffarli

Possibili miglioramenti:
* Confidenzialità: non vogliamo che la leggano altri
* Autenticazione: vogliamo garantire l'identità
* Integrità del messaggio: protezione da modifiche
* Non ripudio dell'origine: protezione dal rinnego da parte del mittente
* Non ripudio della destinazione: protezione dal rinnego da parte del destinatario

Sarebbe bello aggiungere i miglioramenti, mantenendo la caratteristica one-way delle mail. Purtroppo risulta che non si può fare per il non ripudio della destinazione, ma per gli altri si.
Per questo serve che il messaggio sia autocontenuto in un pacchettino con il testo e tutte le informazioni necessarie per la sicurezza.

### PGP Pretty Good Privacy

Simile ad S/MIME, noi vediamo solo PGP (standard de facto), anche se ora si usa S/MIME (standard de iure). La posta PEC usa S/MIME.

Sviluppato da Phil Zimmermann negli anni 90. Ha scritto un singolo programma singolo che prende il file e lo cifra, si invia come testo, il destinatario prende il testo, lo passa per lo stesso programma e viene fuori la mail.

Autenticazione:
* Il mittente crea il messaggio
* Calcola SHA-1 (160 bit)
* Firma l'hash con la chiave RSA privata e lo appende al testo
* Il ricevente usa la chiave RSA pubblica per decifrare l'hash
* Il ricevente compara gli hash

Confidenzialità:
* È troppo pesante cifrare tutto con RSA
* Genera una chiave random di sessione a 128 bit (o di più se serve) e la usa per cifrare il testo con IDEA (flusso) o con 3DES (blocco, con chiave a 198 bit) in modalità CBC
  * La chiave random è generata con l'algoritmo ANSI X12.17, utilizzando come seed 128 bit di informazioni derivate da input precedenti dell'utente e dai tempi del sistema
* Cifra la chiave di sessione con la chiave pubblica del destinatario (che deve essere nota)
* Viene inviata insieme al messaggio
* Viene inviato anche l'ID della chiave pubblica per comunicare al destinatario quale deve usare per decifrare

Compressione:
* Di default PGP comprime il messaggio con l'algoritmo ZIP
* Comprime il messaggio firmato, prima di cifrarlo
* Per compatibilità con la mail si deve codificare il messaggio completo con base64 (Radix-64)
  * Ogni byte corrisponde a 6 bit, ma è rappresentato come testo ASCII stampabile
  * Giusto per gradire si aggiunge anche un CRC del messaggio compresso
* Se il messaggio è troppo grande viene segmentato

Va da se che posso combinare queste tre funzionalità come preferisco per ottenere il servizio di cui ho bisogno.

Formato della mail:
* Messaggio codificato con base64
  * Informazioni su chiave di sessione
    * ID della chiave pubblica del destinatario
    * Chiave di sessione
  * Parte cifrata (con la chiave di sessione) e compressa (con ZIP)
    * Firma
      * Timestamp
      * ID della chiave pubblica del mittente
      * 2 byte prima dell'hash
      * Hash firmato con la chiave privata del mittente
    * Messaggio
      * Nome file
      * Timestamp
      * Dati

Lettura del messaggio:
* Il messaggio viene decompresso
* Si legge l'ID e si cerca la chiave privata per leggere la chiave di sessione
* Si usa la chiave di sessione per decifrare il resto
* Si legge l'ID della chiave del mittente e si usa per leggere l'hash firmato
* Si autentica la mail
* Si può leggere il testo

Al giorno d'oggi solo la comunicazione tra server e client è sicura di default (usa SSL), ma viagga tra i server in chiaro.

#### Gestione delle chiavi

Ogni utente si genera le chiavi e le autofirma (Zimmermann voleva renderlo viabile per chiunque).
Si forma una rete di fiducia. L'affidabilità di una chiave pubblica è data da: quanti altri amici di cui mi fidano hanno firmato la sua chiave fiducia, la fiducia massima è quando la chiave dell'interlocutore è firmata dirattamente da me.

### Posta Elettronica Certificata

I servizi PGP ed S/MIME permettono confidenzialità e autenticazione, ma non la "non ripudiabilità", per quello si usa la PEC. Nel mondo reale la PEC sarebbe equivalente ad una raccomandata.

Si invia la mail protetta con S/MIME (un po' più robusto) al server del provider, che manda a noi una ricevuta di accettazione. Il server la inoltrerà ad un altro server la mail ed attenderà una ricevuta di presa in carico, quando arriva al provider del destinatario, può dire di non averla letta, ma non di non averla ricevuta. Quando il destinatario controlla la casella di posta, invia (direttamente al mittente) una ricevuta di lettura.

## Sicurezza web

In particolare ci occupiamo della sicurezza di trasmissione, ma ci sono un sacco di minacce coinvolte nell'accesso al web.
Anzitutto tutti i router intermedi possono leggere e modificare il payload di tutte le pagine http.

Era successo che un gruppo di hacker che aveva hackerato il wifi di uno starbucks, avesse messo uno script che aggiunge un cryptominer javascript a tutte le pagin http. (questo per dimostrare che è un problema).

Possibili approcci:
* A livello di rete è pesante e system-wide (IPSec)
* A livello di trasporto è abbastanza generico e si fa in spazio utente
* A livello di applicazione dipende dall'applicazione specifica

### Sicurezza a livello di trasporto: SSL (Secure Socket Layer) e TLS (Transport Layer Security)

Sono dei servizi di sicurezza (alternativi e non compatibili) sviluppati inizialmente da Netscape.
Si sono detti: "ma se tutto è in chiaro, nessuno userà mai il web per fare acquisti", quindi hanno inventato una SSL per avere un livello di sicurezza utilizzabile da tutti i protocolli TCP.
Nel 1999 è diventato uno standard internet conosciuto come TLS.

Ora tutte le versioni di SSL (tranne 3.1) e le prime due versioni di TLS (1.0 ed 1.1) sono deprecate, perché soffrivano di dei bachi di sicurezza, ma questo non significa che nessuno le usi, perché sono state deprecate pochi anni fa. Come al solito, l'autenticazione è la parte difficile, ed infatti ci hanno diverse versioni per arrivare dove siamo ora.

### TLS

Lo vediamo come uno strato tra TCP e il livello applicativo. Fornisce delle socket che possono essere usate dal livello applicativo quasi come quelle insicure.

È diviso in due strati:
* Record Protocol
  * Implementa la cifratura e i vari meccanismi
  * In teoria è un protocollo di livello 6
* Handshake/Change Cipher/Alert Protocol
  * Usati per implementare le funzioni di autenticazione, segretezza, etc.
  * In teoria è un protocollo di livello 5

Come vediamo i livelli 5 e 6 sono invertiti.

#### TLS Session

Prima di iniziare la comunicazione bisogna aprire la sesione. Viene creata dall'handshake protocol e definisce le chiavi ed i cifrari da utilizzare per la comunicazione.
Queste informazioni sono mantenute nel session state.

Tra le informazioni dello stato trociamo il master secret: una chiave di 48 byte (384 bit). È il segreto condiviso principale, da questo vengono generate tutte le chiavi ed i vettori di inizializzazione per i protocolli di cifratura.

Stato:
* ID sessione
* Certificato del peer
* Metodo di compressione (se presente)
* Cipher suite
  * Una combinazione di: metodo di scambio, cifrario asimmetrico, cifrario simmetiico, hash, modalità (per i cifrari di blocco) etc
  * Esempi con SSL:
    * SSL_NULL_WITH_NULL_NULL (stato iniziale, nessuna sicurezza)
    * SSL_ RSA_WITH_NULL_MD5 (dati autenticati ma non segreti)
    * SSL_FORTEZZA_DSL_WITH_FORTEZZA_SHA1
  * Per TLS sono disponibili più combinazioni
    * TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA256
  * Non si devono fornire troppe opzioni, perché per rendere il protocollo insicuro basta romperne una
* Master secret
* Is resumable

#### Handshake Protocol

Questo è l'algoritmo più importante, il resto segue.

Viene lanciato per primo quando la suite è NULL e si occupa di:
* Autenticazione
* Negoziare gli algoritmi
* Negoziare le chiavi di cifratura

Fasi e messaggi:
* Fase 1:
  * ClientHello:
    * L'ID di sessione
    * Stabilisce la versione SSL/TLS
    * Propone alcune cipher suite
    * Propone il metodo di compressione
    * Un numero random per la generazione delle chiavi
  * ServerHello:
    * L'ID di sessione
    * Il server cerca un intersezione tra le cipher suite proposte e quelle che conosce/accetta
    * Lo stesso per il metodo di compressione
    * Il suo numero random
* Fase 2-3 (dipendono dall'esito della 1):
  * Nella fase 2 il server invia informazioni al client
  * Nella fase 3 il client invia informazioni al server
  * Le informazioni scambiate in entrambe le fasi cambiano a seconda della cipher suite
  * Supponiamo di avere scelto RSA
    * Il server manda il certificato X.509 al client
    * Il client lo verifica (eventualmente notifica l'utente)
    * Il client genera il pre-master secret e lo cifra con la chiave pubblica del server
    * Il server deve avere un certificato, ma il client no. Per questo poi vengono chiesti username e password dai siti.
      * Se si vuole non ripudiabilità servono altri meccanismi
  * Supponiamo di avere Diffie-Hellman anonimo (naive)
    * Il server non manda certificati
    * Il server manda la sua chiave pubblica
    * Il client non manda certificati
    * Il client manda la sua chiave pubblica
    * Sono usate per generare il master secret (lo stesso per tutte le versioni di DH)
    * Non è più ammesso su TLS 1.3 perché vulnetabile a MITM
  * Supponiamo Fixed DH (Diffie-Hellman autenticato)
    * Il client manda il certificato DH al client
    * Il client manda il certificato DH al server
    * Non è molto sicuro perché i mezzi segreti sono sempre gli stessi
  * Supponiamo DH efimero (il migliore)
    * Il server manda il certificato RSA o DSS
    * Il server manda il mezzo segreto firmato ed i parametri g e p
    * Il client manda il suo certificato RSA o DSS
    * Il client manda il suo mezzo segreto firmato e gli stessi parametri g e p
    * Quando possibile si usa questa
    * Serve che il client abbia un certificato (ne hai uno nella carta regionale dei servizi)
  * ... un sacco di altre combinazioni
    * Ad esempio si può usare la curva ellittica

#### Generazione del master secret

SSL usa un metodo "casalingo":
* Si scrive la stringa "A"||Pre-master||RandomClient||RandomServer
  * Si calcola l'hash con SHA-1
  * Si scrive la stringa Pre-master||hash
    * Si calcola MD5
* Si ripete con "BB"
* Si ripete con "CCC"
* Si concatenano i tre hash

TLS usa un metodo più "studiato":
* Come SSL, prende in input il pre-master secret e i due numeri random
* Li usa come seed per un algoritmo pseudorandom deterministico
* Alla fine SSL fa la stessa cosa, ma la sua funzione pseudorandom è ottenuta con una composizione di hash esistenti

#### TLS Connection

Dopo aver creato la sessione si possono aprire diverse sessioni, ciascuna di esse ha segreti e vettori di inizializzazione generati dal master secret.

Stato:
* Numeri random del server e del client
  * Scelti dalle due parti per ogni connessione
* Write MAC Secret del server
  * Serve per calcolare l'HMAC dal server al client
* Write MAC Secret del client
  * Serve per calcolare l'HMAC dal client al server
  * Non serve veramente che sia diverso da quello del server, ma è meglio
* Write secret del server
  * Chiave per la cifratura dal server al client
  * Associata ad uno dei vettori di inizializzazione
* Write secret del client
  * Come i MAC Secret non era veramente necessario che fosse diversa da quella del server. Ma lo preferiamo
* Vettori di inizializzazione
  * Vettori per la cifratura CBC dei messaggi
* Sequence number
  * Uno per ogni parte
  * Inizia a 0, fa wrap around a $2^{64}-1$ (64 bit)

I segreti vengono generati utilizzando la stessa funzione random usata per generare il master secret, ma sostituendo il pre-master secret al master secret
Essendo l'algoritmo pseudocasuale deterministico, e dal momento che le due parti condividono lo stesso seed (il master secret e le informazioni di sessione) possono generare indipendentemente i segreti di entrambe le parti, senza bisogno di accrodarsi.
La funzione pseudocasuale produce uno stream di dati casuali, ne viene prodotto abbastanza per tutti i segreti e poi "spezzato" nelle dimensioni corrette.

Le connessioni usano la stessa cipher suite della sessione. Cambiano solo i segreti.

#### TLS/SSL Record Protocol

Implementa le funzionalità di integrità e funzionalità utilizzando i segreti di connessione. Le funzionalità di autenticazione sono implementate dall'algoritmo di handshake.
Procedimento (di cifratura):
* Il messaggio viene spezzato in frammenti
* Ogni frammento viene compresso
* viene generato l'hash dai dati compressi e altri valori
* Da questo hash si calcola il MAC
* I dati compressi e il MAC sono cifrati
* Il frammento cifrato è incapsulato con l'intestazione del protocollo di record (RPH)
  * Contiene:
    * 8b Protocollo
    * 16b Versione
    * 16b Lunghezza
* Il frammento cifrato ed incapsulato viene inviato via TCP insicuro

Ovviamente la decifratura fa la stessa cosa ma al contrario.
La frammentazione e compressione rende più difficile analizzare il traffico sfruttando la dimensione dei dati da parte degli attaccanti.

#### Calcolo del MAC

Procedimento:
* Si concatenano:
  * MAC Write Secret
  * Paddin
  * Sequence number
  * Tipo di compressione
  * Dimensione di compressione
  * Frammento compresso
* Si calcola l'hash con l'algoritmo negoziato
* Si concatena:
  * MAC Write Secret
  * Padding (diversdo dal primo)
  * Hash calcolato
* Si calcola di nuovo l'hash con lo stesso algoritmo

#### Portare applicazioni a SSL/TLS

Non è difficile, chi ha progettato questi protocolli lo ha fatto apposta perche sia quasi un trova-sostituisci.

Prima di iniziare la comunicazione bisogna lanciare `SSL_library_init()` e `SSL_CTX_new()` che settano vari parametri ed opzioni riguardo i certificati.
Poi, serve lanciare `SSL_new()` che avvia il protocollo di handshake.

Dopo queste tre chiamate, le altre sono (intenzionalmente) del tutto analoge a quelle dei socket unix:
* `accept()`->`SSL_accept()`
* `read()`->`SSL_read()`
* ...

Per farlo serve il codice del programma.

### IPSec

E se non avessimo accesso al codice delle applicazioni? come facciamo a mettere in sicurezza il nostro traffico? Esiste un metodo per mettere in sicurezza tutto il sistema senza scomodare le applicazioni e senza implementaizioni di librerie?
Sono felice che tu lo abbia chiesto, perché si tratta di IPSec.

In genere viene utilizzato per realizzare le VPN (molto figo).

Utilizzi:
* Supponiamo di avere diverse persone che lavorano da casa in smart working
* Vorrebbero accedere ai loro dati aziendali come se fossero in ufficio, anche se non sono in ufficio
* Viene messa in piedi una rete virtuale
* Si usa IPSec per aprire un canale sicuro direttamente dal nostro PC o dal nostro router, ad una macchina (possibilmente il router) dell'ufficio
* La nostra macchina comunica attreverso questo canale sicuro senza accorgersene, come se ci fosse un cavo ethernet tra le due reti, che non attraversa Internet
* Serve che i router lo supportino

IPv6 prevede che IPSec sia supportato, perché una delle opzioni di IPv6 stesso, attiva IPSec, e la macchina deve essere pronta ad utilizzarlo se richiesto.

IPSec ha due modalità:
* Modalità trasporto (facile)
  * In modalità trasporto si inserisce tra il livello IP ed il livello di trasporto
  * Cifra ed incapsula i messaggi del livello di trasporto, prima di incapsularli nel normale protocollo IP
  * L'intestazione è in due parti: header e trailer
  * Il trailer è subito dopo l'intestazione IP
  * In IPv6 l'intestazione è uno dei campi opzionali di IP
* Modalità tunnel (più difficile, più usata)
  * Si mette tra il livello 3 e di nuovo il livello 3
  * Tutti i messaggi IP sono presi, cifrati ed incapsulati in IPSec
  * Poi sono di nuovo incapsulati nel normale protocollo IP
  * È più figa perché cattura tutto il traffico

#### Encapsulating Security Payload (ESP)

Messaggio completo:
* Intestazione IP
* Messaggio Autenticato
  * Informazioni di cifratura (intestazione IPSec)
    * Parametri
    * Sequence number
  * Messaggio cifrato
    * Payload cifrato
* Informazioni di autenticazione (MAC)

Notare che un attaccante vede verso che reti esiste il tunnel, ma non vede la destinazione finale dei pacchetti.

Tutto ciò sembra una cosa da livello di trasporto, anzitutto serve mantenere uno stato, soprattutto per quel sequence number. In effetti IPSec ha questo difetto, ma serve per evitare gli attacchi reply.

Dato che non è confermato, non serve che accetti tutti i pacchetti e può saltarne alcuni. Si apre una "finestra" che termina all'ultimo sequence number arrivato, se un messaggio è più basso della finestra o se lo ho già ricevuto lo scarto, forse è buono ma non importa, non è confermato IP è un problema per i protocolli sovrastanti, se fosse maligno sarebbe peggio.
Se arrivano messaggi oltre la finestra, la sposto.

#### Security association, IKE (Internet Key Exchange)

Le chiavi di cifratura per i diversi tunnel, sono scritte in un database, normalmente questo database viene manipolato manualmente dall'amministratore.

Per fortuna esiste un protocollo (IKE) che si occupa di scambio chiavi attraverso Internet, e viene usato per popolare questo database.
Quando una macchina prova a comunicare con un altra, ed il sistema decide che serve IPSec (in base a delle regole decise dall'amministratore), prima di tutto si cercano le chiavi nel database, se mancano viene avviato IKE che interroga il nostro interlocutore e popola i database di entrambi con le chiavi necessarie per lo scambio.
