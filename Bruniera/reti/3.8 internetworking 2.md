# Internetworking

Problema: abbiamo centinaia di tecnologie di rete diverse, come facciamo a connetterle? Gli switch ethernete vunzionano solo con reti ethernet o compatibili (WiFi), e così via.
Anche se tutto il mondo utilizzasse ethernet, il meccanismo degli spanning tree non riesce a scalare efficentemente a livello mondiale.
La soluzione è una internetwork.

Internetwork: Un gruppo di reti arbitrarie interconnesse per fonrnire qualche sorta di servizio di distribuzione dei pacchetti host to host.

Per implementare questa astrazione serve un protocollo di livello 3 (network layer).
Il più utilizzato è IP (internet protocol) e la sua variante IPv6, ma non è l'unico. Gira su tutti gli host della rete mondiale Internet.

Deve identificare ogni host di tutte le reti univocamente, ignorando le differenza della tecnologia sottostante.
Questa è l'astrazione che fornisce il protocollo. Posso indicare qualsiasi host senza sapere come ci sono connesso.

Le unità di dati a questo livello si chiamano pacchetti, ma a volte si utilizza datagrama, anche se dovrebbe indicare le unità a livello 4.

Quando si vuole inviare un messaggio dal livello di trasporto si specifica l'indirizzo ip dell'host, oltre agli altri indirizzi del livello superiore (che il protocollo IP ignora, ovviamente) e lo si passa ad IP.
Il messaggio viene incapsulato in un pacchetto e viene smistato sulle possibili interfaccie di rete,

Viceversa, quando si riceve un messaggio, tutte le interfaccie di rete lo passano al protocollo IP che lo smista tra i protocolli di livello 4.

È possibile che un host riceva un pacchetto che non è per lui, a seconda dei casi si può buttarlo via o instradarlo (inoltrarlo verso il destinatario).
La maggior parte degli host lo ignora, non sono istruiti per instradare. Alcuni dispositivi hanno lo scopo di instradare e sono istruiti a farlo, sono i router.

Un router (commutatore di livello 3) è un host con multiple interfaccie di rete, eventualmente di tecnologie diverse (a contrario dei bridge che erano principalmente omogenei), istruito per inoltrare i pacchetti da un interfaccia ad un altra.
questi dispositivi 

I router utilizzano una strategia store and forward. Ma in modo diverso dagli switch. Non considerano la tecnologia del link sottostante. Ogni link può essere di tecnologia diversa.
I pacchetti sono incapsulati, decapsulati ed incapsulati di nuovo.
L'inoltro è deciso in base agli IP, non agli indirizzi si lan.

Un host che vuole comunicare con un altro invierà dei pacchetti ad un router, che li decapsulerà ed incapsulerà secondo la tecnologia del link sottostante, ed invierà ad un altro router, eventualmente arriverà ad un router che lo inoltra all'host destinatario, l'intestazione IP non cambia (in teoria).

È un servizio senza connessione, ogni pacchetto è indipendente dagli altri, ed ogni router tratta ogni pacchetto singolarmente, quindi ogni pacchetto deve avere tutte le informazioni per l'instradamento.
I router moderni sono intelligienti e fanno dei calcoli per stabilire che flussi sono attivi ed ottimizzare la gestione dei pacchetti.

Dato che ogni pacchetto è trattato individualmente, pacchetti tra gli stessi host potrebbero prendere strade diverse, quindi possono arrivare fuori ordine, o non arrivare affatto. Può anche arrivare corrotto, ma è raro.
È una tecnologia best-effort (collegamento unreliable).

Un pacchetto può essere perso a causa della congestione. Il router non ha memoria infinita, quindi se la finisce dovrà eliminare alcuni pacchetti che non riesce a gestire. Più router attraversa più è probabile che succeda.

Si potrebbe rendere la rete affidabile, ma spesso non è necessario, quindi si decide di implementarla a livello superiore se serve. Inoltre, così il protocollo ip è più semplice, perché già l'astrazione che fa è complicata.

Gran parte delle tecnologie di rete che esistono ora non esistevano quando IP è stato progettato, ma dato che è stato progettato per evolversi e scalare, possono funzionare comunque.
Questa è una gran cosa.

## Pacchetto IP

Pacchetto IP:
* 4b versione (di solito v4 0100)
* 4b IHL IP header length in parole da 32 bit (di solito 5, quindi 20 byte)
  * 5 parole sono obbligatorie, possono essercene altre opzionali
* 8b TOS (type of service)
* 16b DImensione di tutto il pacchetto, intestazione e dati
  * Dimensione massima 65536, ma non si raggiunge mai
* 16b Identificativo del pacchetto
* 3b flag
  * 1b non usato
  * 1b don't fragment
  * 1b more fragment
* 13b offset frammentazione
* 8b TTL (time to live)
  * Numero di salti massimi tra i router, viene decrementato ad ogni salto
  * Impedisce ai pacchetti di vivere all'infinito in un loop, quando arriva a 0 viene scartato ed inviato un pacchetto CMP al mittente.
  * È più grossolano dello spanning tree, ma non si possono usare su reti così grandi, ed avere loop dà dei vantaggi
  * Limita il diametro della rete Internet, ma tanto in genere bastano 30 salti (in realtà succedono cose)
* 8b Protocol number (indica il protocollo di livello superiore)
* 16b checksum
  * Fa un controllo di integrità, si può impostare a 0 se non è importante
  * È ridondante rispetto al CRC e meno raffinato, ma potrebbe servire se usiamo tecnologie senza controllo di errore (oggi non ce ne sono)
* 32b IP mittente
* 32b IP destinatario
* ?W32 opzioni
* ?B dati

Sono presenti solo i due indirizzi, non il circuito, deve trovarlo il router.

### TOS

Specifica come deve essere trattato il datagram, ma non è molto usato perché non ci si può fidare degli utenti.

Interpretazione originale:
* In caso i congestione
  * 3b priorità (default 000, si lascia scegliere al router)
    * Potrebbe essere deciso in base al costo della linea
* Tipo di richiesta (default 0000, si lascia scegliere al router)
  * 1b (D) Minimizza il delay
  * 1b (T) Massimizza il throughput
  * 1b (R) Massimizza l'affidabilità
  * 1b (C) Minimizza il costo
* 1b non usato
* Ogni protocollo ha un TOS default associato, i router buoni potrebbero usare questi. ES:
  * SSH/telnet (programmi interattivi) D=1
  * FTP/SMTP (dati pesanti) T=1

Sono dei suggerimenti. Il router ci prova a seguire le indicazioni, ma non è detto che possa fare qualcosa.
Se si impostano richieste contrastanti, ovviamente, il router non può fare molto.
Non si segue molto (alcuni router non lo guardano nemmeno) perché altrimenti tutti gli utenti invierebbero sempre 11111110.

Interpretazione moderna (IPv4: DSCP):
* Se i 3b più a destra sono 000
  * I 3b più a sinistra sono la priorità, come nel TOS
* Se i 3b più a destra sono diversi da 000
  * I 6b più a destra sono 64 servizi
  * xxxx10 Tipi standard IETF
  * xxxx11 Tipi definiti dalle autorità della rete
  * xxxx01 Tipi sperimentali

Anche questi sono bellamente ignorati dai router.

### Frammentazione e riassemblamento

Utilizza la seconda parola dell'intestazione, quindi identificativo e valori di frammentazione.

Ogni link fisico ha una qualche MTU (unità massima di trasferimento) che dipende da che tecnologia utilizza.
Al livello 4 non la sappiamo, quindi invieremo pacchetti senza curarci di questa dimensione. Magari non è neanche la stessa del nostro link, ma dipende da una tecnologia che incontriamo a metà strada.
È un problema di cui deve occuparsi il livello IP, ai livelli sopra non devo saperne niente dei link, ed ai livelli sopra non conosco i link di tecnologie diverse.

L'idea è:
* Quando un pacchetto deve essere inoltrato in un link con MTU troppo basso lo spezza in frammenti e li invia singolarmente
* Tutti i frammenti dello stesso pacchetto hanno gli stessi indirizzi
* I router non ricomporranno i frammenti, perché magari prendono strade diverse ed i router intremedi potrebbero non vederli mai tutti
* È l'host a riassemblare i frammenti.

I pacchetti non frammentati (od i frammenti finali) hanno un qualche identificativo, offset = 0 e more fragment = 0
Qando si frammentano si mantiene lo stesso identificativo su tutti i frammenti e si imposta more fragment a 1 (tranne l'ulitmo che è uguale a quello del pacchetto originale).
Il falore di offset indica la posizione del frammento nel pacchetto, in word di 8 byte. Es: se il primo frammento è di 512 byte, il secondo avrà offset 64 = 512/8, se questo secondo ha a sua volta dimensione 512, il frammento successivo avrà offset 128 = 64 + 512 / 8.
Se si frammenta un pacchetto con more fragment a 1 anche l'ultimo frammento avrà more fragment = 1, ed i vari offset saranno traslati dell'offset del frammento iniziale.

Il destinatario comporrà i pacchetti istanziando un buffer e popolandolo in base all'offset, quando ha tutti i pacchetti intermedi ed il pacchetto con more fragment a 0 può passare il datagram al livello superiore.
Se passano 30 secondi butto via tutto, considero il pacchetto perso.

Frammenti dello stesso pacchetto sono identificati dai 16 bit di identificativo. Dato che 16 bit sono troppo pochi (inizialmente non lo erano), si osservano anche gli indirizzi.

## Indirizzamento

Per ottenere i vantaggi del livello tre serve un modo per indirizzare univocamente tutti i dispositivi della rete in un unico spazio.
Questi indirizzi sono divisi in due parti:
* Indirizzo di rete
  * Assegnato a ogni sistema autonomo da un'autorità centrale
* Indirizzo di host all'interno della rete
  * Ogni sistema autonomo assegna gli indirizzi dei suoi host

Sono sequenze di 32 bit e rappresentati come sequenze di 4 numeri da 0 a 255 (4 porzioni di 8 but) separati da punto.

Come separiamo l'indirizzo di rete da quello di host?
Storicamente Erano divisi in 3 classi a seconda di cosa si trova nei primi bit dell'indirizzo:
* Classe A: (poche reti grandi)
  * Iniziano con 0
  * 7 bit di rete
  * 24 bit di host
  * 127 possibili reti (0.0.0.0 non va bene)
  * $2^{24}-2$ possibili host
* Classe B: (tante reti medie)
  * Iniziano con 10
  * 14 bit di rete
  * 16 bit di host
  * 16384 reti
  * 65534 host
* Classe C: (tantissime reti piccole)
  * Iniziano con 110
  * 21 bit di rete
  * 8 bit di host
  * $2^{21}$ possibili reti
  * 254 possibili host
* In totale:
  * ~2000000 di reti
  * ~3750000000 di host

Gli indirizzi di rete sono quelli con tutti 0 nella parte degli host (es: 10.0.0.0 192.168.1.0) e non possono essere assegnati a nessun host, rappresentano la rete in se.
Gli indirizzi di broadcast sono quelli con tutti 1 nella parte degli host (es: 10.255.255.255 192.168.1.255) ed indicano tutti gli host della rete.
Ad alcuni sistemi viene assegnate un indirizzo di rete ed i sistemisti di quella rete possono assegnare gli indirizzi di quella rete come vogliono, ma non possono assegnare i due indirizzi di rete e di broadcast. Se assegnano

Gli enti dovrebbero richedere un indirizzo di rete di diversa classe a seconda di quanti host intende indirizzare.

È possibile avere quasi 4 miliardi di host con questo sistema, quando la rete Internet è stata progettata sembravano tanti. In realtà sono già finiti.
Per questo abbiamo il NAT per superare questo limite teorico.

Perché dobbiamo separare rete ed host? Adesso vediamo

## Instradamento

Se utilizzassimo per il livello 3 della rete globale la stessa tecnica di indirizzamento che utilizziamo per gli switch di livello 2, ci servirebbe una tabella con 3750000000 entry da, quindi occuperemmo circa 18 giga, quindi non funziona.
Possiamo farlo sulle reti piccole, è a questo che servono i dispositivi che chiamiamo switch di livello 3, sono più semplici di un router ed usano le stesse tecniche degli switch di livello 2.

L'indirizzamento sulla rete globale utilizza solo gli indirizzi di rete, che sono solo 2000000.

Strategia del singolo nodo:
* Ogni pacchetto contiene l'indirizzo destinatario, da cui estraiamo l'indirizzo di rete
* Se l'host è connesso direttamente alla rete di destinazione, inoltro direttamente all'host
  * Questo è fatto internamente alla rete locale, non importa come, magari con WiFi o con uno switch
* Se non è connesso direttamente, allora lo passo ad un router che dovrebbe sapere come gestirlo
  * Per fare questo devo istruire l'host per l'inoltro, altrimenti viene inviato ad un router default, se non ne ha uno droppato il pacchetto

Ogni host finale ha un router di default (gateway/default gateway) che mantiene una tabella di inoltro.
Per compilare la tabella ci serve uno specifico algoritmo di routing.

La tabella di inoltro (in questo caso possiamo chiamarla di routing) mantiene una entry per ogni rete di destinazione che conosce ed o l'indirizzo ip o l'interfaccia a cui trovare il prossimo salto per arrivare alla rete.

Ogni LAN locale deve avere un indirizzo di rete diverso. Host in reti diverse devono avere indirizzi di reti diverse.

## Subnetting

Le reti di classe A e B sono molto grandi. Può essere troppo grande per una sola rete LAN (chiedi ad uno switch di gestire $2^{24}-2$ host).
Quindi la separiamo in sottoreti più piccole, collegate da router.

Queste sottoreti devono avere indirizzi di rete diversi e devono fare parte della rete più grande, quindi utilizzano una parte dei bit dell'host come indirizzo della sottorete.
Per indicare quanta part dell'indirizzo è indirizzo di rete utilizziamo la maschera di sottorete (subnet mask), una sequenza di 32 bit con tutti 1 nella parte della rete.

Es:
* Abbiamo un indirizzo di classe B, quindi 14 bit di rete e 16 di host
* Vogliamo suddividerlo in 255 sottoreti, quindi un byte di indirizzo di rete in più.
* Utilizziamo la maschera 11111111111111111111111100000000
  * Rappresentata come 255.255.255.0
* L'indirizzo è diviso in tre parti:
  * Indirizzo di rete
  * Indirizzo di sottorete
    * La parte di indirizzo originariamente di host coperta dalla subnet mask
  * Indirizzo di host

La mask non può essere più piccola dell'indirizzo di rete della classe, non posso ingrandire il mio range, posso solo partizionarlo.
Nelle tabelle di inoltro inserirò sia IP che maschera di sottorete, quindi quando arriva un ip controllo se mascherato dalla mask corrisponde all'indirizzo.
Nei router moderni se ho due corrispondenze prediligo la più lunga, i router vecchi andavano in ordine e sceglievano il primo match.

Tutti i router esterni alla mia rete non sanno della mia partizione, useranno la maschera standard per indirizzare fino al gateway della mia rete.
Il gateway ed i router che separano le sottoreti conoscono le maschere, e potranno smistare i pacchetti tra le partizioni.

Possibile tabella esterna:
| Rete | Mask | Next hop |
| --- | --- | --- |
| 9.0.0.0 | 255.0.0.0 | 10.22.34.2 |
| 158.110.0.0 | 255.255.0.0 | 158.111.3.47 |
| ... | ... | ... |

Possibile tabella del primo router interno:
| Rete | Mask | Next hop |
| --- | --- | --- |
| 0.0.0.0 | 0.0.0.0 | 158.111.3.46 |
| 158.110.1.0 | 255.255.255.0 | 158.110.0.1 |
| 158.110.2.0 | 255.255.255.0 | 158.110.0.2 |
| 158.110.3.0 | 255.255.255.0 | 158.110.0.3 |
| 158.110.4.0 | 255.255.255.0 | 158.110.0.4 |
| ... | ... | ... |

All'interno della mia rete posso partizionare come voglio.
Ogni sottorete ha due indirizzi non utilizzabili (rete e broadcast) quindi vado a perdere indirizzi quando partiziono tanto.
Ma non è grave, considerando che tanto non possiamo possiamo gestire reti di 65534 host

Se ho una entry:
| Rete | Mask | Next hop |
| --- | --- | --- |
| 0.0.0.0 | 0.0.0.0 | 192.168.1.1 |

questo è un default gateway.
Nell'esempio visto sopra, il router più esterno alla mia rete ha una serie di porte verso le sottoreti (magari una sola collegata ad uno switch di livello 2) e una porta collegata ad un router della rete globale (158.111.3.50).
Il mio router non ha bisogno di sapere i percorsi verso tutte le diverse reti globali, sa che tutte quelle che non sono sottoreti, passano per quel router esterno a cui è collegato, quindi basta indirizzare tutto verso di quello.

Se ho una entry:
| Rete | Mask | Next hop |
| --- | --- | --- |
| 158.111.3.47 | 255.255.255.255 | 192.168.1.1 |

questa è una regola verso un singolo host, posso usarle se voglio che un particolare host prenda una strada diversa da quella che prendono gli altri pacchetti verso la sua rete.
Comunque, posso controllare solo il primo salto.

Se vuoi, in teoria, puoi usare maschere di sottorete esotiche come 255.255.0.1, e funziona. Dividi la rete in due sottoreti in base alla parità dell'ultimo byte.
Ma se lo fai significa che hai il cervello traforato, soprattutto ci dispiace per chi dovrà gestire la rete dopo di te.
Alcuni router non te lo lasciano fare, perché è stupido. Soprattutto se usa la notazione CIDR (che vediamo in seguito).

### Classless inter-domain routing (CIDR, Supernetting)

Assegnare range che non sono classi standard.

Questa tecnica cerca di risolvere due probleimi dello scaling di Internet:
* La crescita delle tabelle di routing
* L'esaurimento dello spazio di indirizzi

Dividere gli indirizzi in tre classi ci forza a consegnare parti della rete in blocchi di dimensioni fisse molto diverse.
Magari una rete ha bisogno di 300 indirizzi, quindi una rete di classe C non basta e gli dobbiamo dare una classe B. Ora ci troviamo 65234 indirizzi inutilizzati che non può usare nessuno.

Tentativo di soluzione:
* Non assegnamo più nessuna classe B ad un sistema autonomo almeo che non dimostri che gli serve davvero.
* Assegnare più classi di classe C se chiedono più indirizzi, per diminuire gli indirizzi sprecati (nel nostro esempio sarebbero sprecati solo 154 indirizzi)
  * Adesso che abbiamo più reti di classe C nello stesso posto, ogni router della backbone deve avere più entry per ciascuna di quelle reti, anche se sono nello stesso posto
  * Le tabelle diventano gigantesche per niente

Classless addressing:
* Ignorando le classi, raggruppiamo le reti contigue di una classe (ad esempio C) come una sola rete di classe più alta
* Nel nostro esempio avremmo raggruppato le due reti di classe C come una rete con mask 255.255.254.0, e le avremmo assegnare in modo che differiscano solo nell'ultimo bit del terzo byte.
* In questo modo abbiamo una sola entry nei router, ed a seconda degli indirizzi possiamo raggrupparla con altre reti adiacenti per rimpicciolire ancora la tabella.
* A questo punto possiamo sommare reti di qualsiasi classe per ottenere spazi di qualsiasi dimensione.

Per comodità e per convenzione utilizziamo la notazione CIDR per indicare la dimensione del prefisso di rete.
per indicare una rete 158.110.0.0 con net mask 255.255.240.0 usiamo la notazione 158.110.0.0/20.
In questo modo non possiamo più avere le sottoreti "esotiche" del tipo 255.255.0.1, che non è necessariamente un male.
Questa notazione è praticamente standard con IPv4, ed è presa in prestito dalla notazione standard di IPv6 (in v6 potremmo trovarci con una rete /126 che se indicassimo come maschera sarebbe ff.ff.ff.ff.ff.ff.ff.ff.ff.ff.ff.ff.ff.ff.ff.fc)
Le classi A, B e C hanno notazione CIDR /8, /16 e /24.

Quando qualcuno chiede uno spazio di indirizzi, gli forniamo uno spazio su misura, non usiamo più le classi standard.
Quando possiamo raggruppiamo le regole della routing table per diminuirne la dimensione (route aggregation)

### Route aggregation

Quando ho delle reti con indirizzi contigui e lo stesso next hop posso raggruppare la regola come un unica entry.
Notiamo che la route aggregation è la stessa cosa che succedeva quando assegnavo una rete ad un ente, e questo la partizionava a modo suo, solo che viene fatto anche per reti originariamente separate

Supponiamo la situazione:

| Rete | Mask | Next hop |
| --- | --- | --- |
| 158.110.1.0 | 255.255.255.0 | 158.110.0.1 |
| 158.110.2.0 | 255.255.255.0 | 158.110.0.1 |
| 158.110.3.0 | 255.255.255.0 | 158.110.0.1 |
| 158.110.4.0 | 255.255.255.0 | 158.110.0.2 |

Notiamo che se non fosse per la rete 158.110.4.0 (che ha next hop 158.110.0.2) potremmo raggruppare tute le reti nella regola:

| Rete | Mask | Next hop |
| --- | --- | --- |
| 158.110.0.0 | 255.255.252.0 | 158.110.0.1 |

Per fortuna, entra in nostro aiuto il longest match.
Come abbiamo detto nella sezione sul subnetting, se un indirizzo ha più match scegliamo quello con la corrispondenza più lunga (maschera più grande/sottorete più piccola/etc).
Quindi potremmo aggiungere al gruppo la regola per l'indirizzo 158.111.4.0 senza intaccare le altre.

| Rete | Mask | Next hop |
| --- | --- | --- |
| 158.110.0.0 | 255.255.252.0 | 158.110.0.1 |
| 158.110.4.0 | 255.255.255.0 | 158.110.0.2 |

Quando arriva un messaggio per l'indirizzo 158.110.2.5, il match sarà solo con la prima regola e verrà indirizzato cverso 158.110.0.1.
Quando arriva un messaggio per 158.110.4.56 avrà un match con entrambe le regole, ma dato che la mascherà /24 è più grande della maschera /22, verrà selezionata la seconda regola, quindi indirizzato a 158.110.0.2

Nei router vecchi non è presente questa regola, si usa il first match. Il nome è self-explanatory, scorre in ordine e sceglie la prima regola con cui ha un match.
In questi router, per ottenere lo stesso risultato dovrei utilizzare esattamente la tabella 

| Rete | Mask | Next hop |
| --- | --- | --- |
| 158.110.4.0 | 255.255.255.0 | 158.110.0.2 |
| 158.110.0.0 | 255.255.252.0 | 158.110.0.1 |

In questa tabella, a contrario di quella vista prima, l'ordine delle regole conta, perché fa parte della decisione di routing.
Per ottenere lo stesso effetto del longest match bisogna ordinare le regole in base alla maschera di sottorete.

Sono pochi i router rimasti con first match, ora quasi tutti usano longest match.

## Indirizzi speciali (RFC 5735)

* 0.0.0.0/8 non indirizzabile, invalido. Si usa per indicare "un IP qualsiasi"
* 10.0.0.0/8 usato per reti private, non collegate a Internet (NAT)
* 172.16.0.0/12 usato per reti private, non collegate a Internet (NAT)
  * Normalmente partizionata in 16 sottoreti di classe B
* 192.168.0.0/16 usato per reti private, non collegate a Internet (NAT)
  * Normalmente partizionata in 256 sottoreti di classe C
* 127.0.0.0/8 Loopback (me stesso)
* 169.254.0.0/16 Indirizzi per l'autoconfigurazione quando non c'è DHCP (protocollo APIPA)
* 224.0.0.0/4 classe D. Indirizzi di multicast
* 240.0.0.0/4 classe E. Riservata per usi futuri (mai usate, in realtà)