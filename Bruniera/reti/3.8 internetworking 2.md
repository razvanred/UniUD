# Internetworking

Problema: abbiamo centinaia di tecnologie di rete diverse, come facciamo a connetterle? Gli switch ethernete vunzionano solo con reti ethernet o compatibili (WiFi), e così via.
Anche se tutto il mondo utilizzasse ethernet, il meccanismo degli spanning tree non riesce a scalare efficentemente a livello mondiale.
La soluzione è una internetwork.

Internetwork: Un gruppo di reti arbitrarie interconnesse per fonrnire qualche sorta di servizio di distribuzione dei pacchetti host to host.

Per implementare questa astrazione serve un protocollo di livello 3 (network layer).
Il più utilizzato è IP (internet protocol) e la sua variante IPv6, ma non è l'unico. Gira su tutti gli host della rete mondiale Internet.

Deve identificare ogni host di tutte le reti univocamente, ignorando le differenza della tecnologia sottostante.
Questa è l'astrazione che fornisce il protocollo. Posso indicare qualsiasi host senza sapere come ci sono connesso.

Le unità di dati a questo livello si chiamano pacchetti, ma a volte si utilizza datagrama, anche se dovrebbe indicare le unità a livello 4.

Quando si vuole inviare un messaggio dal livello di trasporto si specifica l'indirizzo ip dell'host, oltre agli altri indirizzi del livello superiore (che il protocollo IP ignora, ovviamente) e lo si passa ad IP.
Il messaggio viene incapsulato in un pacchetto e viene smistato sulle possibili interfaccie di rete,

Viceversa, quando si riceve un messaggio, tutte le interfaccie di rete lo passano al protocollo IP che lo smista tra i protocolli di livello 4.

È possibile che un host riceva un pacchetto che non è per lui, a seconda dei casi si può buttarlo via o instradarlo (inoltrarlo verso il destinatario).
La maggior parte degli host lo ignora, non sono istruiti per instradare. Alcuni dispositivi hanno lo scopo di instradare e sono istruiti a farlo, sono i router.

Un router (commutatore di livello 3) è un host con multiple interfaccie di rete, eventualmente di tecnologie diverse (a contrario dei bridge che erano principalmente omogenei), istruito per inoltrare i pacchetti da un interfaccia ad un altra.
questi dispositivi 

I router utilizzano una strategia store and forward. Ma in modo diverso dagli switch. Non considerano la tecnologia del link sottostante. Ogni link può essere di tecnologia diversa.
I pacchetti sono incapsulati, decapsulati ed incapsulati di nuovo.
L'inoltro è deciso in base agli IP, non agli indirizzi si lan.

Un host che vuole comunicare con un altro invierà dei pacchetti ad un router, che li decapsulerà ed incapsulerà secondo la tecnologia del link sottostante, ed invierà ad un altro router, eventualmente arriverà ad un router che lo inoltra all'host destinatario, l'intestazione IP non cambia (in teoria).

È un servizio senza connessione, ogni pacchetto è indipendente dagli altri, ed ogni router tratta ogni pacchetto singolarmente, quindi ogni pacchetto deve avere tutte le informazioni per l'instradamento.
I router moderni sono intelligienti e fanno dei calcoli per stabilire che flussi sono attivi ed ottimizzare la gestione dei pacchetti.

Dato che ogni pacchetto è trattato individualmente, pacchetti tra gli stessi host potrebbero prendere strade diverse, quindi possono arrivare fuori ordine, o non arrivare affatto. Può anche arrivare corrotto, ma è raro.
È una tecnologia best-effort (collegamento unreliable).

Un pacchetto può essere perso a causa della congestione. Il router non ha memoria infinita, quindi se la finisce dovrà eliminare alcuni pacchetti che non riesce a gestire. Più router attraversa più è probabile che succeda.

Si potrebbe rendere la rete affidabile, ma spesso non è necessario, quindi si decide di implementarla a livello superiore se serve. Inoltre, così il protocollo ip è più semplice, perché già l'astrazione che fa è complicata.

Gran parte delle tecnologie di rete che esistono ora non esistevano quando IP è stato progettato, ma dato che è stato progettato per evolversi e scalare, possono funzionare comunque.
Questa è una gran cosa.

## Pacchetto IP

Pacchetto IP:
* 4b versione (di solito v4 0100)
* 4b IHL IP header length in parole da 32 bit (di solito 5, quindi 20 byte)
  * 5 parole sono obbligatorie, possono essercene altre opzionali
* 8b TOS (type of service)
* 16b DImensione di tutto il pacchetto, intestazione e dati
  * Dimensione massima 65536, ma non si raggiunge mai
* 16b Identificativo del pacchetto
* 3b flag
  * 1b non usato
  * 1b don't fragment
  * 1b more fragment
* 13b offset frammentazione
* 8b TTL (time to live)
  * Numero di salti massimi tra i router, viene decrementato ad ogni salto
  * Impedisce ai pacchetti di vivere all'infinito in un loop, quando arriva a 0 viene scartato ed inviato un pacchetto CMP al mittente.
  * È più grossolano dello spanning tree, ma non si possono usare su reti così grandi, ed avere loop dà dei vantaggi
  * Limita il diametro della rete Internet, ma tanto in genere bastano 30 salti (in realtà succedono cose)
* 8b Protocol number (indica il protocollo di livello superiore)
* 16b checksum
  * Fa un controllo di integrità, si può impostare a 0 se non è importante
  * È ridondante rispetto al CRC e meno raffinato, ma potrebbe servire se usiamo tecnologie senza controllo di errore (oggi non ce ne sono)
* 32b IP mittente
* 32b IP destinatario
* ?W32 opzioni
* ?B dati

Sono presenti solo i due indirizzi, non il circuito, deve trovarlo il router.

### TOS

Specifica come deve essere trattato il datagram, ma non è molto usato perché non ci si può fidare degli utenti.

Interpretazione originale:
* In caso i congestione
  * 3b priorità (default 000, si lascia scegliere al router)
    * Potrebbe essere deciso in base al costo della linea
* Tipo di richiesta (default 0000, si lascia scegliere al router)
  * 1b (D) Minimizza il delay
  * 1b (T) Massimizza il throughput
  * 1b (R) Massimizza l'affidabilità
  * 1b (C) Minimizza il costo
* 1b non usato
* Ogni protocollo ha un TOS default associato, i router buoni potrebbero usare questi. ES:
  * SSH/telnet (programmi interattivi) D=1
  * FTP/SMTP (dati pesanti) T=1

Sono dei suggerimenti. Il router ci prova a seguire le indicazioni, ma non è detto che possa fare qualcosa.
Se si impostano richieste contrastanti, ovviamente, il router non può fare molto.
Non si segue molto (alcuni router non lo guardano nemmeno) perché altrimenti tutti gli utenti invierebbero sempre 11111110.

Interpretazione moderna (IPv4: DSCP):
* Se i 3b più a destra sono 000
  * I 3b più a sinistra sono la priorità, come nel TOS
* Se i 3b più a destra sono diversi da 000
  * I 6b più a destra sono 64 servizi
  * xxxx10 Tipi standard IETF
  * xxxx11 Tipi definiti dalle autorità della rete
  * xxxx01 Tipi sperimentali

Anche questi sono bellamente ignorati dai router.

### Frammentazione e riassemblamento

Utilizza la seconda parola dell'intestazione, quindi identificativo e valori di frammentazione.

Ogni link fisico ha una qualche MTU (unità massima di trasferimento) che dipende da che tecnologia utilizza.
Al livello 4 non la sappiamo, quindi invieremo pacchetti senza curarci di questa dimensione. Magari non è neanche la stessa del nostro link, ma dipende da una tecnologia che incontriamo a metà strada.
È un problema di cui deve occuparsi il livello IP, ai livelli sopra non devo saperne niente dei link, ed ai livelli sopra non conosco i link di tecnologie diverse.

L'idea è:
* Quando un pacchetto deve essere inoltrato in un link con MTU troppo basso lo spezza in frammenti e li invia singolarmente
* Tutti i frammenti dello stesso pacchetto hanno gli stessi indirizzi
* I router non ricomporranno i frammenti, perché magari prendono strade diverse ed i router intremedi potrebbero non vederli mai tutti
* È l'host a riassemblare i frammenti.

I pacchetti non frammentati (od i frammenti finali) hanno un qualche identificativo, offset = 0 e more fragment = 0
Qando si frammentano si mantiene lo stesso identificativo su tutti i frammenti e si imposta more fragment a 1 (tranne l'ulitmo che è uguale a quello del pacchetto originale).
Il falore di offset indica la posizione del frammento nel pacchetto, in word di 8 byte. Es: se il primo frammento è di 512 byte, il secondo avrà offset 64 = 512/8, se questo secondo ha a sua volta dimensione 512, il frammento successivo avrà offset 128 = 64 + 512 / 8.
Se si frammenta un pacchetto con more fragment a 1 anche l'ultimo frammento avrà more fragment = 1, ed i vari offset saranno traslati dell'offset del frammento iniziale.

Il destinatario comporrà i pacchetti istanziando un buffer e popolandolo in base all'offset, quando ha tutti i pacchetti intermedi ed il pacchetto con more fragment a 0 può passare il datagram al livello superiore.
Se passano 30 secondi butto via tutto, considero il pacchetto perso.

Frammenti dello stesso pacchetto sono identificati dai 16 bit di identificativo. Dato che 16 bit sono troppo pochi (inizialmente non lo erano), si osservano anche gli indirizzi.

## Indirizzamento

Per ottenere i vantaggi del livello tre serve un modo per indirizzare univocamente tutti i dispositivi della rete in un unico spazio.
Questi indirizzi sono divisi in due parti:
* Indirizzo di rete
  * Assegnato a ogni sistema autonomo da un'autorità centrale
* Indirizzo di host all'interno della rete
  * Ogni sistema autonomo assegna gli indirizzi dei suoi host

Sono sequenze di 32 bit e rappresentati come sequenze di 4 numeri da 0 a 255 (4 porzioni di 8 but) separati da punto.

Come separiamo l'indirizzo di rete da quello di host?
Storicamente Erano divisi in 3 classi a seconda di cosa si trova nei primi bit dell'indirizzo:
* Classe A: (poche reti grandi)
  * Iniziano con 0
  * 7 bit di rete
  * 24 bit di host
  * 127 possibili reti (0.0.0.0 non va bene)
  * $2^{24}-2$ possibili host
* Classe B: (tante reti medie)
  * Iniziano con 10
  * 14 bit di rete
  * 16 bit di host
  * 16384 reti
  * 65534 host
* Classe C: (tantissime reti piccole)
  * Iniziano con 110
  * 21 bit di rete
  * 8 bit di host
  * $2^{21}$ possibili reti
  * 254 possibili host
* In totale:
  * ~2000000 di reti
  * ~3750000000 di host

Gli indirizzi di rete sono quelli con tutti 0 nella parte degli host (es: 10.0.0.0 192.168.1.0) e non possono essere assegnati a nessun host, rappresentano la rete in se.
Gli indirizzi di broadcast sono quelli con tutti 1 nella parte degli host (es: 10.255.255.255 192.168.1.255) ed indicano tutti gli host della rete.
Ad alcuni sistemi viene assegnate un indirizzo di rete ed i sistemisti di quella rete possono assegnare gli indirizzi di quella rete come vogliono, ma non possono assegnare i due indirizzi di rete e di broadcast. Se assegnano

Gli enti dovrebbero richedere un indirizzo di rete di diversa classe a seconda di quanti host intende indirizzare.

È possibile avere quasi 4 miliardi di host con questo sistema, quando la rete Internet è stata progettata sembravano tanti. In realtà sono già finiti.
Per questo abbiamo il NAT per superare questo limite teorico.

Perché dobbiamo separare rete ed host? Adesso vediamo

## Instradamento

Se utilizzassimo per il livello 3 della rete globale la stessa tecnica di indirizzamento che utilizziamo per gli switch di livello 2, ci servirebbe una tabella con 3750000000 entry da, quindi occuperemmo circa 18 giga, quindi non funziona.
Possiamo farlo sulle reti piccole, è a questo che servono i dispositivi che chiamiamo switch di livello 3, sono più semplici di un router ed usano le stesse tecniche degli switch di livello 2.

L'indirizzamento sulla rete globale utilizza solo gli indirizzi di rete, che sono solo 2000000.

Strategia del singolo nodo:
* Ogni pacchetto contiene l'indirizzo destinatario, da cui estraiamo l'indirizzo di rete
* Se l'host è connesso direttamente alla rete di destinazione, inoltro direttamente all'host
  * Questo è fatto internamente alla rete locale, non importa come, magari con WiFi o con uno switch
* Se non è connesso direttamente, allora lo passo ad un router che dovrebbe sapere come gestirlo
  * Per fare questo devo istruire l'host per l'inoltro, altrimenti viene inviato ad un router default, se non ne ha uno droppato il pacchetto

Ogni host finale ha un router di default (gateway/default gateway) che mantiene una tabella di inoltro.
Per compilare la tabella ci serve uno specifico algoritmo di routing.

La tabella di inoltro (in questo caso possiamo chiamarla di routing) mantiene una entry per ogni rete di destinazione che conosce ed o l'indirizzo ip o l'interfaccia a cui trovare il prossimo salto per arrivare alla rete.

Ogni LAN locale deve avere un indirizzo di rete diverso. Host in reti diverse devono avere indirizzi di reti diverse.

## Subnetting

Le reti di classe A e B sono molto grandi. Può essere troppo grande per una sola rete LAN (chiedi ad uno switch di gestire $2^{24}-2$ host).
Quindi la separiamo in sottoreti più piccole, collegate da router.

Queste sottoreti devono avere indirizzi di rete diversi e devono fare parte della rete più grande, quindi utilizzano una parte dei bit dell'host come indirizzo della sottorete.
Per indicare quanta part dell'indirizzo è indirizzo di rete utilizziamo la maschera di sottorete (subnet mask), una sequenza di 32 bit con tutti 1 nella parte della rete.

Es:
* Abbiamo un indirizzo di classe B, quindi 14 bit di rete e 16 di host
* Vogliamo suddividerlo in 255 sottoreti, quindi un byte di indirizzo di rete in più.
* Utilizziamo la maschera 11111111111111111111111100000000
  * Rappresentata come 255.255.255.0
* L'indirizzo è diviso in tre parti:
  * Indirizzo di rete
  * Indirizzo di sottorete
    * La parte di indirizzo originariamente di host coperta dalla subnet mask
  * Indirizzo di host

La mask non può essere più piccola dell'indirizzo di rete della classe, non posso ingrandire il mio range, posso solo partizionarlo.
Nelle tabelle di inoltro inserirò sia IP che maschera di sottorete, quindi quando arriva un ip controllo se mascherato dalla mask corrisponde all'indirizzo.
Nei router moderni se ho due corrispondenze prediligo la più lunga, i router vecchi andavano in ordine e sceglievano il primo match.

Tutti i router esterni alla mia rete non sanno della mia partizione, useranno la maschera standard per indirizzare fino al gateway della mia rete.
Il gateway ed i router che separano le sottoreti conoscono le maschere, e potranno smistare i pacchetti tra le partizioni.

Possibile tabella esterna:
| Rete | Mask | Next hop |
| --- | --- | --- |
| 9.0.0.0 | 255.0.0.0 | 10.22.34.2 |
| 158.110.0.0 | 255.255.0.0 | 158.111.3.47 |
| ... | ... | ... |

Possibile tabella del primo router interno:
| Rete | Mask | Next hop |
| --- | --- | --- |
| 0.0.0.0 | 0.0.0.0 | 158.111.3.46 |
| 158.110.1.0 | 255.255.255.0 | 158.110.0.1 |
| 158.110.2.0 | 255.255.255.0 | 158.110.0.2 |
| 158.110.3.0 | 255.255.255.0 | 158.110.0.3 |
| 158.110.4.0 | 255.255.255.0 | 158.110.0.4 |
| ... | ... | ... |

All'interno della mia rete posso partizionare come voglio.
Ogni sottorete ha due indirizzi non utilizzabili (rete e broadcast) quindi vado a perdere indirizzi quando partiziono tanto.
Ma non è grave, considerando che tanto non possiamo possiamo gestire reti di 65534 host

Se ho una entry:
| Rete | Mask | Next hop |
| --- | --- | --- |
| 0.0.0.0 | 0.0.0.0 | 192.168.1.1 |

questo è un default gateway.
Nell'esempio visto sopra, il router più esterno alla mia rete ha una serie di porte verso le sottoreti (magari una sola collegata ad uno switch di livello 2) e una porta collegata ad un router della rete globale (158.111.3.50).
Il mio router non ha bisogno di sapere i percorsi verso tutte le diverse reti globali, sa che tutte quelle che non sono sottoreti, passano per quel router esterno a cui è collegato, quindi basta indirizzare tutto verso di quello.

Se ho una entry:
| Rete | Mask | Next hop |
| --- | --- | --- |
| 158.111.3.47 | 255.255.255.255 | 192.168.1.1 |

questa è una regola verso un singolo host, posso usarle se voglio che un particolare host prenda una strada diversa da quella che prendono gli altri pacchetti verso la sua rete.
Comunque, posso controllare solo il primo salto.

Se vuoi, in teoria, puoi usare maschere di sottorete esotiche come 255.255.0.1, e funziona. Dividi la rete in due sottoreti in base alla parità dell'ultimo byte.
Ma se lo fai significa che hai il cervello traforato, soprattutto ci dispiace per chi dovrà gestire la rete dopo di te.
Alcuni router non te lo lasciano fare, perché è stupido. Soprattutto se usa la notazione CIDR (che vediamo in seguito).

### Classless inter-domain routing (CIDR, Supernetting)

Assegnare range che non sono classi standard.

Questa tecnica cerca di risolvere due probleimi dello scaling di Internet:
* La crescita delle tabelle di routing
* L'esaurimento dello spazio di indirizzi

Dividere gli indirizzi in tre classi ci forza a consegnare parti della rete in blocchi di dimensioni fisse molto diverse.
Magari una rete ha bisogno di 300 indirizzi, quindi una rete di classe C non basta e gli dobbiamo dare una classe B. Ora ci troviamo 65234 indirizzi inutilizzati che non può usare nessuno.

Tentativo di soluzione:
* Non assegnamo più nessuna classe B ad un sistema autonomo almeo che non dimostri che gli serve davvero.
* Assegnare più classi di classe C se chiedono più indirizzi, per diminuire gli indirizzi sprecati (nel nostro esempio sarebbero sprecati solo 154 indirizzi)
  * Adesso che abbiamo più reti di classe C nello stesso posto, ogni router della backbone deve avere più entry per ciascuna di quelle reti, anche se sono nello stesso posto
  * Le tabelle diventano gigantesche per niente

Classless addressing:
* Ignorando le classi, raggruppiamo le reti contigue di una classe (ad esempio C) come una sola rete di classe più alta
* Nel nostro esempio avremmo raggruppato le due reti di classe C come una rete con mask 255.255.254.0, e le avremmo assegnare in modo che differiscano solo nell'ultimo bit del terzo byte.
* In questo modo abbiamo una sola entry nei router, ed a seconda degli indirizzi possiamo raggrupparla con altre reti adiacenti per rimpicciolire ancora la tabella.
* A questo punto possiamo sommare reti di qualsiasi classe per ottenere spazi di qualsiasi dimensione.

Per comodità e per convenzione utilizziamo la notazione CIDR per indicare la dimensione del prefisso di rete.
per indicare una rete 158.110.0.0 con net mask 255.255.240.0 usiamo la notazione 158.110.0.0/20.
In questo modo non possiamo più avere le sottoreti "esotiche" del tipo 255.255.0.1, che non è necessariamente un male.
Questa notazione è praticamente standard con IPv4, ed è presa in prestito dalla notazione standard di IPv6 (in v6 potremmo trovarci con una rete /126 che se indicassimo come maschera sarebbe ffff:ffff:ffff:ffff:ffff:ffff:ffff:fffc)
Le classi A, B e C hanno notazione CIDR /8, /16 e /24.

Quando qualcuno chiede uno spazio di indirizzi, gli forniamo uno spazio su misura, non usiamo più le classi standard.
Quando possiamo raggruppiamo le regole della routing table per diminuirne la dimensione (route aggregation)

### Route aggregation

Quando ho delle reti con indirizzi contigui e lo stesso next hop posso raggruppare la regola come un unica entry.
Notiamo che la route aggregation è la stessa cosa che succedeva quando assegnavo una rete ad un ente, e questo la partizionava a modo suo, solo che viene fatto anche per reti originariamente separate

Supponiamo la situazione:

| Rete | Mask | Next hop |
| --- | --- | --- |
| 158.110.1.0 | 255.255.255.0 | 158.110.0.1 |
| 158.110.2.0 | 255.255.255.0 | 158.110.0.1 |
| 158.110.3.0 | 255.255.255.0 | 158.110.0.1 |
| 158.110.4.0 | 255.255.255.0 | 158.110.0.2 |

Notiamo che se non fosse per la rete 158.110.4.0 (che ha next hop 158.110.0.2) potremmo raggruppare tute le reti nella regola:

| Rete | Mask | Next hop |
| --- | --- | --- |
| 158.110.0.0 | 255.255.252.0 | 158.110.0.1 |

Per fortuna, entra in nostro aiuto il longest match.
Come abbiamo detto nella sezione sul subnetting, se un indirizzo ha più match scegliamo quello con la corrispondenza più lunga (maschera più grande/sottorete più piccola/etc).
Quindi potremmo aggiungere al gruppo la regola per l'indirizzo 158.111.4.0 senza intaccare le altre.

| Rete | Mask | Next hop |
| --- | --- | --- |
| 158.110.0.0 | 255.255.252.0 | 158.110.0.1 |
| 158.110.4.0 | 255.255.255.0 | 158.110.0.2 |

Quando arriva un messaggio per l'indirizzo 158.110.2.5, il match sarà solo con la prima regola e verrà indirizzato cverso 158.110.0.1.
Quando arriva un messaggio per 158.110.4.56 avrà un match con entrambe le regole, ma dato che la mascherà /24 è più grande della maschera /22, verrà selezionata la seconda regola, quindi indirizzato a 158.110.0.2

Nei router vecchi non è presente questa regola, si usa il first match. Il nome è self-explanatory, scorre in ordine e sceglie la prima regola con cui ha un match.
In questi router, per ottenere lo stesso risultato dovrei utilizzare esattamente la tabella 

| Rete | Mask | Next hop |
| --- | --- | --- |
| 158.110.4.0 | 255.255.255.0 | 158.110.0.2 |
| 158.110.0.0 | 255.255.252.0 | 158.110.0.1 |

In questa tabella, a contrario di quella vista prima, l'ordine delle regole conta, perché fa parte della decisione di routing.
Per ottenere lo stesso effetto del longest match bisogna ordinare le regole in base alla maschera di sottorete.

Sono pochi i router rimasti con first match, ora quasi tutti usano longest match.

## Indirizzi speciali (RFC 5735)

* 0.0.0.0/8 non indirizzabile, invalido. Si usa per indicare "un IP qualsiasi"
* 10.0.0.0/8 usato per reti private, non collegate a Internet (NAT)
* 172.16.0.0/12 usato per reti private, non collegate a Internet (NAT)
  * Normalmente partizionata in 16 sottoreti di classe B
* 192.168.0.0/16 usato per reti private, non collegate a Internet (NAT)
  * Normalmente partizionata in 256 sottoreti di classe C
* 127.0.0.0/8 Loopback (me stesso)
* 169.254.0.0/16 Indirizzi per l'autoconfigurazione quando non c'è DHCP (protocollo APIPA)
* 224.0.0.0/4 classe D. Indirizzi di multicast
* 240.0.0.0/4 classe E. Riservata per usi futuri (mai usate, in realtà)

## Protocolli Ancillary di IP

Protocolli ausiliari di IP

Non servono ad inviare dati tra gli host, servono a permettere al protocollo IP di farlo

### ARP

Address Resolution Protocol.
Quando inviamo un messaggio a qualcuno, il pacchetto IP viene incapsulato in un frame di livello 2. Questo frame ha bisogno di un indirizzo MAC per funzionare.
Il protocollo ARP è quello che permette di trovare questo MAC.

Il protocollo ARP ci fornisce il MAC del prossimo router che attraversiamo per arrivare a destinazione. Questo router decapsulerà il pacchetto e lo reincapsulerà in un nuovo frame con un nuovo MAC.
Per questo, il protocollo ARP gira solo su reti locali, non esce sulla rete globale.

Per fare questo ci serve una tabella che associa ogni IP ad un MAC di next hop.
Dato che gli IP cambiano continuamente, e si possono aggiungere e rimuovere dispositivi dalla rete, serve un protocollo che gestisca questa tabella automaticamente.
Anche perché alla stessa porta possono corrispondere più IP.

Il protocollo ARP invia dei pacchetti, con un indirizzo incapsulato, in broadcast sulla rete locale. Quando un dispositivo riconosce il suo indirizzo nel pacchetto, risponde.
Funziona solo su piccole reti, perché crea molto traffico con tutti i pacchetti broadcast che manda.
Il mittente del pacchetto segna sulla tabella chi ha risposto.

Si verificano 4 situazioni che risolviamo col protocollo ARP:
* L'host deve mandare un messaggio ad un host nella stessa rete.
  * Il pacchetto IP viene incapsulato in un frame con il MAC del fratello
* L'host deve mandare un messaggio ad una rete diversa
  * Il pacchetto viene incapsulato in un frame il MAC del grateway
* Un router deve mandare il messaggio ad un altro router della sottorete
  * Il pacchetto viene incapsulato in un frame il MAC del prossimo router
* Un gateway deve inviare il messaggio al destinatario finale
  * Il gateway è nella stessa rete del destinatario finale, ricade nel primo caso

Generaliziamo questi casi dicendo che ogni pacchetto IP viene incapsulato in un frame con il MAC del nexthop, che può essere un gateway, un router, o semplicemente il destinatario.
Prima non avevamo spiegato come viene inoltrato un messaggio da un router all'altro, ora sappiamo che si fa così.

Algoritmo:
* Controllo se ho l'indirizzo del nexthop sulla tabella
* Se lo ho, inoltro
* Altrimenti invio a tutti i nodi della rete locale (in broadcast, ma senza attraversare i router)
  * Viene invocato dal modulo IP quando non trova la entry nella tabella
* Tutti i nodi della rete locale ignorano, tranne quello con l'indirizzo richiesto che risponde in unicast
* Aggiungo la nuova entry nella tabella ARP
* Periodicamente le entry vengono droppate, per aggiornare le entry quando la rete cambia

È importante sapere che, nonostante gli esempi, funziona con qualsiasi tipo di indirizzi fisici e logici, non solo MAC e IP.
Per questo permette di specificare gli indirizzi hardware e logici che vogliamo.

Pacchetto ARP:
* 16b tipo di hardware
* 16b protocollo (IPv4, IPv6, etc)
* 8b lunghezza indirizo hardware (in byte, solitamente 6)
* 8b lunghezza indirizo logico (in byte, solitamente 4)
* 16b operazione (richiesta/risposta/etc)
* ?B indirizzo hardware sorgente
* ?B indirizzo logico sorgente
* ?B indirizzo hardware target (nelle richieste è 00:00:00:00:00:00)
* ?B indirizzo logico target

### Proxy ARP

È un host che rappresenta altri host, in genere una rete intera. Risponde con il suo MAC a richiesta ARP verso gli host "nascosti" che rappresenta.
Può essere usato per unire logicamente reti diverse, in genere si trovano tra sottoreti diverse della stessa rete.

Commutano i pacchetti tra le sottoreti come uno switch, ma cambiando gli indirizzi MAC.

Gli host non sanno di passare per un gateway, pensano di stare comunicando direttamente all'altro dispositivo.
Può essere usata in modo malevolo (ARP poisoning) per dirottare i messaggi.

### RARP

Lo accenniamo solo, non si usa.
Funziona al contrario di ARP, ogni host si "presenta" comunicando il suo IP in broadcast.

### Configurazione degli HOST

L'indirizzo MAC viene assegnato dal costruttore e non cambia. Ma l'indirizzo IP dipende da dove è collegato nella rete e da che altri dispoditivi sono collegati.

Non si possono avere host con lo stesso indirizzo sulla stessa rete. Quindi bisogna fare in modo che tutti sappiano quali indirizzi non sono disponibili.
RARP è utile per questo.

Un metodo è quello di configurare manualmente tutti gli host. Ma su reti grandi può essere troppo laborioso, inoltre introduce la possibilità di errori.

Quindi vogliamo un sistema automatico, ad esempio basato su RARP. Ora si ha la tendenza ad usare dei metodi centralizzati, come BOOTP (che non vedremo).

### DHCP

Dynamic Host Configuration Protocol

È un protocollo centralizzato che si occupa di fornire configurazioni agli host, rende altri sistemi come RARP e BOOTP obsoleti.

È centralizzato, quindi c'è un server (spesso è il gateway) sulla rete che si occupa di fornire tutte le informazioni ai dispositivi, non sono gli host a dover capire come configurarsi.

Quando un dispositivo si connette, invia un DHCPDISCOVER, un messaggio con destinazione 255.255.255.255 (broadcast limitato, i router non lo inoltrano) per trovare il server DHCP sulla rete. L'IP del mittente è irrilevante, ed il messaggio contiene il MAC mittente.
Se il server non è nella stessa rete il messaggio broadcast non lo raggiunge, quindi si utilizza un dispositivo detto DHCP relay (spesso è il gateway) che inoltra in unicast al server (usando l'IP), e successivamente inoltra la risposta al client (usando il MAC).

Se è presente un server DHCP, questo risponde in unicast con la configurazione del dispositivo.
La configurazione contiene un indirizzo ip, una subnet mask, due DNS predefiniti, ed un default gateway.

Il server è istruito per assegnare IP da un certo range; e tiene traccia di tutti gli IP che ha già assegnato per evitare di assegnare due volte lo stesso indirizzo.

Il protocollo DHCP non è di livello 3, è applicativo. L'inoltro da relay a server funziona con UDP.

Quando un client non riceve risposta dal DHCP. Sceglie un indirizzo a caso dal range 169.254.0.0/16 e spero che vada bene.

### ICMP

Internet Control Message Protocol.

Nato insieme ad IP. Da non confondere con IGMP.

È il protocollo di controllo e diagnostica della rete. Definisce un set di errori, notifiche e messaggi che sono inviati in risposta al mittente.

Messaggi:
* Un dispositivo non è in grado di processare il pacchetto:
  * Destinazione irraggiungibile per un problema di link/nodo
  * Ricomponimento fallito
  * Non può frammentare (flag Don't fragment)
  * Il TTL è arrivato a 0
  * Checksum dell'header fallito
    * Potrebbe arrivare all'host sbagliato
    * Magari è corrotto l'indirizzo
* Esiste una rotta migliore
  * Dal router al mittente (ICMP-redirect)

In ogni caso il messaggio viene sempre inviato solo al mittente del messaggio originale, non al destinatario.

La parte iniziale del diagramma rigettato è inclusa nel messaggio ICMP, per facilitare l'analisi. Di solito è un pezzo dell'intestazione di livello 4.
Quindi il messaggio ICMP incapsula l'intestazione ICMP, L'intestazione IP del messaggio incriminato ed I primi 8 byte del payload del messaggio incriminato, in un nuovo pacchetto IP.
Si appoggia al protocollo IP.

Può essere uno qualunque dei router intermedi ad inviare questo pacchetto di diagnostica, e viene sempre inviato verso l'ip mittente trovato nell'intestazione.

Fornisce anche alcune funzioni "a richiesta":
* Echo (ping): Ripete lo stesso messaggio inviato, si usa per verificare che sia raggiungibile un host
* Timestamp: Invia il timestamp di quando riceve il pacchetto, si usa per misurare il round trip time
* Address-mask: Scopre la maschera ed il router, sostiduito dal DHCP
* Router solicitation: Boh, non si usa

### ICMP-redirect

Un router riceve un datagram per una destinazione verso cui esiste una rotta migliore.

Il datagram è consegnato, ma si notifica il mittente che esiste la rotta migliore.

L'host dovrebbe aggiustare la sua tabella.

Come fa il router a sapere che c'è una strada migliore?
Nota che sia mittente che destinatario cadono nella stessa sottorete, quindi poteva essere inviato direttamete.

Non è un errore, è solo un avvertimento.

### Traceroute

Sfrutta il protocollo ICMP per trovare il percorso che un pacchetto segue per arrivare alla destinezione.

Questa è una cosa che normalmente non ci interessa, sia perché vogliamo che il percorso sia nascosto, sia perché i pacchetti potrebbero trovare strade diverse verso lo stesso host.
Quindi in realtà trova il percorso che un pacchetto attraverserebbe in questo momento, ma può cambiare nel tempo.

Utilizza il TTL ed i messaggi di errore di ICMP:
* Invio il pacchetto verso una destinazione ma con TTL=1
* Il primo router lo droppa e mi manda un errore, qua scopro l'indirizzo del router
* Invio un secondo pacchetto alla stessa destinazione ma con TTL=2
* ...

## NAT e reti private

L'idea è quella di creare un range di IP separati dal resto della rete. Usando gli IP privati per il routing interno, ed un router speciale per collegare LAN e WAN.

Questi IP privati non sono unici (possono essere usati da due macchine in reti private diverse), e sono scelti dai range di IP non routabili.

IP privati:
* 10.0.0.0/8
  * 10.0.0.1
  * 10.255.255.255
* 172.16.0.0/12
  * 172.16.0.1
  * 172.31.255.255
* 192.168.0.0/16
  * 192.168.0.1
  * 192.168.255.255

Questi IP non possono essere utilizzati nella rete globale. Perché non sono univoci, e lo standard non lo permette (sono dedicati a questo utilizzo).
Quindi non si può inviare un messaggio in rete usando questi indirizzi. Per comunicare attraverso la rete globale si deve usilizzare un dispositivo speciale.

Si usa la tecnica del NAT (Network Address Translation). Serve a permettere a macchine sotto rete privata di comunicare in rete globale. Attraverso una traduzione degli indirizzi dei pacchetti (e anche la porta, quando serve).
Ogni pacchetto che attraversa il router verso la rete globale viene analizzato, ed il suo indirizzo mittente viene sostituito da quello del router.
I pacchetti in risposta vedranno il loro indirizzo destinatario (che ora è quello del router) sostituito a sua volta da quello privato della macchina.
Per fare questo usa una tabella.

### Esempio

Arriva il messaggio `192.168.0.5:2345 -> 74.125.228.67:80` viene creata nella tabella la entry `192.168.0.5:2345=66.31.210.69:2345`, non serve cambiare la porta.

Il server riceve il messaggio `66.31.210.69:2345 -> 74.125.228.67:80` e risponde con il messaggio  `74.125.228.67:80 -> 66.31.210.69:2345`.

Il router riceve dalla rete pubblica il messaggio `74.125.228.67:80 -> 66.31.210.69:2345` e con la tabella traduce il messaggio in `74.125.228.67:80 -> 192.168.0.5:2345`, quindi arriva all'host.

Un altro host interno prova a connettersi allo stesso server, al router arriva il messaggio `192.168.0.8:2345 -> 74.125.228.67:80`. C'è un problema, la porta è la stessa, ed anche il destinatario, quindi deve tradurre anche la porta.
Crea la entry `192.168.0.8:2345=66.31.210.69:2346` (notare che la porta pubblica è diversa). Traduce il messaggio in `66.31.210.69:2346 -> 74.125.228.67:80`.

Il server riceve i messaggio `66.31.210.69:2346 -> 74.125.228.67:80` e `66.31.210.69:2345 -> 74.125.228.67:80`. E risponde con i messaggi `74.125.228.67:80 -> 66.31.210.69:2345` e `74.125.228.67:80 -> 66.31.210.69:2346`.

Il router riceve dalla rete esterna i messaggi `74.125.228.67:80 -> 66.31.210.69:2345` e `74.125.228.67:80 -> 66.31.210.69:2346`. E con le tabelle le traduce con `74.125.228.67:80 -> 192.168.0.5:2345` e `74.125.228.67:80 -> 192.168.0.8:2345`.

Quando smettono di arrivare messaggi, si rimuovono le entry inutilizzate (si usa un timer per ogni entry).

La tabella ha un aspetto tipo:
| Privato | Pubblico |
| --- | --- |
| 192.168.0.5:2345 | 66.31.210.69:2345 |
| 192.168.0.8:2345 | 66.31.210.69:2346 |
| ... | ... |

### Utilità del NAT

Il NAT ha diverse utilità:
* Aumentare il numero degli IP facendo multiplexing
  * Questo per gestire il problema degli indirizzi limitati
  * Se tutti i dispositivi avessro IP pubblici (come a UNIUD) finirebbero subito
  * Specialmente nelle reti WiFi e cellulare
* Facilitare la migrazione delle reti
  * Se si cambia gestore o si cambia range di indirizzi, con il nat si devono cambiare solo gli indirizzi al confine
  * Se si dovesse cambiare gli indirizzi di tutta la rete, sarebbe ingestibile per le reti grandi
* Load Balancing
  * Si può usare il NAT inverso per separare le richieste tra più macchine
  * Si fa per scaricare richieste a servizi diversi su più server
  * Si impostano delle entry statiche del NAT (deve essere fatto manualmente)
* "Firewall" naturale
  * Non è veramente un firewall e non è particolarmente sicuro
  * Supponiamo di avere un server HTTP gestito dalla regola `192.168.0.6:80=74.125.228.67:80`
    * Se qualcuno prova a connettersi a `74.125.228.67:80` arriva a destinazione, ma fa solo HTTP
    * Se qualcuno cerca di connettersi ad un servizio non gestito dalla regola come SSH usando `74.125.228.67:20` il NAT scarta la richiesta perché non c'è una regola
    * Se inizia una connessione dall'interno che crea quell'associazione, il malintenzionato entra comunque
  * Ovviamente, se voglio davvero rendere un servizio disponibile devo impostare le regole manualmente
    * È problematico su reti grandi

### Hole Punching

Problema: come facciamo a rendere possibile una connessione attraverso i NAT?

Si usano due applicazioni di livello 7 per "aprire buchi" nel NAT:
* STUN
  * Session Traversal Utilities for NAT
  * Si usa un server di terze parti per avere un echo del proprio IP (altrimenti non sappiamo con che IP usciamo oltre il NAT)
    * Il server STUN riceve il messaggio e risponde con un messaggio che contiene l'IP pubblico nel Payload
    * Il router non me lo dice, l'SNMP è solo per gli amministratori
    * Se ci sono NAT annidati non basta interrogare il mio gateway
  * Se le altre macchine sono esposte
    * Posso comunicare il mio indirizzo pubblico alle altre macchine e farle connettere
    * Quando ho fatto uscire il messaggio è stata agginta una entry al NAT
  * Se sono anche loro sotto NAT non funziona
* TURN
  * Trasversal Using Relays around NAT
  * Una macchina si connette al server TURN
    * Si aggiunge una entry alla tabella
  * Il server TURN somunica all'altra macchina (che a sua volta doveva essere connessa al server) IP e porta pubblici dell'altra macchina
  * L'altra macchina comunica ad IP e porta pubblici della prima
    * Si crea una entry nel NAT della seconda macchina per poter rispondere

Queste tecniche sono per popolare le tabelle, una volta pronte si può comunicare come si vuole.

### Dubbi sul NAT

* Ha problemi di performance e scalabilità
  * Bisogna mantenere gli stati
  * Modifica le intestazioni IP e TCP od UDP invalidando i checksum
    * Si possono ricalcolare
    * A volte si rimuovono per prestazioni
  * Crea il traffico aggiuntivo di STUN e TURN
* Rompe l'astrazione
  * Lavora sia a livello 3 che livello 4 (modifica IP e porta)
  * È un male necessario
* Rompe la connettività end-to-end
* Non è un vero firewall

## IPv6 (IP NextGen)

Gli IP sono finiti. Nel 25 novembre del 2019 il RIPE ha assegnato l'ultima rete di classe /22, nel 2012 avevano assegnato l'ultima di calsse /8.

Ora tutto gira sotto NAT (tranne UNIUD) per questo. L'alternativa migliore è usare IPv6, la nuova versione di IP, incompatibile con la precedente.

Caratteristiche di IPv6:
* Indirizzi a 128 bit
  * $2^{128}\simeq3*10^{38}$ indirizzi (sono tanti tanti 340 miliardi di miliardi di miliardi di miliardi)
  * Se li distribuissimo su tutta la superfice della terra ci sarebbero $0.58*10^{18}$ indirizzi per millimetro quadrato
* Supporta il Multicast nativamente
* Supporta servizi real-time
* Tutti i dispositivi IPv6 devono implementare dei protocolli di autenticazione e cifratura (non ad usarli)
* Possono essere autoconfigurati
* Frammentazione end-to-end
* Funzionalità di routing migliorata
  * Supporto per host mobili (che mantengono l'IP quando si spostano)
  * Routing su base geografica
* Estendibile (è modulare)

### Indirizzi IPv6

Si usa la notazione CIDR tipo indirizzo/maschera.
Si scrivono come 8 numeri esadecimali da 4 cifre separati da : e gli 0 contigui si indicano con :: (esempio 437f::89ab:ef43)
Si può indirizzare IPv4 in una rete IPv6, ma non viceversa, gli ultimi 32bit di un indirizzo v6 sono un v4, quindi ::159.110.15.60

Sono assegnati da un provider gerarchicamente come gli IPv4, e sono organizzati in base geografica.
Generalmente un utente si prende una rete /48 o /64.

L'intestazione è molto più semplice, perché è modulare.

Intestazione:
* 4b Versione
* 8b TraficClass
* 20b FlowLabel (serve per il real-time)
* 16b PayloadLen
* 8b NextHeader
  * Indica il tipo di prossimo header, che viene concatenato a quello base
  * Posso aggiungerne diversi a seconda dei servizi che voglio
    * Frammentazione
    * Source routing
    * Autenticazione e sicurezza
    * ...
  * Si possono aggiungere altri servizi in futuro perché è modulare
* 8b HopLimit (TTL)
* 128b Mittente
* 128b Destinatario
* ?B NextHeader/data

### Priority

La traffic class definisce la priorità del datagramma nel rispetto degli altri:
* 0 traffico generico
* 1 traffico di background
* 2 traffico senza attesa
* 3 e 5 riservati
* 4 traffico con attesa
* 6 traffico interattivo
* 7 traffico di controllo
* 8-15 indipendente da congestione (non droppare)

### FlowLabel

È un numero random a 20 bit assegnato dalla sorgente. I datagrammi dello stesso flusso sono etichettati con lo stesso valore.
I router possono decidere di utilizzare questo valore per fornire servizi coerenti ai datagrammi dello stesso flusso.

Ad esempio:
* Usare la stessa rotta
  * Creando una sorta di comunicazione a circuito
* Qualità di servizio
  * Riservare risorse ai flussi
  * Utile per servizi real-time
  * Prima servivano protocolli diversi (RSVP)

### Transizione da IPv4 a IPv6

Il problema è che IPv6 non è usato. Questo perché non sono compatibili i protocollo.
La cosa da fare sarebbe rimpiazzare tutti gli IPv4 con IPv6, ma è difficile perché non puoi costringere gli altri a farlo, anche perché ci sono miliardi di host che funzionano ancora. Basti pensare che la transizione doveva essere completa 20 anni fa.
Serve un modo per farle coesistere.

Si utilizzano delle macchine dual-stack, quindi che supporta contemporaneamente IPv4 ed IPv6.

Quando si comunica in rete bisogna specificare il tipo di indirizzo da usare ed idealmente usare v6 come default e v4 come fallback.

### Tunneling

Come facciamo se dobbiamo far comunicare due host che usano v6, attraverso una rete che usa v4? Col tunneling.

Si incapsula payload ed intestazione v6 in un pacchetto v4 (perdendo i vantaggi di v6), si invia il v4 ad un router intermedio che conosce v6, che lo decapsulerà e lo rimetterà in rete come pacchetto v6.
Mittente e destinatario v6 sono i due host, mentre quelli sull'intestazione v4 sono i due router ai confini della regione v4.

I router di confine devono conoscersi tra di loro per sapere come attraversare la regione.

### Traduzione dell'intestazione

Come faccio comunicare una macchina v6 ad una v4? Direttamente non posso, ma utilizziamo un meccanismo di traduzione.

Un router di destinazione prenderà l'header v6 e lo sostituirà con un intestazione v4 per l'ultimo tratto. In modo simile al NAT.

Se usassimo tutti IPv6 non servirebbe il NAT, tanto tutti potrebbero avere una rete /48 senza problemi.

In Finlandia o in qualche stato scandinavo (il professore non ricorda) assegnano una rete /48 personale ad ogni neonato.
