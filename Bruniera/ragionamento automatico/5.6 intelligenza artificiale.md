# Intelligenza artificiale

## Automazione dei sillogismi

Inventata da Aristotele in "analitici primi" e include: la nozione di variabile, gli assiomi di identità $A=A$ e di non contraddizione $A\neq\lnot A$. Inventa alcuni sistemi di inferenza logica tipo "Se tutti gli uomini sono mortali, e Socrate è un uomo, allora Socrate è mortale".

Ramon Llull sviluppa la prima macchina per l'inferenza automatica di sillogismi (~1200). La sua macchina era basata su un sistema di dischi di carta ed anelli. La macchina non era descritta in modo preciso, ma abbiamo delle ricostruzioni.

Leibniz inventa la macchina moltiplicativa, estendendo la pascalina che faceva solo somme. Lui voleva una macchina per fare tutte le computazioni di base ed inferenze, così che gli umani potessero concentrarsi sulle parti difficili.

Boole inventa il calcolo booleano, un metodo matematico per risolvere problemi di logica come se fossero formule aritmetiche. Nel suo sistema $\land$ è rappresentato dalla moltiplicazione, quindi gli serviva che nel suo sistema $A\cdot A=A$, questo non è vero per qualsiasi numero, ma se ammettiamo solo 0 ed 1 sì.
In questo sistema codifica e dimostra tutte le operazioni di base $\land\lor\lnot\rightarrow$ ed alcune leggi (ad esempio quelle di De Morgan). Dimostra anche il sillogismo di Aristotele.

Frege espande il lavoro di Boole con i quantificatori esistenziali ed universali, e inventa la logica del primo ordine. Scrive un libro in due volumi in cui assiomatizza i principi dell'aritmetica usando gli insiemi e la logica del primo ordine, un lavoro enorme ed importante, Frege voleva fondare le basi di tutta la matematica.
Mentre il secondo volume era in stampa arriva una lettera di un lettore: William Russel.

La lettera di Russel propone un paradosso. Definiamo come *straordinario* un insieme che contiene se stesso ed *ordinario* uno che non lo fa. Supponiamo che $S$ sia l'insieme di tutti gli insiemi ordinari, se $S$ fosse ordinario, sarebbe contenuto in $S$ ma questo lo renderebbe straordinario, viceversa se fosse straordinario vorrebbe dire che contiene se stesso ma gli insiemi contenuti in $S$ sono ordinari.
L'insieme $S$ non può esistere e questo paradosso invalidava l'intero lavoro di Frege (o quanto meno non poteva più fondare tutta la matematica).
Frege include la lettera nel secondo volume.

Kurt Gödel, basandosi sulle idee di Frege e Russel dimostra che un sistema formale abbastanza espressivo da contenere l'aritmetica, permette di scrivere un'espressione di cui ne l'espressione stessa ne il suo inverso può essere dimostrato, un'espressione indecidibile.
Dimostra anche che un sistema in cui tutte le espressioni sono decidibili non è completo e non può esprimere tutta l'aritmetica.

Turing inventa una macchina formale per decidere tutto quello che è decidibile, ovviamente è soggetto ad una variante del problema della decisione (problema della terminazione) ma non si può fare niente, il suo sistema è completo.

## Programmazione logica

Nasce da dei lavori del 1969 sul theorem proving e sul problem solving.
In particolare, Hewitt inventa un sistema di problem solving (chiamato "planning"), è un sistema basato sulla logica del primo ordine, ma ha un modello pessimo ed estremamente lento.
Non sapevano che il problema che volevano risolvere era PSPACE-completo quindi non c'è modo di renderlo efficiente.\
Successivamente nel 1972 nasce prolog (vera nascita della programmazione logica).

Prolog permette di esprimere facilmente predicati del primo ordine in un linguaggio di programmazione dichiarativo.

```prolog
human(X) :- mortal(X).
human(socrate).
?- mortal(socrate).
?- yes.
?- mortal(Y).
?- Y=socrate;
no
```

La prima implementazione efficiente di prolog è del 1983, basata su una macchia astratta di Warren. Dopo hanno seguito molte altre implementazioni.

In prolog si possono scrivere problemi indecidibili, è Turing-Completo.

Prolog ha una serie di semantiche interessanti che sono "facili" da dimostrare.

Prolog permette di rappresentare ragionamento non monotonico (ragionamento con eccezioni).

## Syntax of logic programming

Abbiamo alcuni set di simboli
* $C$ delle costanti
  * `a`, `b`, `socrate`, `uomo`, `42`
  * Possono essere infiniti
  * Tipicamente con la minuscola
* $V$ delle variabili
  * `X`, `Y`, `X1`, `X2`
  * Tipicamente con la maiuscola
* $F$ delle funzioni
  * `f`, `g`, `h`, `sqrt`
  * Ogni simbolo $f\in F$ ha un'arietà $ar(f)\geq0$
* $P$ dei predicati
  * `p`, `q`, `genitore`,  `eq`, `leq`
  * Ogni simbolo $p\in P$ ha un'arietà $ar(p)\geq0$

Termini:
* Definizione:
  * Se $c\in C$ `c` è un termine
  * Se $x\in V$ `x` è un termine
  * Se $f\in F$ ha arietà $ar(f)=n$ e `t1,...,tn` sono termini, `f(t1,...,tn)` è un termine
* Un termine senza variabili è un *ground* term (termine chiuso)
* Un termine è un albero dove le etichette di ogni nodo sono sottotermini del termine radice

Formule:
* Formule atomiche:
  * Definizione
    * Se $p\in P$ ha arietà $ar(p)=n$ e `t1,...,tn` sono termini, `p(t1,...,tn)` è una *formula atomica* od un *atomo*
  * Ha un solo caso, non c'è ricorsione
* Letterali:
  * Definizione:
    * Se `A` è un atomo `A` è un letterale
    * Se `A` è un atomo `not A` è un letterale
  * Anche qua no ricorsione, però due casi

I programmi sono set di regole, alla fine di ogni regola si mette un punto.

Regole:
* Definizione:
  * Se `H` è un atomo e `B1,...,Bn` sono letterali, `H :- B1,...,Bn` è una regola
  * Se `B1,...,Bn` sono letterali, `:- B1,...,Bn` è una regola *denial* o vincolo
* Se `H :- B1,...,Bn` è una regola e `B1,...,Bn` non contengono letterali, la regola è un *fatto*
* Un denial è una formula che non deve verificarsi
* Una regola `H :- B1,...,Ba,not Bb,...,not Bn` (dove i `Bi` sono atomi, non letterali) equivale a:
  * $H\leftarrow B_1\land...\land B_a\land\lnot B_b\land...\land\lnot B_n$
  * $H\lor\lnot B_1\lor...\lor \lnot B_a\lor Bb\lor...\lor B_n$
* Una regola può essere vista come una disgiunzione di letterali, quindi è una *clause* (clausola)

Cerchiamo di definire un predicato con delle regole. Sia il programma `grandparent(X,Y) :- parent(X,Z), parent(Z,Y).`, ci sono due modi equivalenti di vedere questa regola:
* Dati `X` ed `Y`, se esiste `Z` tale che `parent(X,Z), parent(Z,Y)` allora `grandparent(X,Y)`
* Dati `X`, `Y` e `Z`, se vale `parent(X,Z), parent(Z,Y)` allora `grandparent(X,Y)`

Possiamo definire predicati ricorsivi:
```prolog
ancestor(X,Y) :- parent(X,Y).
ancestor(X,Y) :- parent(X,Z), ancestor(Z,Y)
```

Proviamo a definire `married` e `sibling`
```prolog
married(X,Y) :- parent(X,Z), parent(Y,Z).
sibling(X,Y) :- parent(Z,X), parent(Z,Y).
```

Sembra corretta, ma non va bene. Potresti essere sposato con te stesso e fratello di te stesso. Per correggere bisogna forzare che `X` ed `Y` siano diversi (come esercizio definiamo anche `eq`, ma è già build in).
```prolog
married(X,Y) :- parent(X,Z), parent(Y,Z), X \= Y.
sibling(X,Y) :- parent(Z,X), parent(Z,Y), not eq(X,Y).

eq(X,X).
```

Proviamo ad implementare l'aritmetica di base:
```prolog
nat(0).
nat(s(X)) :- nat(x).

plus(X,0,X).
plus(X,S(Y),S(Z)) :- plus(X,Y,Z).

minus(0,X,0).
minus(X,X,0).
minus(s(X),Y,s(Z)) :- minus(X,Y,Z)
```

Ci sono le liste, come quelle dei linguaggi funzionali:
```prolog
[A,B,C] :- [A|[B|[C]]].
```