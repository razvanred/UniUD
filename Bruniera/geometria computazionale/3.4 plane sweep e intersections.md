# Plane sweep per identificare punti di intersezione tra segmenti

## Plane sweep

Un approccio in cui tentiamo di identificare delle proprietà geometriche immaginango di spazzare il piano con una retta. Spostiamo una retta da sinistra a destra (o viceversa) chiedendoci cosa vede la retta.

Per sua natura è strettamente legataa problemi sul piano. La introdurremo come tecnica per identificare le intersezioni tra segmenti.

Elementi del plane sweep:
* Sweep line:
  * Una retta verticale (convenzionalmente)
  * Spazza il piano da sinistra a destra (convenzionalmente) parallelamente a se stessa
  * Teniamo traccia di quello che la retta "vede" del problema e come cambia
  * A sinistra della retta il lavoro è completato
  * A destra stiamo ancora la vorando
* Events:
  * Sono le posizioni di questa retta in cui occorrono dei "cambiamenti sostanziali"
  * Per "cambiamenti sostanziali" cambiamenti rilevanti per il problema
  * Cambiamenti riguardanti la topologia del piano
  * Quello che la retta vede è quello che si trova tra la retta stessa ed uno degli eventi significativi precedenti

## Problema dei punti di intersezione (line segment insersection)

* Siano un set $S$ di $n$ segmenti su un piano
* Trovare tutti i punti di ntersezione tra i segmenti in $S$
  * Per ora supponiamo che non ci siano punti di intersezione di 3 segmenti ne estremi in comune tra segmenti
* È banale risolverlo in $\theta(n^2)$ nel caso peggiore
  * Si ordinano i segmenti in base al vertice più a destra
  * Si confronta ogni segmento con tutti i precedenti
  * Ci sono casi in cui questa è l'unica soluzione:
    * Metà dei segmenti interseca l'altra metà dei segmenti
      * Abbiamo $(\frac n2)^2$ punti e dobbiamo visitarli tutti
    * Se queste situazioni fossero comuni, avrebbe senso usare sempre l'algoritmo banale, ma non è così
* Ci interessano algoritmi che siano "proporzionati" alla dimensione dell'output

Prima idea:
* Due segmenti possono intersecarsi solo se le loro intersezioni sull'asse $x$ si sovrappongono
* La retta di spazzamento vede i segmenti che interseca (le cui proiezioni si sovrappongono)
* Se ci interessa solo sapere quali segmenti interseca (ed è così) gli eventi corrispondono a quando incontra gli estremi
  * Quando incontra l'estremo a sinistra vede un segmento in più (ENTER)
  * Quando incontra l'estremo a destra vede un segmento in meno (EXIT)
* Abbiamo una descrizione di un algoritmo rudimentale
  * Agli eventi ENTER controlliamo l'intersezione tra il nuovo segmento e quelli incrociati
  * In entrambi i casi aggiorno la lista aggiungendo o rimuovento i segmenti
* Ordinare gli estremi inizialmente costa $O(n\log n)$
* Comunque, il caso peggiore è sempre $O(n^2)$
  * Sappiamo che a volte è inevitabile
  * Qua succede anche se non è inevitabile (ad esempio quando abbiamo tutte linee parallele inclinate, ragionateci sopra)
  * Molto male

Seconda idea:
* Al passaggio $k$, sia $L_k$ l'insieme di punti in cui la linea incroca i segmenti
* Perché due segmenti si intersechino serve che ad un certo passaggio (prima dell'intersezione) siano adiacenti nell'insieme
* Shanoms & Hoey propongono un algoritmo per scoprire se esistono segmenti che si intersecano in $S$
  * Non trova i punti di intersezione
  * L'ordinamento dei segmenti in $S$ costa $O(n\log n)$
  * Creiamo un albero di ricerca bilanciato vuoto $S_k$ (per abbassare la complessità)
    * Gli eventi ENTER aggiungono il segmento $s\in S$ ad $S_k$
    * Gli eventi EXIT rimuovono il segmento 
    * Costo delle singole operazioni $O(\log n)$
  * Come troviamo le adiacenze?
    * Quando inseriamo il segmento $s$ troviamo i due segmenti ($u,v$) tra cui viene inserito
      * Controllo se interseca i due
    * Quando rimuoviamo il segmento $s$ diventano adiacenti i due segmenti ($u,v$) tra cui si interponeva
      * Controllo se $u$ e $v$ si intersecano
      * Non sono necessariamente gli stessi di prima (che sarebbero già stati testati)
  * Costo complessivo $O(n\log n)$
    * Ordinamento +
    * Al più $n$ eventi
      * Ciascun evento causa una quantità limitata da costante di operazioni su albero $O(\log n)$
* Questa soluzione è ottimale nel caso peggiore, quindi diventa un lower bound per il test di intersezione
  * Il problema di element uniqueness può essere ridotto a questo test di intersezione
    * Vedi Dobkin & Lipton 1975, 1979
    * Sia una sequenza $X$ di numeri di cui vogliamo testare l'unicità
    * Per ogni numero $X_i$ inseriamo un segmento $(x_i-i,-i)(x_i+i,+i)$ in cui $i$ è l'indice
      * L'indice rende i segmenti tutti diversi tra di loro
    * Se due $x_i$ e $x_j$ sono uguali, i segmenti hanno una sovrapposizione
  * Il test di intersezione si può ridurre al problema dei punti di intersezione
