# Convex Hull

Si tratta di uno dei problemi classici della geometria computazionale. È facile da formulare, e anche da risolvere in modo efficiente (una delle soluzioni in particolare). Vi si possono applicare diversi approcci tipici dei provlemi di gc.

Vedremo tre soluzioni del problema: un algoritmo incrementale, uno divide et impera, ed uno randomizzato

Problema: Dato un set $P$ di punti sul piano, determinare la più piccola regione convessa che li contiene tutti.

Questa regione è un poligono convesso nel piano. Su spazi a più di due dimensioni diventa un poliedro (e diventa molto più complicato).

Definizione operativa:
* convex hull $=\bigcap\{C:P\subset C\}$, $C$ regione convessa
  * Intersezione di *tutte* le regioni convesse che contengono i punti $P$
  * Troppo generale, ci sono troppi piani da considerare
* convex hull $=\bigcap\{H:P\subset H\}$, $H$ semipiano
  * Consideriamo solo i semipiani
  * Sono facili da caratterizzare perché è sufficiente la retta che li determina e la parte della retta su cui si trova il piano
* convex hull $=\bigcap\{H_{pq}:p,q\in P\land P\subset H_{pq}\}$
  * Basta considerare i semipiani che contengono sulla retta due punti di $P$ e tutti i punti al loro interno
  * Molto più semplice computazionalmente perché i semipiani che soddisfano queste regole sono finiti
* Consideriamo $pq$ un segmento orientato con il semipiano alla sua sinistra
  * MOLTO facile da caratterizzare, bastano i due punti $p$ e $q$ ordinati
* Il set di semipiani è finito (Hurray!!!!!) e minimale (HURRAY!!!!!)

## Passiamo dalla definizione operazionale all'algoritmo brute

Un segmento $pq$ è un lato del convex hull *se e solo se* tutti gli altri punti di $P$ sono alla siniztra di $pq$

Usiamo la funzione `CGAL::left_turn(p1,p2,q)` per sapere se un punto si trova a sinistra di una retta, vediamo il codice:
```cpp
bool liesToTheLeftOf(Point q, Point p1, Point p2) {
  return CGAL::left_turn(p1,p2,q);
  // La primitiva della libreria traccia la spezzata che passa per i tre punti
  // e valuta se gira verso sinistra
}

void naiveConvexHull(PointVector &points, SegmentVector &edges) {
  int n = point.size();

  edges.clear();

  for(int i=0; i<n; i++) {
    for(int j=0; j<n; j++) {
      bool candidate = true; // Il candidato è il segmento pi-pj

      for(int k=0; candidate && (k<n); k++) {
        if((k != i) && (k != j)) {
          candidate = liesToTheLeftOf(points[k], points[i], points[j]);
          // Sul flag candidate indica se trova un punto che invalida il segmento
        }
      }

      if(candidate) {
        edges.push_back(Segment(points[i], points[j]));
        // Se non è stato trovato nessun punto invalidante, il segmento è parte del poligono
      }
    }
  }
}
```

Nota: le prossime volte cercherò di evitare di copiare tutti gli algoritmi se non necessario

L'algoritmo è molto banale, non solo è lento, ma ha un problema grave: se almeno tre punti sono allineati, tutti i segmenti tra questi punti hanno almeno un punto che non è alla loro sinistra, ovvero quello sulla stessa retta.
Non trova i lati che sono allineati ad altri lati. Non ce ne saremmo mai accorti con punti casuali perché non sarebbero mai capitati punti allineati, da un punto di vista puramente probabilistico è 0, e anche se fossero allineati sarebbe un problema solo se fossero sul bordo.
Siamo stati troppo superficiali, dire che sta alla sinistra del segnemento non è sufficiente per dire che appartengono al semipiano.

## Casi degeneri e prestazioni

L'algoritmo non è robusto. Serve un analisi più dettagliata. Però va bene iniziare affrontando il problema ignorando i casi degeneri.
Ora come ci occupiamo dei punti colineari? E come ci occupiamo di piccole perturbazioni (limiti dei float)?

Ci serve un modo per rappresentare l'output (non solo i lati messi a casaccio in un vettore). Dobbiamo anche decidere quali sono i lati che vorremmo tenere nel caso dei punti allineati.

Non c'è una unica risposta giusta, della seconda decisione ci sono almeno due soluzioni sensate:
* Mantenere tutti i segmenti tra punti "adiacenti"
* Collegare direttamente i due estremi dei due segmenti allineati
  * Probabilmente questa è quella più comoda perché ci permette di creare un nuovo vertice solo quando abbiamo un cambio di direzione
  * Scegliamo questa

Utilizziamo la primitiva `CGAL::are_strictly_ordered_along_line(p1, q, p2);` che verifica se i punti passati come argomento sono allineati nell'ordine in cui sono passati.

```cpp
bool liesToTheLeftOf(Point q, Point p1, Point p2) {
  return CGAL::left_turn(p1,p2,q) || CGAL::are_strictly_ordered_along_line(p1, q, p2);
  // Se gira verso sinistra o se sono allineati con q a metà tra i due il lato è valido
}
```

Adesso il nostro algoritmo trova tutti i vertici e soli che cercavamo, quindi anche quelli in cui i punti sono allineati, e senza spezzare segmenti che non cambiano direzione.

Occupiamoci dell'altra parte del problema: vogliamo rappresentare il nostro poligono in modo ragionevole.

Scegliamo di rappresentare il poligono come elenco ordinato dei vertici in senso antiorario. Ora abbiamo anche le informazioni topologiche sul poligono, non solo i segmenti di cui è composto.
Notiamo che con questo problema i problemi di integrità strutturale che vengono introdotti sono estremamente limitati: non abbiamo nuove informazioni geometriche, solo relazionali, nel senso che i punti sono sempre gli stessi, non dobbiamo acalcolare altre misure che potrebbero essere errate.

Il primo algoritmo semplici consiste nel calcolare il solito insieme di segmenti e con un altro algoritmo di forza bruta trovare i segmenti con vertici che coincidono (non lo vediamo perché è stupido). Questa soluzione avrebbe complessità cubica per trovare i lati, e quadratica per trovare i punti coincidenti.

Possiamo migliorare l'algoritmo mantenendoci allineati sul bordo del poligono. Bisogna scegliere un punto di partenza che sappiamo essere parte del poligono, come facciamo? Il punto più in alto ha sicuramente tutti sotto, e se sono allineati, in alto, basta scegliere quello più a sinistra di quelli più in alto (ordinamento lessicografico).
Questo (chiamato Jarvis' March, marcia di Jarvis) è il primo algoritmo presentato, da Jarvis nel 1973.

```cpp
bool before(Point p, Point q) {
  return CGAL::lexicographically_xy_smaller(p,q);
}

int naiveConvexHull(PointVector &points, PointVector &hull) {
  int n = point.size();

  hull.clear();

  int leftmost = 0;
  for(int i=1; i<n; i++) {
      if(before(points[i], points[leftmost])) {
      leftmost = i;
    }
  }
  int k = leftmost;
  // Troviamo il punto più in alto a sinistra (come una ricerca del minimo)

  do {
    hull.push_back(points[k]);
    // Inizio inserendo il punto precedente (che so essere nel convex hull) nell'elenco

    int j = (l + 1) % n;
    // Seleziono il prossimo punto nel vettore

    for(int i=(j+1)%n; i!=k; i=(i+1)%n) {
      // Provo se tutti i punti successivi sono a sinistra
      if(liesToTheLeftOf(points[j], points[k], points[i])) {
        // Verifico se i è a destra di kj (quindi se j è alla sinistra di ki)
        // se lo è, tutti i punti già controllati sono anche a sinistra di ki e i è il nuovo candidato
        j = i;
      }
    }
  } while(k != leftmost);
  // Mi fermo quando sono tornato a k
  // Le iterazioni del do-while sono tante quanto i lati, quelle dei cicli interni sono n

  return hull.size();
}
```

Questo algoritmo è molto migliore, perchè ha complessità $O(hn)$ dove $h$ è il numero di lati. Nel caso peggiore ha complessità quadratica, quando il numero di vertici è il numero dei lati, è ancora molto lento, ma comunque molto migliore. Si può ancora migliorare molto? Non si sa.

Questa volta l'output è ordinato comevogliamo senza doverlo riprocessare.

Lower Bound:
* Consideriamo l'insieme di punti $P=\{(x_i,x^2_i):1\leq i\leq n\land x_i\in\R\}$
  * Sono dei punti che si trovano tutti su un arco di parabola
  * L'algoritmo di Convex Hull risolve il problema dell'ordinamento delle x
* Quindi se posso trasformare un ordinamento in un problema di CH non posso risolvere CH più velocemente di un ordinamento
  * Questo non dimostra che posso risolvere CH in $O(n\log n)$, dimostra solo che non potrò mai fare di meglio
* Se sapessimo che $h=O(\log n)$, questo algoritmo diventa già molto efficiente
  * Ovviamente diventa dalla distribuzioni di punti
  * Altri studenti hanno scritto degli articoli su questo argomento (migliorare l'efficienza avendo delle ipotesi sulla distribuzione)
  * Se $h=O(\sqrt{n})$ allora possiamo eseguire Jarvis' March in $O(\sqrt{n}\times\sqrt{n})=O(n)$
    * Non possiamo fare meglio di così con punti randomici perché dovremmo poter trovare CH senza nemmeno conoscere tutti i punti
