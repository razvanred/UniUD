# Gestione della memoria

## Uso della memoria ram

Nell'suo uso tipico, il codice ARM (vale anche per altri assembly, con alcune modifiche) prevede una divisione della memoria in intervalli consecutivi:
* 0 - oxfff: riesevata al sistema operativo
  * Se provate a leggere o scrivere da quà da errore
* 0x1000 - ww: codice del programma (.text)
  * Contiene il codice macchina del programma
  * Da quà si può solo leggere (dipende dalla macchina)
* ww - xx: costanti + variabili del programma principale (.data)
* xx - yy: heap per dati dinamici
* yy - zz: stack per chiamate di procedura, stack di attivazione

In più, sono utilizzati anche due registri:
* `r13`/`sp`: Stack pointer, punta alla cima dello stack
* `r11`/`fp`: Frame pointer, punta all'inizio del frame della procedura in esecuzione

Esistono tre metodi di allocazione della memoria:
* Allocazione statica: allocata in tempo di compilazione (compiletime)
  * Sono la parte di memoria che contiene lo stesso dato durante tutta l'esecuzione
  * È allocata in fase di compilazione, ed in fase di caricamento del programma viene caricata
* Allocazione dinamica: allocata a tempo di esecuzione (runtime), si divide in:
  * Stack: oggetti allocati con politica LIFO
    * Ogni procedura alloca una sua porzione di stack
    * Le procedure vengono terminate in ordine inverso, svuotando lo stack dall'ultimo oggetto inserito
  * Heap: oggetti allocati e deallocati liberamente
    * Altri dati che possono essere allocati e deallocati da qualsiasi punto del codice

Un programma, normalmente, utilizza tutti e tre i meccanismi.

## Allocazione statica

Gli oggetti in memoria statica hanno indirizzo assoluto, che viene mantenuto per tutta la durata dell'esecuzione. Anche se l'indirizzo specifico può (dipende da diversi fattori) variare tra un'esecuzione e l'altra.

Viene utilizzata per:
* Variabili globali
* Costanti note a compiletime
* Tabelle utilizzate dal supporto a runtime, per realizzare meccanismi come:
  * Type checking
  * Garbage collection
  * Esecuzione asincrona
  * ...

Alcuni linguaggi antichi (come FORTRAN) utilizzano solo allocaizione statica.

Vantaggi:
* Facile da implementare
  * Basta riservare uno spazio nel segmento .data
* Veloce
  * Basta sostituire i riferimenti con l'indirizzo in fase di compilazione
  * Tutti i dati sono nello stesso posto, agevolando la cache

Svantaggi:
* A compiletime devo allocate *tutta* la memoria necessaria per *tutti* gli oggetti che userà mai il programma
* Non permette ricorsione (che richiede una struttura LIFO)

## Stack di attivazione

Ogni istanza di procedura in esecuzione possiede un record di attivazione (o frame) per contenere:
* Variabili locali
* Parametri
* Indirizzo di ritorno
* Link dinamico (alla procedura chiamante)
* Link statico (alla procedura genitore, quando si usano funzioni annidate)
* Risultati intermedi
* Backup dei registri

Escluse le variabili locali ed i parametri, questi dati non sono visibili nei linguaggi di programmazione ad alto livello (sono visibili a livello di assembly).

Questi frame vengono impilati nello stack nell'ordine in cui sono chiamate le procedure e le funzioni. Ogni volta che una funzione termina, rimuove il suo frame dalla pila di attivazione.
Possono essere utilizzate quasi allo stesso modo per i blocchi anonimi. La differenza è che per questi non è necessario l'indirizzo di ritorno.

Servono a gestire le chiamate a procedura od i blocchi. Sono organizzati a record e contengono tutte le informazioni necessarie all'esecuzione della procedura.
Lo stack cresce (verso il basso) con le chiamate a procedura, e contiene i record di attivazione di tutte le procedure chiamate finora.

Sono necessarie alcune informazioni per gestirlo, generalmente memorizzate in due registri del processore:
* Frame pointer: contiene il puntatore all'inizio del record di attivazione
  * Viene utilizzato per accedere alle variabili della funzione
* Stack pointer: contiene il puntatore alla prima casella libera sullo stack
  * Viene utilizzato per eventuali altri inserimenti nello stack

Il record di attivazione conterrà anche il frame pointer precedente (link dinamico), mentre lo stack pointer è il frame pointer della procedura attuale.

### Esecuzione di blocchi anonimi

```c
{
  int x = 0;
  int y = x + 1;
  {
    int z = (x + y) * (x - y);
  };
};
```
Processo di chiamata della procedura:
* Push di record con spazio per x ed y
* Setta i valori di x ed y
  * Push del record del blocco interno, con spazio per z ed eventualmente risultati intermedi
  * Setta il valore di z
  * Pop del record del blocco interno
* Pop del record del blocco esterno

Le operazioni di push causano l'aggiornamento dei frame pointe, stack pointer e link dinamico:
* Push:
  * Link dinamico diventa frame pointer
  * Frame pointer diventa stack pointer
  * E lo stack pointer diventa il nuovo stack pointer
* Pop:
  * Lo stack pointer diventa frame pointer
  * Frame pointer diventa link dinamico
  * Link dinamico torna il link trovato nel record precedente

Nelle implementazioni reali si sceglie di non utilizzare record di attivazione per ogni blocco, ma di alloracare (alla chiamata della procedura) abbastanza memoria per tutti i blocchi anonimi nella procedura.
Viene sprecata memoria, ma si gaudagna in velocità.

### Chiamata a procedura

```c
int fact(int n) { //fattoriale
  if(n <= 1) return 1;
  else return n * fact(n - 1);
}
```

Il record contiene:
* Parametri in ingresso
* Parametri in uscita (risultato)
* Link statici, dinamici, ed indirizzo di ritorno, backup dei registri

Questa procedura causa la creazione di n record di attivazione

processo:
* Push n
* Push valore di ritorno
* Salto
  * Push di spazio per valori intermedi
  * Push n-1
  * Push di valore di ritorno
    * ... ripeti n volte
    * Carica 1 nel parametro in uscita
    * pop
    * ...
  * Trovo il risultato di `fact(n - 1)` nel parametro in uscita
  * Carica il risultato nel parametro in uscita
  * Pop
* Trovo il risultato di `fact(n)` nel parametro in uscita

Nel caso della chiamata a funzioni o procedure non è possibile fare a meno dello stack di attivazione (a contrario del caso dei blocchi).

La gestione dello stack avviene in 4 fasi, alcune eseguite dal chiamante ed altre dal chiamato:
* Sequenza di chiamata
  * Dal chiamante
* Prologo
  * Dal chiamato
* Epilogo
  * Dal chiamante
* Sequenza di ritorno
  * Dal chiamato

Sono necessarie tutte e quattro, ed è necessario che alcune operazioni (come il salto al codice della procedura) avvengano in una delle fasi nello specifico (in questo caso nella sequenza di chiamata).
Altre operazioni (come il backup dei registri) possono essere eseguite indipendentemente in fasi diverse (in questo caso nella sequenza di chiamata o nel prologo).
Quando possibile si cerca di fare in modo che vengano eseguite dal chiamato, perché così si riesce a migliorare le prestazioni.

## Allocazione dinamica con heap

La heap è una zona di memoria le cui parti possono essere allocate e deallocate secondo necesità. È necessaria quando il linguaggio permette tipi dinamici, tipi di dimensione variabile, ed oggetti che sopravvivono alla procedura che li crea.

### Gestione della heap

Inizialmente una heap è formata da una lista di blocchi di dimensione uguale. È possibile allocare uno o più di questi blocchi ed utilizzarli liberamente. Quando sono deallocati vengono reinseriti nella lista.
I blocchi di dimensione fissa sono un problema, se sono troppo piccoli serve gestirne tanti e serve spezzare oggetti su più blocchi. Se sono troppo grandi viene sprecato molto spazio per oggetti piccoli.

Per risolvere si utilizzano liste di blocchi di dimensione variabile (lista libera).
Inizialmente è composta da un solo blocco con tutta la memoria. Quando si alloca una porzione di memoria il blocco si spezza, una parte è quella allocata, l'altra resta nella lista.
Quando si dealloca si reinserisce il blocco nella lista, se necessario si fonde il blocco con quelli adiacenti.

La soluzione con lista di blocchi di dimensione variabile offre vantaggi, ma si rischia di causare frammentazione.
* La soluzione con blocchi di dimensione fissa causava frammentazione interna
  * Parte del blocco non utilizzato
* La soluzione con blocchi di dimensione variabile causa frammentazione esterna
  * Si separano i blocchi in tanti blocchetti piccoli inutilizzabili

Si possono utilizzare diverse politiche di gestione della lista libera:
* First fit: più veloce perché non serve scorrere tutta la linea
* Best fit: minimizza la frammentazione, ma può essere molto più costosa
  * Si utilizzano delle soluzioni ad hoc per ottenere il risultato del best fit ma più velocemente

### Gesrione della lista libera: più liste

Buddy system:
* La k-esimalista contiene blochci di dimensione $2^k$
* Si cerca un blocco nella con i blocchi di dimensione adatta
  * Se la lista dei blocchi migliori è vuota si prende un blocco più grande e lo si spezza
* Quando deallochiamo si reinserisce il blocco nella sua lista
  * Se nella lista troviamo il suo "combagno" (buddy), li fondiamo e li mettiamo nella lista dei blocchi più grandi

Fibonacci heap:
* Simile ma i blocchi hanno la dimensione dei numeri di fibonacci
* I blocchi crescono di dimensione più lentamente, quindi è un po' migliore
* Da contro, fare i conti è un po' più complicato

## Implementazione delle regole di scope

Come recuperiamo i dati non locali nello stack di attivazione? Se i dati sono locali è facile, sappiamo l'offset dal frame locale. Altrimenti dipende dalle politiche di scope.

Bisogna fare attenzione all'efficienza, perché la ricerca potrebbe essere complicata

### Scope statico

#### Catena statica

Oltre al link dinamico al frame precedente abbiamo anche un link statico.

Consideriamo il programma
```cpp
int x = 10;

void a() {
  x++;
}

void b() {
  int x = 5;

  void c() {
    x = x + 2;
    a();
  }
  a();
  c();
}

b();
```

Le chiamate ad una funzione possono essere fatte solo da funzioni con *almeno* la stessa visibilità (ma anche di più). La funzione chiamata ha bisogno di un link al contesto in cui è dichiarata.
Fortunatamente, la funzione che la ha chiamata ha visibilità su quello stesso contesto, quindi può passare alla funzione il link a questo contesto.

Invece che avere un link a ciascuno dei contesti che ereditano fino alla radice, il frame contiene solo un puntatore a quello più interno, e scorre fino agli altri come una lista concatenata.
Quando una funzione chiamante si trova su un blocco più interno di quella chiamata, deve passare il link al blocco più esterno, e per trovarlo scorre la sua lista.

L'esecuzione del programma sopra produce questo stack:
* Fino ad esecuzione della prima a()
  0. Contesto globale
  1. B -> 0
  2. A -> 0
* Fino alla fine
  0. contesto globale
  1. B -> 0
  2. C -> 1
  3. A -> 0
