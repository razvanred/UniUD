# Paradigma funzionale

Il paradigma si separa di molto sia dai linguaggi ad oggetti, che dai linguaggi di Von Neumann (che alla fine ricadono entrambi tra i linguaggi imperativi).

I linguaggi imperativi sono strettamente collegati al funzionamento della macchina, infatti il linguaggio specifica una sequenza di estruzioni, più alcune strutture di controllo di flusso. Che indicano in ordine le operazioni che il processore deve eseguire.
In questi linguaggi l'operazione di base è l'assegnazione di una variabile, infatti i programmi hanno bisogno di mantenere degli stati, ed introduce il concetto di mutabilità che nella matematica non è presente.
Sono stati anche proposte macchine che non utilizzano l'architettura di Von Neumann, ma non hanno avuto successo, quindi tutti i moderni processori sono basati su questo tipo di architettura.

Nota bene che questo discorso è vero soprattuto per i linguaggi imperativi puri (quelli di Von Neumann), più che per quelli ad oggetti, anche perché ci sono linguaggi ad oggetti non imperativi, ma dichiarativi.

I linguaggi funzionali, invece, cercano di separarsi dall'architettura di Von Neumann, quindi tagliando i legami con i linguaggi imperativi.
Non abbiamo più una sequenza di istruzioni, ma una serie di dichiarazioni di funzioni, che al momento di esecuzione poi produrranno una sequenza di istruzioni da eseguire.
Si perde lo stato, i dati sono immutabili, quindi non è presente nemmeno l'operazione di assegnamento, e tutti gli identificatori sono immutabili.
La perdita dello stato porta alla perdita dei cicli, che non sono più né realizzabili, né utili. Se si vuole ripetere un'operazione più volte, lo si fà utilizzando la ricorsione.

Caratteristiche generali:
* Assenza di stato
  * Conseguentemente, assenza di cicli while e simili
  * Sostituiti da funzioni ricorsive
* Le funzioni sono oggetti di primo ordine
  * Si possono deginire funzioni di ordine superiore
  * Si possono definire funzioni senza nome (espressioni lambda)
    * In Scheme: `(lambda (x) (+ x 1))`
* Polimorfismo
  * Le funzioni si adattano a tipi di dato diversi, quindi possono essere riutilizzate
  * Si può usare type checking...
    * Dinamico (come su Scheme)
    * Statico (come su haskell), ma con sistemi sofisticati
solo all'interno della procedura che la dichiara.

## Meccanismo di valutazione teorico: riscrittura

Formalmente, un linguaggio funzionale eseguirebbe una chiamata sostituendo gli argomenti formali con quelli attuali, e riscrivendo man mano che esegue le operazioni (Es: `f(a,b)=a+b`, quindi `f(1,2)` -> `f(1,2)=a+b` -> `1+2` -> `3`).
Qualsiasi algiritmo è descritto formalmente come una serie di riscritture del programma, fino ad ottenere un singolo elemento che è il risultato.

Molto poco efficiente da implementare.

## Meccanismo di valutazione implementato

Si separe un espressione in sottoespressioni che vengono valutate man mano in ambienti incrementali.

Viene creato uno stack di operazioni da valutare con i loro ambienti. Questa struttura complessa e la sua gestione sono la macchina SECD, a cui si ispirano tutti i linguaggi funzionali.

## Vantaggi del paradigma funzionale rispetto a quello imperativo

Facciamo un esempio usando un errore della libreria Java nella classe `ProtectedResource` (vedi appunti per il codice).

Era presente una lista di `allowedUsers`, per sapere quali sono si usa un metodo publico `getAllowedUsers` che restituisce la lista.
Visto che il modello di memoria è a riferimento, chi ottiene la lista può modificarla da fuori dell'oggetto, in pratica ottiene un alias della lista. La soluzione sarebbe di copiare la lista invece che passarla e basta.

Su un linguaggio funzionale questo non sarebbe mai successo perchè non si possono modificare gli stati e non si creano alias.

## Valori

Soprattutto nei linguaggi eager è importante definire:
* L'insieme di valori considerati "completamente valutati"
* Costanti numeriche
  * Sono sempre valori, in qualsiasi linguaggio
  * 1, 2, 3, ...
* Espressioni di tipo complesse
  * Es: se trovo una coppia, non vado a valutare i singoli elementi, la coppia è considerata completamente valutata
* Lambda espressioni:
  * Una funzione si considera completamente valutata quando è ridotta ad una lambda espressione
    * Anche costanti o thunk (senza argomenti)
  * Una *chiamata* ad una funzione si considera completamente valutata quando è ridotta ad uno degli altri valori

## Purezza

Molti linguaggi funzionali, Scheme compreso, non sono linguaggi funzionali puri, perché permettono di definire funzioni con effetti collaterali. Alcuni effetti collaterali possono essere assegnazioni di variabili e scritture su console.
Alcuni linguaggi non puri permettono anche di usare meccanismi tipici dei linguaggi imperativi, come cicli while.

Haskell è puro.

## Haskell (e confronto con Scheme)

Presentiamo il paradigma con un esempio concreto (Haskell), confrontandolo a Scheme, perché hanno lo stesso paradigma, ma sono completamente diversi.

Il linguaggio può essere sia compilato che interpretato, a noi basta un interprete, ma è più efficiente compilare il codice.

### Differenze

Origini:
* Scheme:
  * Uno dei tanti dialetti di Lisp (John McCarthy 1958)
  * Predecessore di Racket
  * Sviluppato nel 1975 da Guy L. Steele e Gerald Jay Sussman
* Haskell:
  * Derivato da ML (David Milner 1973), come Caml e OCaml
  * Proposto nel 1987 da Philip Wdler e Stephen Blott
  * Sviluppato nel 1990 da un comitato

Sintassi:
* Scheme: pochi costrutti semplici, a scapito della verbosità
* Haskell: non molti costrutti di base, molto zucchero sintattivo per meno verbosità

```Haskell
-- crivello di Eratostene in Haskell
primes = filterPrime [2..]
  where filterPrime (p:xs) =
    p : filterPrime [x | x <- xs, x `mod` p /= 0]
```

Sono entrambi fortemente tipizzati, ma Haskell è tipizato staticamente, mentre Scheme dinamicamente. In particolare, il controllo di tipo di Haskell è estremamente sofisticato e basato sull'inferenza di tipo

Meccanismo di valutazione:
* Scheme: eager, call-by-value
  * Più semplice da implementare
* Haskell: lazy, call-by-need
  * Versione più efficiente del call-by-name, serve che la funzione non abbia effetti collaterali
  * La valutazione lazy permette di gestire facilmente strutture di dati infinite

In generale i linguaggi funzionali si distinguono tra quelli eager e quelli lazy.

### Valori

Il sistema di tipo di Haskell fa inferenza sui tipi, e sceglie sempre il tipo più generico che riesce quando è possibile

Tipi scalari:
* Numerici, di varie classi
  * `Num`, interi semplici
  * `Fractional`, numeri razionali
  * `Floating`, numeri con virgola mobile
  * Si può fare overloading delle operazioni senza conversione esplicita
* Caratteri
  * Supporta i caratteri unicode

Tipi più complessi
* Ennuple di tipi diversi
  * Di lunghezza fissa
  * Ovviamente, anche non omogenee
  * Si può iterare sui valori delle ennuple
  * Si possono definire distruttori
* Liste
  * Di lunghezza arbitraria, ma con elementi di tipo omogeneo
  * Possono essere costruite usando due costruttori:
    * Lista vuota `[]`
    * Concatenazione `val:list`
  * Si possono scrivere usando zucchero sintattico
    * `[1,2,4]` equivalente ad `(1:(2:(4:[])))`
    * `"abc"` equivalente ad `('a':('b':('c':[])))`
  * Si possono usare distruttori `head` e `tail`, che sono come `car` e `cdr`
* Sequenze aritmetiche, presenti anche in altri linguaggi
  * `[1..9]` numeri da 1 a 9
  * `[1,3..20]` numeri da 1 a 20 (ma si ferma a 19) saltando 2 (quindi 1 3 5 7 8 ... e non arriva a 20)
  * `[1,2,4..64]` questo è troppo complicato, può fare solo salti

Tipi definiti dall'utente:
* Enumeratori
  * `data Colore = Rosso | Verde | Blu`
  * `col = Rosso`
  * Haskell è case sensitive, i tipi *devono* avere la maiuscola, altrimenti genera un errore
    * `data colore ...` errore
    * `data Colore = rosso | ...` errore
  * Il tipo booleano è definito nel preludio come un enumeratore
    * Si possono definire tipi con lo stesso nome su moduli diversi (quindi puoi ridefinire `Bool`), ma bisogna specificare a quale si fa riferimento quanod si usano
    * L'interprete accetta anche definizioni multiple nello stesso modulo
* Tipi record, con costruttori
  * `data IntPoint = IPt Integer Integer`
    * `IPt 3 6`
  * Definisco il tipo record usando il suo costruttore (la funzione IPt)
* Tipi unione, più alternative 
  * `data Point = PT2 Integer Integer | PT3 Integer Integer Integer`
  * Si specificano diversi costruttori, usando il pipe `|` per indicare le alternative
  * La selezione usa il nome del costruttore
* Tipi parametrici, o tipi polimorfi
  * `data Point a = Pt a a`
  * Come i record, ma aggiungo il parametro `a` sulla parte del nome del tipo
  * Il costruttore è generico ed accetta tanti tipi diversi
    * Quali tipi accetta lo decide haskell col sui sistema di inferenza di tipo
  * Possiamo vedere `data Point` come un costruttore di tipo, mentre `Pt` è un costruttore di dati
  * Assomiglia al meccanismo delle classi generiche di Java
  * `data Point a = Point a a` e `Point 2 3 :: Point Integer` possono coesistere
    * Il nome `Point` ripetuto non è un problema perché verrà usato in contesti diversi
      * Come funzione e come tipo
    * Tutto si basa sul meccanismo di inferenza di tipo come al solito
* Ennuple
  * `(3, 'a', ['b']) :: Num t => (t, Char, [Char])`
    * Notare la virgola per separare i campi
  * È un particolare tipo di record parametrico
  * Equivalente (circa, perché questo non è valido) a `data (_, _, _) a b c = (_, _, _) a b c`
    * Ma con una vagonata di zucchero
  * Si possono definire ennuple di lunghezza arbitraria e di tipi non omogenei
    * Concettualmente, è come se venissero definiti diversi costruttori (del tipo di quello sopra) per ogni numero di argomenti
* Tipi ricorsivi e parametrici
  * `data Tree a = Leaf a | Branch (Tree a) (Tree a)`
    * Nota che la definizione della libreria standard non è proprio come questa, perché non ha dati nei nodi interni
    * `data Tree a = Nil | Node a (Tree a) (Tree a)` quella standard è più simile a questa
  * `data List a = Nil | Cons a (List a)`
    * Questa è abbastanza simile alla definizione della lista standard, solo che ci aggiungono dello zucchero sintattico
  * Posso avere tanti tipi di costruttori parametrici, e possono essere ricorsivi
  * Possiamo vederli come un tipo particolare di union in cui metto il tipo stesso tra i parametri
  * Sono ammessi anche tipi mutualmente ricorsivi
    * Alberi non binari sono definiti da due tipi: una foresta (come insieme di alberi) ed un albero (come nodo padre ed una foresta di figli)
  * Anche in scheme si possono fare senza problemi, soprattutto perché è non tipizzato

Tipi predefiniti come caso particolare:
* Boolean, come enumeratori
* Ennuple, per lo zucchero sintattico
* Integral, seguono il pattern di base, ma hanno troppi elementi per poter essere davvero definiti in modo standard
* Floating

#### Equazioni di tipo

Posso dare un nome ad espressioni di tipo:

```Haskell
type String = [Char]
type Person = (Name, Address)
type Name = String
data Address= None | Addr String

type IntTree = Tree Integer
type BinaryFunction a = a -> a -> a
type BinaryIntFunction = BinaryFunction Integer
```

Si possono specificare uguaglianze tra tipi, ed Haskell usa l'equivalenza strutturale. Fa unfolding fino ai tipi base e se trova la stessa espressione considera i tipi come uguali.
*Tranne*, quando si parla di tipi ricorsivi, in quel caso serve anche avere lo stesso nome (altrimenti molti tipi sarebbero equivalenti per caso)

### Variabili e binding

Si possono associare valori alle variabili:

```Haskell
x = 5 + 3
```

Il legame è immutabile, non si possono ne fare assegnamenti ne ridefinire la variabile.
Quando si usa l'interprete è diverso: è come se ogni assegnamento aprisse un nuovo ambiente in cui quell'assegnamento è valido.

Notiamo che il linguaggio è lazy, quindi l'espressione `5 + 3` non verrà valutato finché non si va a chiamare la variabile `x`.

Essendo lazy, si possono definire senza problemi variabili mutualmente ricorsive. Se si creano dei cicli infiniti, il programma continuerà a calcolare finche non finisce la memoria.

Possiamo definire ambienti locali con il `let`:
``` Haskell
y = 5
let y = a + 3
    a = 5
in y + a      -- fa riferimento alla y che vale a+3
```


### Funzioni

Le funzioni sono oggetti del primo ordine, per definire le funzioni si usano le lambda espressioni, che si indicano con `\` perché è la lettera che assomiglia di più a $\lambda$.

```Haskell
\ x -> x + 1
```

Si può associare un identificatore alle funzioni, con dello zucchero sintattico per facilitare la scrittura, ma equivale a creare un legame tra una variabile ed una lambda espressione.

```Haskell
inc = \ x -> x + 1
inc x = x + 1 -- zucchero sintattico, equivalente a sopra
```

#### Pattern matching

Si possono definire "versioni diverse" della stessa funzione, che attraverso un meccanismo di pattern matching vengono selezionata in base all'input.

```Haskell
fact 0 = 1
fact n = n * fact (n - 1)
```

È permesso definire la funzione per casi, che rende alcune funzioni più sintetiche e chiare, ma è zucchero sintattico, perché si può ricondurre ad altri meccanismi di base. Quando si fa si possono usare delle wildcard `_` per indicare variabili di input che ci sono, ma in un caso non sono utilizzate.

```Haskell
head (x:xs) = x
tail (_:xs) = xs

map :: (a -> b) -> [a] -> [b]
map _ [] -> = []
map f (x:xs) = f x : map f xs

fibAux 1 = (0, 1)
fibAux n = (snd pair, fst pair + snd pair)
            where pair = fibAux(n-1)
            -- where definisce un ambiente locale in cui valutare l'espressione precedente
            -- (simile al let)

fastFib n = fst fibAux n
```

#### Currying

Prende il nome da Haskell Curry. Ha definito dei formalismi da cui nasce la programmazione funzionale.
Le funzioni con più argomenti sono viste come funzioni che restituiscono funzioni.

```Haskell
-- Tre definizioni equivalenti di somma
add = \ x -> ( \ y -> (x + y))
add = \ x y -> x + y
add x y = x + y
```

Il currying permette di definire più sinteticamente alcune funzioni derivate come `add 1` che è derivata da quella appena definita e realizza un incremento di 1.

Per chi vuole forzare una versione uncarryed si può fare prendendo in input un record. In genere non si fa, perché è più scomodo da scrivere ed a volte meno efficiente (facendo così comincia ad assomigliare alla notazione di un linguaggio più C-like).

#### Regole sintattiche per evitare le parentesi

Le parentesi non sono obbligatorie il più delle volte, ma servono per disambiguare in alcuni casi.

Il linguaggio associa generalmente a sinistra, se si vuole disambiguare si possono mettere le parentesi come su lisp. Quando si fanno catene di `->`, di solito si vuole associare a destra, quindi si devono mettere le parentesi, come nella definizione di `add` sopra.

#### Alcune funzioni standard

* Curry 
  * Trasforma una funzione binaria in una funzione curryficata
* Uncurry
  * Operazione inversa di curry
* Compose
  * Prende due funzioni e restituisce la composizione delle funzioni

### Meccanismo di valutazione

Usa la valutazione lazy, con un meccanismo call-by-need:
* Gli argomenti sono associati a variabili, ma non sono valutati
  * Viene passata la loro chiusura
* Se viene utilizzata la variabile, viene valutata, ma solo la prima volta, poi si memorizza il risultato

#### Dati lazy

La valutazione differita viene usata anche per i costruttori, quindi permette di definire dati infiniti.
Quando un dato è definito ricorsivamente, viene espansa sola la parte chiesta dal codice, non necessariamente tutti i costruttori ricorsivi che chiama.

Esempi:
```Haskell
-- Quando le liste sono infinite si chiamano stream
numsFrom n = n : numsFrom(n + 1)
-- Questa lista contiene tutti i naturali a partire da n
-- Vengono espansi solo quando sono richiesti

-- Lista di tutti i quadrati
squares = map (\x -> x^2) (numsFrom 0)
-- Questa funziona solo su liste infinite, perché non prevede
-- la stringa vuota

-- Sequenza di Fibonacci
addList (x:xs)(y:ys) = (x + y) : addList xs ys
fib = 1:(addList fib (0:fib))
-- Viene sommata la lista di Fibonacci alla lista traslata di 1
-- È efficiente perché col call-by-need viene calcolata solo una volta anche se viene duplicata
```

Quando provo ad acccedere ad un elemento della lista di quadrati viene forzata l'espansione della lista di naturali fino allo stesso punto, e mappa la funzione fino a quel punto. Ma gli elementi successivi non sono calcolati finché non sono richiesti.

#### Estrarre parti finite da dati lazy

Per la prima parte finita si usa la funzione `take` predefinita nel preludio:
```Haskell
take 0 _ = []
-- Caso base
take _ [] = []
-- Per gestire le liste finite troppo corte
take n (x:xs) = x : take (n-1) xs
-- Caso generale
```

Per selezionare l'iesimo elemento di uno stream si usa `takeEl`
```Haskell
takeEl 0 (x:_) = x
takeEl n (x:xs) = takeEl (n-1) xs
```

#### Stream nei linguaggi funzionali eager

Molti meccanismi tipici di Haskell vengono adottati anche da altri linguaggi, come il pattern matching su Rust. Alcuni non sono formalmente presenti nei linguaggi ma sono simulati.

Si possono rappresentare strutture di dati infinite con i thunk nei linguaggi eager:
```Scheme
(define (numsFrom n) (lambda () (cons n (numsFrom (+ n 1)))))

(define nums (numsfrom 0))

(define (take n xs)
  (cond
    [(equal? n 0) null]
    [(equal? (xs) null) null]
    ; Le parentesi tonde forzano la valutazione del thunk
    [true (cons (car (xs)) (take (- n 1) (cdr (xs))))]))
; Restituisce una lista di n elementi, costruita dal thunk
; Assomiglia agli iteratori con .next()
```

Quando si lavora sugli stream simulati con thunk, non si possono usare le classice funzioni di valutazione, ma si devono definire nuove funzioni:
```Scheme
(define (lazymap f xs)
  (if (equal? (xs) null)
    xs
    (lambda () (cons (f (car (xs)))
                     (lazymap f (cdr (xs)))))))

(take 20 (lazymap (lambda (x) (* x x)) nums))
; Prende i primi 20 quadrati
```

### Sintassi infissa

Haskell utilizza la sintassi infissa per gli operatori, ma gli operatori possono essere definiti dal linguaggio.

* Predefiniti
  * Operazioni aritmetiche
  * Concatenazione
  * Costruzione delle liste
  * Operatore di composizione
* Definiti dall'utente
  * Si possono definire operatori infissi non standard
    * `(#) a b = rem a b` permette di scrivere `6 # 3`
    * `(\\) a b = a + b` permette di scrivere `6 \\ 3`
  * Si può specificare la priorità di associatività:
    * `infixl 9 #` associativo a sinistra con priorità 9
    * `infixr 5 \\` associativo a destra con priorità 5
    * `7 # 4 # 3 \\ 2 \\ 5` diventa `((7 # 4) # 3) \\ (2 \\ 5)`
* Posso rendere prefisso un operatore infisso con le parentesi
  * `(x) a b` equivale a `a + b`
* Posso rendere infisso un operatore prefisso con i backtick
  * (non si possono scrivere su markdown, non accetta escaping, esempio con gli apostrofi)
  * `a 'add' b` equivale a `add a b`

### List comprehension

Le liste in Haskell sono largamente utilizzate, è utile avere dello zucchero sintattico.
La list comprehension è equivalente ad un mapping, ma più comodo.

```Haskell
[f x | x <- xs]
-- Applica f a tutti gli x in xs
-- Assomiglia alla notazione insiemistica
```

La parte a destra del pipe si chiama generatore. Posso averne più di uno e viene valutato il prodotto cartesiano (anche questo è zucchero sintattico).
```Haskell
[(x * y) | x <- [1..10] | y <- [1:10]]
-- Equivalente a
[[(x * y) | x <- [1..10]] | y <- [1..10]]
```

Posso aggiungere delle guardie booleane per filtrare la lista (esempio col quicksort).

Simulazione di quicksort (non efficiente come quello imperativo)
```Haskell
quickSort [] = []
quickSort (x:xs) = 
  quickSort[y | y <- xs, y < x] ++
  (x : quickSort[y | y <- xs, y > x])
-- La virgola separa il generatore dalla guardia
-- Il ++ è l'operatore di concatenazione
```

### Preludio

Il preludio è una libreria che viene caricata all'inizio del programam e contiene una serie di operazioni predefinite ed alcune librerie ricorrenti che vengono usare sempre (come il preludio di rust).
Abbiamo visto solo le cose più basilari, è utile dare un occhiata alle librerie fornite dal preludio.

### Fold

#### Left

`foldl f z l` applica `f` agli elementi di `l` da sinistra a destra, con valore iniziale `z`

```Haskell
-- Tipo di foldl
foldl :: (b -> a -> b) -> b -> [a] -> b

foldl f z [] = z
foldl f z (x:xs) = foldl f (f z x) xs
```

Possiamo usarlo per definire la funzione `reverse`
```Haskell
reverse xs = foldl (\ys y -> (y:ys)) [] xs
-- Oppure
reverse xs = foldl (\ys -> \y -> (y:ys)) [] xs
reverse xs = foldl (\ys -> (:ys)) [] xs
```

#### Right

Equivalente a fold left, ma da destra e non da sinistra.

```Haskell
-- Tipo di foldr
foldr :: (a -> b -> b) -> b -> [a] -> b

foldr f z [] = z
foldr f z (x:xs) = f x (foldr f z xs)
```

Possiamo usarlo per definire il reverse:
```Haskell
reverse xs = foldr (\ y ys -> (ys ++ [y])) [] xs
```

### Case

Quando definiamo le funzioni per pattern matching, in realtà stiamo usando zucchero sintattico per il costrutto case:
```Haskell
take 0 _ = []
take _ [] = []
take n (x:xs) = x : take (n-1) xs

-- Equivalente a

take n xs case (n, xs) of
  (0, _) -> []
  (_, []) -> []
  (n, (y:ys)) -> y:take (n-1) ys

```

Ovviamente i case possono essere annidati.

I linguaggi di programmazione imperativi non permettono di utilizzare case con pattern matching (Rust sì, ma non supporta tipi ricorsivi), è una caratteristica tipica di Haskell.

Utilizzare un case forza la valutazione dell'argomento, che però viene valutato in modo lazy. Nel senso che se a sua volta l'elemento contiene altri elementi, questi non sono valutati se non sono richiesti.
I case possono essere complessi, anche su una sola variabile, potrebbero cercare di far combaciare diverse costruzioni, ad esempio `(x:0:xs)` per verificare che una lista ha `0` come secondo elemento.

#### Ordine di valutazione

I pattern vengono provati in ordine di definizione, quando un pattern combacia eseguo l'espressione. È importante controllare l'ordine in cui sono definiti i pattern, altrimenti si potrebbe avere una computazione diversa.
Se alcuni casi non sono stati previsti, viene generato un errore a runtime (case non esaustivo), ma se non vengon mai utilizzati quei casi, non è un problema (Rust ti forza a sccrivere case esaustivi).

```Haskell
take 0 _ = []
take _ [] = []
take n (x:xs) = x : take (n-1) xs

take _ [] = []
take 0 _ = []
take n (x:xs) = x : take (n-1) xs

-- Non sono equivalenti, il codice generato è diverso
-- Quando xs è [] uno forza la valutazione di n e l'altro no
-- non si mantiene stato, quindi il risultato sarà lo stesso, se terminano
-- Non sono ovvi, ma ci sono casi in cui uno diverge e l'altro no
-- Es: Se n diverge (quindi non termina) e la lista è vuota, il primo diverge ed il secondo no
```

#### Pattern con guardie

```Haskell
sign x | x > 0 = 1
       | x == 0 = 0
       | x < 0 = -1

-- Equivalente a
sign x = case x of
         y | y > 0 = 1
           | y == 0 = 0
           | y < 0 = -1

-- Equivalente a
sign x = case x of
         y | y > 0 = 1
           | y == 0 = 0
           | otherwise = -1
```

Il lingauggio permette di definire diverse guardie per ogni pattern (non sono obbligatorie) per gestire casi in cui un pattern ha anche dei sottocasi che non si riescono a catturare con i pattern, come dei confronti di maggioranza.
Si può usare la keyword `otherwise` come un caso di default.

### Ambienti locali

#### Let

Definisco alcune espressioni mutualmente ricorsive prima dell'espressione che voglio valutare.

L'espressione in cui queste definizioni hanno valore sono indicate dalla keyword `in`

#### Where

Definisce alcune associazioni non mutualmente ricorsive. Viene indicato dopo l'espressione per cui è valido.

### Layout

Notiamo che negli esempi mancano sia separatori come `;`, che indicatori di blocco come `{ }`.
Viene usata la tabulazione per indicate blocci di codice. Se si sbaglia la tabulazione il programma non funziona, ed in genere causa errori di compilazione, ma non sono molto chiari.

Volendo si può scrivere in modo tradizionale con separatori e blocchi.

Il lexer di Haskell deve essere più complicato perché non bastano solo i token, serve anche la posizione. Lo stesso problema riguarda tutti i linguaggi che hanno tabulazione significativa, come Python.

### Record

```Haskell
data Point23 = Pt2 {xCoord, yCoord :: Float}
             | Pt3 {xCoord, yCoord, zCoord :: Float}
             | Pt Float Float
```

I record di Haskell sono record varianti. Le diverse varianti sono definite dai costruttori e possono avere o meno etichette per i campi.
I costruttori possono essere usati per il pattern matching, mentre i nomi dei campi (se presenti) possono essere usati come distruttori.
Quando costruisco un record con i nomi nei campi devo usare i nomi nel costruttore.

Posso copiare un record modificandone alcuni campi.

```Haskell
p1 = Pt 4 2
p2 = Pt2 {xCoord = 3, yCoord = 5}

-- pattern
(Pt f1 f2) = p1

-- distruttore
f3 = xCoord p2

-- partendo da p2
-- definisco p3 = Pt2 {xCoord = 3, yCoord = 6}
p3 = p2{yCoord = 6}
```

Visto che il linguaggio è lazy, alcune espressioni invalide possono essere scritte, e causeranno errore solo quando sono valutate.

```Haskell
p = Pt2 {xCoord = 3, yCoord = 5}
f = zCoord Pt2
-- genera errore solo quando viene valutato f
```

Alcuni controlli di tipo, come quello precedente, possono essere catturati solo a runtime.

### Polimorfismo, type classes

Haskell permette di definire delle funzioni senza doverne specificare il tipo. Volendo possiamo andare a vedere il tipo che viene associato alla funzione dal compilatore. Il compilatore cerca di trovare il più generico tipo parametrico possibile che riesca a catturare il comportamento della funzione.
Quando viene definito il primo caso, il sistema trova un tipo parametrico adatto; e man mano che vengono aggiunti altri casi alla funzione, raffina il tipo parametrico. Ovviamente se non esiste un tipo parametrico non si blocca.

Questo sistema non funziona sempre. Ad esempio, se definiamo il quicksort, generalizzare col tipo parametrico `[a] -> [a]` non basta, perché non tutti i tipi supportano i confronti di maggioranza, quindi serve un modo per forzare che sia supportato.
Nel caso del quicksort, serve che implementino una classe `Ord`, e la definizione del tipo divente `Ord a => [a] -> [a]`, che indica una funzione che manda da liste a liste dello stesso tipo, in cui il tipo della lista deve implementare `Ord`
Ord è la classe degli oggetti che implementano `<` e `<=`, ci sono dei modi che usa il compilatore per implementarle automaticamente per alcuni tipi. Si tratta di polimorfismo di overloading (quindi un tipo di polimorfismo ad hoc), perché è la stessa funzione definita in modo diverso in base al tipo.

Il meccanismo per definire una classe, definisce una serie di metodi che il tipo deve avere.
```Haskell
class Eq a where
    (==) :: a -> a -> Bool
    -- L'identazione identifica il blocco di funzioni
```

Per far si che un tipo appartenga alla classe bisogna indicare le implementazioni delle funzioni richieste.
```Haskell
instance Eq Integer where
    x == y = integerEq x y
```

Ovviamente alcuni tipi predefiniti sono già istanze di alcune classi predefinite, come i due esempi appena fatti, ma possiamo definirne di altre.

Quando andiamo a scrivere una funzione polimorfa, il sistema riesce a capire la classe necessaria. Ma se ci sono delle ambiguità bisogna specificarla manualmente.
```Haskell
elem x [] = False
elem x (y:ys) = x == y || (elem x ys)

-- Il sistema riesce ad inferire il tipo
elem :: (Eq a) => a -> [a] -> Bool
```

Sugli elementi di equal non solo si può usare il metodo `==`, ma anche il metodo `/=`. Ma non serve implementarle manualmente entrambe, perché sono presenti delle implementazioni di default.
```Haskell
class Eq a where
    (==), (/=) :: a -> a -> Bool
    x /= y = not (x == y)
    x == y = not (x /= y)
```

Quando andiamo a definirne una sola, l'altra tiene la definizione di default che è definita in base a quella definita da noi. Non possiamo non definirne nessuna perché sono mutualmente ricorsive.
Possiamo anche implementarle entrambe, ma non è strettamente necessario. Questo ci permette di rompere la coerenza che otteniamo definendo una relazione in base all'altra, perché Haskell controlla solo i tipi (non potrebbe controllare la coerenza nemmeno volendo).

#### Definizione di istanze polimorfe

Prendiamo la definizione ricorsiva parametrica di albero. Come implementiamo l'uguaglianza sugli alberi? Non serve realizzare un'implementazione ad hoc per ogni tipo di albero, possiamo indurre l'uguaglianza dell'alberp quando il tipo delle foglie è un istanza di `Eq`.

```Haskell
instance (Eq a) => Eq (Tree a) where
    Leaf l1 == Leaf l2 = l1 == l2
    Branch tl1 tr1 == Branch tl2 tr2 = tl1 == tl2 && tr1 == tr2
      _ == _ = False
```

Queste definizioni strutturali "standard" possono essere definite automaticamente utilizzando la keyword `deriving` nella definizione di tipo.
```Haskell
data Tree = Leaf a | Branch (Tree a) (Tree a)
    deriving (Eq)
```

Non è disponibile per tutti le classi, ma per quelle per cui è disponibile, permette di scrivere meno codice.

#### Relazione di sottoclasse

Si può dichiarare una classe come sottoclasse di un'altra. Non è la stessa cosa delle sottoclassi dei linguaggi ad oggetti, le classi di Haskell assomigliano di più alle interfaccie di Java, od ai tratti di Rust (che non è ad oggetti, ed essendo più furbo ha evitato omonimie).
```Haskell
class (Eq a) => Ord a where
    (<), (<=), (>), (>=) :: a -> a -> Bool
    min, max :: a -> a -> a
    x <= y = x < y || x == y
    -- Posso usare il comparatore di uguaglianza perché per essere di classe Ord
    -- deve essere anche di classe Eq
    x >= y = x > y || x == y
    x < y = not (x >= y)
    x > y = not (x <= y)
    -- È sufficiente implementare un confronto ed un uguaglianza per implementare
    -- automaticamente tutti i metodi di entrambe le classi
```

Si possono anche avere sottoclassi multiple
```Haskell
classe (Eq a, Show a) => EqAndShow a where
    ...
```

#### Visibilità dei nomi

Serve per poter definire funzioni o ridefinire metodi:
* Classi e metodi globali sono visibili a tutto il programma
* Uno stesso nome di metodo non può essere definito su più classi
* Le sottoclassi implementano tutti i metodi della superclasse
  * È l'unico caso in cui due classi hanno gli stessi metodi
* Metodi variabili e funzioni sono nello stesso namespace
  * Non posso avere variabili e funzioni con lo stesso nome

#### Relazione con i linguaggi OO

Ci sono una serie di differenze:
* Non c'è ereditarietà
* Su linguaggi ad oggetti si indica l'oggetto e si indica il metodo da eseguire
  * Su haskell si indica il metodo e l'oggetto su cui lo si vuole eseguire
  * I metodi non sono collegati agli oggetti, ma al tipo
* Non c'è information hiding

#### Esempi di classi

```Haskell
class Eq ...

class Ord ...

class Functor f where
    fmap :: (a -> b) -> f a -> f b
    -- Parte da una funzione che va da `a` a `b`
    -- restituisce una funzione che va da `f a` (`f` applicato ad `a`) ad `f b`

instance Functor [] where
    fmap = map

-- Ci aspettiamo le proprietà
fmap id == id
fmap (f . g) == fmap f . fmap g
```

Quando definiamo una classe, elenchiamo anche le proprietà che ci aspettiamo di vedere rispettate, come le proprietà transitiva, riflessiva e simmetrica di `Eq`.

### Costruttori di tipo canonici

#### Maybe

```Haskell
data Maybe a = Nothing | Just a

-- Come Option<t> di Rust

-- Esempio:
myhead :: [a] -> Maybe a
myhead [] = Nothing
myhead (x:xs) = Just x

-- È un funtore
instance Functor Maybe where
    fmap f Nothing = Nothing
    fmap f (Just x) = Just (f x)
```

#### Either

Per realizzare l'unione di due tipi.
```Haskell
data Either a b = Left a | Right b

-- Non è un funtore
```

### Classi numeriche

Haskell ha un insieme ricco di tipi numerici, ereditato da Scheme. Ha anche un ricco insieme di classi per questi tipi numerici.

```Haskell
class Eq a where
    ...

class Show a where
    ...

class Read a where
    ...
  
-- Più generale
-- Prevede una quarantina di istanze possibili
class (Eq a) => Num a where 
    (+), (-), (*) :: a -> a -> a
    negate, abs :: a -> a
    fromInteger :: Integer -> a

class (Num a, Ord a) => Real a where
    toRational :: a -> Rational

class (Real a, Enum a) => Integral a where
    quot, rem :: a -> a -> a
    div, mod :: a -> a -> a
    toInteger :: a -> Integer

class (Num a) => Fractional a where
    (/) :: a -> a -> a
    recip :: a ->

class (Fractional a) => Floating a where
    ...
    -- Alcune funzioni di arrotondamento

class (Real a, Fractional a) => RealFrac a

class (RealFrac a, Floating a) => RealFloat a

class Functor a where
    ...

class Monad a where
    ...
```

#### Casting esplicito

Per fare il casting di tipo su Haskell bisogna usare una funzione di conversione. Per tutti i tipi numerici sono definite una serie di funzioni di casting ad hoc che specificano non solo il tipo che viene convertito, ma anche il metodo di conversione (ad esempio `ceiling` o `floor` per convertire da integrale ad intero)

### I/O Pragmatica

Nell'uso pratico IO di haskell, si definisce una variabile `main :: IO (...)` che viene valutata all'inizio del programma, e causa le operazioni di input ed output

Dentro la variabile main (tra parentesi), si inseriscono tutte le operazioni di IO, come una sequenza.

Ovviamente, le operazioni di IO hanno degli effetti collatterali, che in un linguaggio funzionale puro non dovrebbero essere presenti, in più in Haskell l'ordine di valutazione delle operazioni è stano, si rischiano problemi. Ci servono dei modi per gestire la cosa.

Alternative:
* Permettere funzioni con effetti collaterali, senza segnalare niente
  * Il linguaggio non è più puro
  * ML e Scheme
  * Il comportamento del linguaggio dipende dall'ordine di valutazione
* Si introduce esplicitamente lo steso nel tipo delle funzioni
  * `fs :: A x S -> B x S`
    * Curryficando: `fs :: A -> (S -> (B x S))`
  * Permette di avere un linguaggio funzionale puro, ed è quella scelta da Haskell

#### Tipo IO

In Haskell per gesire le operazioni con effetti collaterali (quelle di IO in particolare) si utilizza il tipo `data IO a = (S -> (a,S))` (la definizione non è proprio così, è un costruttore predefinito).

La definizione è nascosta, ma esistono alcune funzioni predefinite sui tipi IO, come `getChar` e `putChar` (da cui si può ottenere tutto il resto).

Cos'è questo fantomatico *stato* che le operazioni modificano? Boh. Possono essere i file stdin e stdout, in questo caso, ma anche altri file od altri costrutti.

#### Funzioni di IO

* `getChar :: IO Char`
  * Dato uno stato, restituisce un carattere e modifica lo stato
* `putChar :: Char -> IO ()`
  * Dato un carattere ed uno stato, stampra il carattere e modifica lo stato
* `getLine :: IO String`
* ...

#### Operatori su IO

Posso comporre i comandi base con alcuni operatori:
* `(>>) :: IO a -> IO b -> IO b`
  * È in pratica l'operazione di composizione di due comandi
  * Ottiene il valore `a` e lo stato modificato, dimentica `a` e ottiene `b` con lo stato modificato da `a`
* `(>>=) :: IO a -> (a -> IO b) -> IO b`
  * Compone due comandi azione, tenendo in considerazione il risultato di `a`
  * Questo ed il precedente associano a destra
* `return a -> IO a (a -> (S -> (a, S)))`
  * Presa un’espressione `v` di tipo `a` restituisce un’azione che lascia lo stato inalterato e ritorna `v` 
  * In pratica perende un valore, e senza fare niente restituisce un valore sotto forma di comando
* `do`
  * Permette di eseguire una sequenza di comandi di IO

#### Separazione tra funzionale ed IO

Su comandi ed espressioni di tipo `IO a` non si possono usare altre funzioni, solo gli operatori di IO e le funzioni di IO.
All'interno di comandi, invece, posso chiamare una funzione, ma devo restituire un'altro comando.

#### Esempi

```Haskell
main :: IO()
main = do c <- getChar
          putChar c
          putChar '\n'

getLine2 :: IO String
getLine2 = do c <- getChar
              if c == '\n'
              then return ""
              else do l <- getLine2 
                      return (c:l)
```

#### Classi Show e Read

Sono le classi dei tipi che possono essere letti o scritti
```Haskell
class Show a where
  show :: a -> String
  -- funzione usata dall'interprete per visualizzare le espressioni
  shows :: a -> String -> String
  showsPrec :: Int -> a -> String -> String
  showList :: [a] -> ShowS


class Read a where
  readsPrec :: Int -> ReadS a
  readlist :: ReadS [a]
  ...
  ...
```
