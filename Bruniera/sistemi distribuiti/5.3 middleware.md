# Middleware

## Caratteristiche delle API di IPC che un MW gestisce

Possiamo suddividere le varie API di IPC in due grandi categorie:
* Sincrone
  * Send bloccante: si aspetta che il destinatario riceva i dati (TCP)
  * Receive bloccante: si aspetta che arrivino dei dati
  * Sono necessarie entrambe per comunicazione sincrona
* Asincrone
  * Send non bloccante: si invia e si passa subito ad altro (UDP)
  * Receive non bloccante: se non ci sono dati da leggere si riporta e si passa oltre
  * Spesso si ha send non bloccante ma receive bloccante, conta comunque come asincrono

Per indicare il destinatario non possiamo usare IP e porta perché viola la trasparenza di locazione.\
Per gli IP basta usare un DNS, per la porta si usa un servizio port mapper, che ascolta sempre sulla stessa porta, e comunica le porte su cui ascoltano diversi servizi.

Affidabilità.

Ordinamento.

## Message Passing Interface (MPI)

È uno dei primi middleware (1994), pensato per scambiare messaggi tra i nodi di un cluster HPC in modo molto ottimizzato.
Progettati per essere semplici, pratici, efficienti, e portabili.

## External Data Representation

Diversi linguaggi su diverse macchine rappresentano i dati in modo diverso.
Serve un modo per rappresentare i dati in modo comune (marshaling/unmarshaling).

Il primo formato era XDR della Sun, ora i più comuni sono XML e json.
JSON è molto usato su web services REST. Mentre XML è richiesto dai servizi SOAP (lo schema va incluso in WSDL).

### Remote Object Reference

Per sistemi come CORBA serve un sistema cross-platform per rappresentare oggetti univocamente in un sistema distribuito.

Servono di sicuro ip e porta. Il tempo e la porta identificano univocamente il processo.
* 32 bit: IP
* 32 bit: porta
* 32 bit: time
* 32 bit: numero dell'oggetto
* Interfaccia dell'oggetto

Non va bene il metodo di CORBA, perché non rispetta la trasparenza di località. Ci sono soluzioni (proxy, informare dei cambiamenti) ma non sono ottimi.

## Comunicazione di gruppo

### Multicast

Lo conosciamo, non è molto supportato.

Utilizzerebbe UDP, che non ha garanzie sull'ordine e sulla ricezione.

### Overlay network

Abbiamo alcune macchine connesse alla rete pubblica. Quando devono comunicare, invece che "parlare" direttamente con il destinatario, ogni macchina parla solo con alcune macchina prestabilite, che inoltreranno il messaggio per farlo arrivare alla destinazione.
Questo aumenta la latenza ovviamente, ma permette di usare algoritmi di routing intelligenti per ottimizzare il traffico, o per implementare altre funzionalità avanzate.

Tecniche:
* Hash table distribuite
* P2P file sharing
* CDN
* molte altre...

Caso di studio, Skype (pre-microsoft):
* Skype nasce come applicazione VoIP p2p nel 2003
* È una rete p2p composta da nodi e super-nodi
* Quando il client si collega, esegue il login su un server principale, che assegna un super-nodo (a questo punto si può chiudere la comunicazione col server principale)
  * Dovrebbero essere scelti in base alla locazione, ma non è immediato stabilirla
  * I super-nodi possono essere "riallocati" se la localizzazione risulta sbagliata
* Tutto il traffico delle chat viene instradato attraverso i super-nodi con un loro algoritmo di routing
* I super-nodi sono dei normali client che vengono promossi a super-nodi in base a certi criteri
  * Se hai un IP pubblico, se hai una buona connessione, se stai collegato molto tempo, etc.
* Il traffico per questi nodi deve essere cifrato end to end, inizialmente non lo era
* Il video invece era diretto perché era pesante gestire il traffico video per i client