# Sottosequenza ripetuta

Dato un testo $T\in\Sigma^*$ vogliamo trovare la più lunga sottosequenza $\alpha$ ripetuta in $T$. Le ripetizioni possono essere sovrapposte.

Per molto tempo le soluzioni proposte sono state $O(n\log n)$. Anche Knuth pensava che fosse il lower bound, ma si sbagliava, è lineare.

Notazione:
* $T$ è il testo
* $T^i$ è un suo prefisso
* $T_i$ è un suo suffisso
* $\sigma(T)=\{T_j:j\in\{1...n\}\}$ è l'insieme dei suffisso

## Suffix trie

Consideriamo il $K(\sigma(T))$, chiamato *suffix trie di $T$* (non tree).\
Ho un'occorrenza di $\alpha$ in $T$ sse è il prefisso di un qualche suffisso di $T$.
Una stringa $\alpha$ occorre *due* volte sse è il prefisso di almeno due suffissi di $T$.

Cerchiamo il *più* lungo percorso che parte dalla radice e finisce in un nodo con almeno due figli. I sottoalberi di questo nodo sono liste, perché se ci fosse un altro nodo con due figli nei sottoalberi, il percorso più lungo finirebbe lì.
Trovato questo prefisso, continuando fino alla fine delle foglie trovo la posizione delle occorrenze.

Il prefisso non è necessariamente unico. Nel senso che ci possono essere più prefissi massimi, che sono diversi ma hanno la stessa lunghezza.

Grazie al suffix trie, se ho un pattern posso semplicemente controllarlo sull'albero è trovare tutte le sue occorrenze nel testo.

Se $K(\sigma(T))$ fosse piccolo (lineare) e lo sapessi costruire in tempo lineare, allora avrei una soluzione al problema della massima sottostringa ripetuta in $O(|T|)$.

$\sigma(T)$ è un insieme di $n$ stringhe distinte di dimensione $n$, ci sono davvero alberi con $O(n^2)$ nodi. Ci sono davvero stringhe il cui suffix trie è quadratico?
Si: $a^nb^n$. L'albero avrà un ramo di $n$ nodi $a$, e da ciascuno pendono $n$ nodi $b$.

Se voglio che ad ogni suffisso appartenga una foglia, il trucco è aggiungere un carattere esterno all'alfabeto $\$$ alla fine del testo.

Quando ho un ramo senza branching, potrei comprimerlo in un unico nodo memorizzando gli indici di inizio e fine del ramo.

## Suffix tree

Se vogliamo che l'algoritmo sia lineare, deve prima essere lineare anche la struttura dati.

> ***Teorema***:
> 
> Sia $T$ un albero con solo nodi branching. Allora il numero di nodi di $T$ è meno del doppio del numero di foglie.

Elimino in $K(\sigma(T))$ ogni sequenza del tipo $ua_1...a_ka$ in cui tutti i nodi $a_i$ (non $v$ ed $u$) sono non branching. Sostituisco la sequenza con $uv$, etichettando l'arco con $[i,j]$ che sono gli indici della porzione di testo coperta dai nodi $a_i$.

Questa struttura risulterà lineare nel senso che dobbiamo per forza mantenere anche il testo a cui fanno riferimento gli indici. Non posso buttarla via come facevo prima. (e non occupa spazio $O(n\log n)$ perché non stiamo usando un modello succinto).

Una volta confrontato un pattern $P$ con il suffix tree di $T$ posso sapere il numero e la posizione delle occorrenze all'interno del testo osservando il sottoalbero del nodo in cui finisce $P$.
Se il sottoalbero ha $m$ foglie (quindi il numero di occorrenze del pattern), allora ha meno di $2m$ nodi in totale, quindi scorrere questo sottoalbero è $O(m)$.

Se il suffix tree è stato costruito, il costo della ricerca di $P$ in $T$ ha complessità ottimale. Il costo è $O(|P|+c)$, dove $c$ è il numero di occorrenze di $P$.