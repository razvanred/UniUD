# Distanza approssimata tra stringhe

La ricerca esatta è inutile nel mondo reale, ci serve la ricerca approssimata. Possiamo portare sfruttare il lavoro fatto per la ricerca esatta, per quella approssimata?

La prima intuizione è che se abbiamo una stima di quanti errori occorrono, significa che abbiamo anche delle porzioni esatte. Gli algoritmi più veloci si basano sulla ricerca di queste porzioni esatte.

## Distanza tra stringhe
 
Per parlare di matching inesatto bisogna innanzitutto definire "distanza" tra stringhe
 
La definiamo quindi come il numero di operazioni necessarie per convertire una sequenza nell'altra. Le operazioni consentite sono: Match $m$, Insert $i$, Delete $d$, Substitute $s$. Ciascuna operazione ha un suo costo o score
 
Vediamo un esempio
 
$$ \begin{align}
 
 && a && c && g && t && c && a && t && c && a \\
i && m && s && m && m && s && d && m && m && m \\
t && a && a && g && t && g && \  && t && c && a
 
\end{align} $$
 
Qua la linea di mezzo è la stringa di operazioni ed è chiamata ==edit-string==, mentre quella sopra e quella sotto sono le due stringhe per le quali calcoliamo la distanza
 
Il miglior algoritmo noto per calcolare la distanza ha complessità $O(m\times n)$ dove $m$ ed $n$ sono le lunghezze delle due stringhe
 
Il costo delle varie operazioni va scelto e ci sono diverse maniere per farlo, e non tutte danno un costo costante
 
Lavoreremo con l'assegnamento di costi più banale, ossia quello che da costo $0$ al Match e costo $1$ a tutte le altre operazioni
 
> [!abstract] Distanza di Levensthein
> 
> Minimo numero di $i,d,s$ per convertire una stringa in un'altra
> 
> Tipicamente indicata con $d_L(\sigma_1,\sigma_2)$
 
> [!abstract] Distanza di Hamming
> 
> Minimo numero di sostituzioni per convertire una stringa in un'altra
> 
> Tipicamente indicata con $d_H(\sigma_1,\sigma_2)$
> 
 
 
## Allineamento di sequenze
 
Parleremo di ==allineamento globale==, ovvero il matching di due stringhe nella loro interezza, e di ==allineamento locale==, che matcha tutta la prima stringa ad una porzione della seconda
 
Più intuitivamente l'allineamento globale è il calcolo della distanza (ovvero della [[String Matching#Distanza approssimata tra stringhe|edit-string]] ottimale). Invece l'allineamento locale chiede di trovare la sottostringa di $T$ la cui distanza è minima da $P$
 
In poche parole l'allineamento locale utilizza quello globale come subrutine
 
### Allineamento globale
 
Chiamiamo $\eta$ la nostra edit-string. Partiamo da un algoritmo esponenziale che verrà migliorato poi dalla [[Programmazione Dinamica|programmazione dinamica]]
 
```
allineamento_exp(s1,s2,i,j) {
	if i==0 or j==0 return i+j
	if s1[i] == s2[j] then
		cm <- allineamento_exp(s1,s2,i-1,j-1)
	else
		cs <- allineamento_exp(s1,s2,i-1,j-1) +1
	ci <- allineamento_exp(s1, s2, i-1, j) +1
	cd <- allineamento_exp(s1, s2, i, j-1) +1
	return min(cm,cs,ci,cd)
}
```
 
Qua $cm, cs, ci, cd$ rappresentano la scelta di operazione per il prossimo step
 
Vediamo che questo algoritmo fa una quantità esponenziale di chiamate ricorsive alterando $i,j$ nell'algoritmo. Però esistono solo una quantità quadratica di coppie $i,j$ diverse, pertanto memorizziamo chiamate già fatte e poi le ritorniamo direttamente quando vengono chieste nuovamente