# String matching

Noi studieremo partendo da algoritmi per la biologia

Knuth: "My favourite way do define CS is to say that is the theory of algorithms".

Il problema è che non c'è una buona definizione di algoritmo, tutte quelle che abbiamo visto non sono ben precise su alcuni aspetti, un po' vaghe.
Come si fa quando non si sà qualcosa

Spesso si dice che un algoritmo deve terminare, però questo ad esempio esclude i sistemi operativi, che sono di per se dei grandi algoritmi.

## Overview

> ***Problema***: String matching *esatto*
>
> Definizioni:
> * $\Sigma$ è un alfabeto (per noi sarà $\{a,c,g,t\}$)
> * $\Sigma^*$ è la collezione delle stringhe finite su $\Sigma$
> * $P,T\in\Sigma^*$ sono due stringhe che chiameremo "pattern" e "testo"
> * $|\Sigma|=\sigma$ è una costante fissata a priori, la consideriamo $\sigma\in O(1)$
> * $|T|=m$
> * $|P|=n$
> * $S[i]$ indicizza una stringa (da 1)
> * $S[i,j]$ è una slice
>
> Produci tutte le occorrenze esatte di $P$ in $T$. (Esistono anche le occorrenze "approssimate")
>
> ***Definizione formale***:
> Input $P,T\in\Sigma^*$\
> Output $\{i\in[1,n]:T[i,i+n-1]=P\}$

* Ha una soluzione?
* È un lower bound?
* Esiste un lower bound?

Algoritmo naive $O(nm)$ (quadratico):
```
for i in 1..m-n {
    for j in 1..n {
        if T[i+j-q] != P[j]{
            break
        }
    }
    if j == n{
        match
    }
}
```

Questo è un upper bound.\
$O(m+n)=O(m)$ è il lower bound (lineare), perché bisogna almeno leggere tutto l'input.

Esistono algoritmi sub quadratici, e lineari? Sì.

L'idea è che dopo che ho fallito il match non riparto da zero, ma riposiziono il pattern e riprendo da "metà match".

Diciamo che ho già tentato di fare il match di $P[1,j]$ e al passo dopo devo ricominciare. Se avessi preprocessato il massimo $a$ per cui $P[j-a-1,j]=P[1,a]$ (prefisso del pattern e suffisso della parte processata). Allora potrei continuare il match dalla stessa posizione di $T$, e dalla posizione $a$ di $P$.
Questa scansione è lineare, ma qual è la complessità preprocessing di $P$?

Il primo metodo per il preprocessing non era lineare, ma lo era nella dimensione del pattern che è molto più piccolo.