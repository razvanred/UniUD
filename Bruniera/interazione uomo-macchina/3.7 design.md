# Design

What is design? "Design is to design a design to produce a design", John Heskett

La parola design è molto ambigua, anzitutto è sua sostantivo che verbo.
Come verbo significa: disegnare, ideare, creare, eccetera.

Si può avere una visione ingegneristica o artistica sul design, anche sulle interfaccie utente ci sono filosofie di pensiero da entrambe le visioni.

Sono spesso molto richiesti designer "artisti" che producano le interfaccie, per evitare di avere siti tutti uguali e noiosi.
Ma ovviamente non si può avere siti radicalmete diversi l'uno dall'altro, altrimenti non potremmo avere interfaccie unificate.
L'ideale è quello di far comunicare i due mondi.

| Artista | Ingegnere |
| --- | --- |
| ispirazione orizzontale | soluzioni top-down |
| soluzioni contingenti | soluzione universale |
| causare riflessioni e provocazioni | fornire strumenti di risoluzioni |
| ambiguità | certezza |
| estetico ed emotivo | logico e razionale |
| esperienza soggettiva | sperimentare e spiegare |

Se dovessimo fare interfaccie solo pe astronauti, questi discorsi sarebbero inutili, loro soo disposti ad utilizzare interfaccie completamente non intuitive.
L'interfaccia con cui sono andati sulla luna prevedeva di selezionare un verbo (ad esempio "chidere") ed un sostantivo (ad esempio "pannelli") premendo un tasto con scritto verbo o sostantivo, e poi digitando il numero che rappresenta quello che vogliamo.

## User centered design

Metodo di design che da all'utente la sensazione che l'inerfaccia sia stata sviluppata per loro.

Design Partecipato: Un altro metodo, usato specialmente in Scandinavia, in cui gli utenti fanno parte del team di sviluppo dell'interfaccia, per avere un feedback immediato sulla qualità dell'interfaccia.
È scomodo da gestire ed organizzare quindi molto raro, soprattuto in Italia, ma è potenzialmente molto efficace.

Processo di design di un sistema interattivo:
* Obbiettivi
  * Spesso il commissionante non è l'utilizzatore finale del software, quindi fare quello che chiede (riguardo l'usabilità) è sbagliato
  * Bisogna andare sul posto e capire cosa vogliono gli utenti finali
* Analisi
  * Scoprire che task (compiti) devono svolgere gli utenti mediante il nostro software
* Progetto
* Sviluppo e distribuzione

## Analisi

### Personas

Dato che ascoltare cosa ha da dire il manager riguardo l'interfaccia è stupido, andiamo a parlare con i dipendenti, per capire cosa vogliono e come gli piace.
Per facilitare il design, si separa l'userbase in Personas, dei prototipi di utenti basati sull'utenza reale del nostro software.
Durante la progettazione ci si interroga su cosa vorrebbero queste figure in diversi scenari tipo.

### Task analysis

Dobbiamo capire come strutturare un interfaccia perché l'utente riesca a portare a termine i suoi compiti utilizzando il nostro programma.

Quindi elenchiamo le Attività dell'utente e le separiamo in sottoattività, producendo un albero di task che l'utente può svolgere.

A questo punto dobbiamo capire che input ebisogna dare al programma per svolgere le varie operazioni, coinvolgendo gli utenti in dei workshop per capire il modo migliore.

Non ci sarà una sola soluzione, e dipenderà da quali utenti rispondono, si possono supportare entrambi i metodi per aiutare entrambi i tipi di utenti (quando possibile).
Ad esempio, per la task "salvare un file" un utente inesperto suggerirà un tasto, un altro utente suggerirà ctrl+c.

Un altro esempio in cui non si riesce a soddisfare tutti è programmazione di un forno.
Possiamo impostare inizio e fine, inizio e durata, fine e durata. Facciamo provare a diversi utenti ed otterremo risposte diverse.
In questo caso le opzioni vanno in conflitto, quindi si sceglierà solo l'opzione supportata da più utenti.

Si possono usare dei progammi specifici per progettare  questi alberi di task, come CTTE o XMind

### Scenari/Casi d'uso

Si tratta di delle situazioni tipo in cui dobbiamo immaginare il comportamento di un utente.
Una buona idea è disegnarli come un fumetto o comunque una storyboard, come se stessimo scrivendo una sceneggatura, solo che la storia non è lineare.

È utile sia per capire meglio come verrà utilizzato il nostro sistema, sia da mostrare all'utente. Possiamo fargli vedere le card e capire come agirebbe sull'interfaccia.

Non bisogna esagerare con gli sforzi nella produzione degli storyboard, sono fatti per essere buttati via quando l'utente dice che non gli vanno bene.
Facendoli alla svelta possiamo permetterci di cambiarle velocemente e senza investire troppo tempo e soldi nella produzione di un'interfaccia che sarà scartata.

## Progettazione

### Scenari/Casi d'uso

Il coinvolgimento dell'utente nel test dell'interfaccia attraverso scenari fa parte della prototipazione tipica dell progettazione

### Mock-up

È praticamente un prototipo a basso costo, con materiali di bassa qualità e meno curati. L'idea è di avere velocemente un idea di come potrebbe venire un dispositivo o di un interfaccia da far vedere agli utenti per sapere cosa ne pensano.

Non si tratta di un prodotto che funziona veramente, è solamente un "segnaposto" per avere qualcosa di materiale da far vedere.

A noi interessa fare prototipi di interfacce più che di dispositivi, e per questo abbiamo dei software per la prototipazione di interfacce.
Sono anche molto dettagliati, ma non producono programmi, sono giusto per far vedere agli utenti un idea del funzionamento

Inizialmente erano solo degli editor grafici personalizzati, poi si sono evoluti.

[Elenco di programmi sulle slide]

Bisogna anche in questo caso, come con gli scenari, bisogna evitare di esagerare con i dettagli e perdere troppo tempo in un prototipo che verrà scartato.

---

In questa fase di progettazione dobbiamo applicare i principi di utilizzabilità che abbiamo già visto per produrre dei prototipi.
Quindi aggiungere maggiori dettagli su come inserire gli input delle task, non solo su che input devono avere.

Principi di usabilità:
1. Dialogo semplice e naturale
2. Parla il linguaggio dell'utente
3. Minimizza il carico mentale dell'utente
4. Corenza agli standard
5. Fornire feedback e visibilità dello stato del sistema
6. Fornire uscite chiaramente indicate (undo)
7. Efficienza e flessibilità
8. Buoni messaggio d'errore
9. Prevenire gli errori
10. Fornire aiuto e documentazione

Si ha molto spazio per la creatività, ma anche la possibilità di scegliere tra le interfaccie statisticamente più di successo della storia, rinunciando completamente alla creatività.

Esistono delle guidlines che stabiliscono dei suggerimenti su comeprogettare disegnare un'interfaccia in modo che tutti i programmi siano coerenti tra di loro.

Le prime guidelines sono state prodotte dal MITRE nell'86 perché all'epoca tutti i programmi che utilizzavano le società governative americane erano completamente incoerenti tra di loro.
Per uniformarle tra di loro.

Con linee guida come queste si possono prendere dei programmatori che non hanno mai studiato niente di HCI, dargli in mano le linee guida e dirgli di seguirle alla lettera.
Dal punto di vista ingegneristico è una proposta interessante, otteniamo programmi tutti coerenti e tutti perfettamente utilizzabili.
Dal punto di vista "artistico" non è una buona cosa perché alla fine tutti i programmi risultano uguali e noiosi.

Una pietra miliare sono le linee guida di Apple de l'92, aggiornate qualche anno dopo. Seguendo il loro esempio Microsoft (un po' in ritardo, nel '98) ha pubblicato le sue, anche se un po' striminzite.
Interfaccie di questo tipo servono per uniformare le applicazioni per la stessa piattaforma, lasciando comunque un po' di spazio per la creatività senza violare le indicazioni.
Non ha senso seguire le interfaccie di un sistema facendo applicazioni per un altro, dovremmo, inveve, prima di sviluppare un programma per un sistema, controllare se hanno rilasciato delle linee guida e seguire quelle.

Un altro livello di linee guida, dopo quelle generali e quelle della piattaforma, sono quelle specifiche per il tipo di applicazione.
Ad esempio IBM ha sviluppato delle linee guida per le applicazioni 3D d'ufficio, in questo modo, se qualcuno vuole imbarcarsi in un progetto di sviluppo di una particolare applicazione abbiamo in indicazione di cosa funzione per applcazioni di questo tipo.

Riguardo le piattaforme recenti sono disponibili linee guida per:
* Apple Himan Interface Guidelines for MacOs 2009 2020
* Microsoft Windows UI Design Guidelines 2010 2020
* GNOME Human Interface Guidelines 2010 2020
* ANDROID User Interface Guidelines 2010 2020
* iOS Human Interface Guidelines 2009 2020

Interessantemente, negli ultimi anni le linneguida di Apple lasciano un po' a desiderare mentre quelle di Microsoft sono diventate molto sofisticate
Anche se inizialmente la situazione era al contrario.

Durante la produzione della nostra interfaccia è una buona idea creare dei prototipi per testarli, darli in mano agli utenti, ed eventualmetne tornare alla fase di progettazione.
Vedi le tecniche precedenti (scenari d'uso e mock-up) per la prototipazione.

### ISO 9241

È uno standard internazionale formale sull'usabilità dei dispositivi.
Si occupa sia dell'aspetto hardware che dell'aspetto software dell'interfaccia e la disposizione degli elementi nello schermo.

Alla fine dicono le stesse cose delle altre linee guida generali e parte di quello che dicono le linee guida per le piattaforme.
Però è internazionale e standard.

Si può chiedere ad una commissione di validare e certificare il proprio prodotto, per poter mettere il bollino che indica che rispettiamo gli standard.
Non è necessario, e visto che costa e gli utenti non sanno cosa sia, non viene fatto da nessuno, ma se servisse si può fare.

Negli anni pià recenti è stato prodotto un nuovo standard per i dispositivi multimediali, ma l'idea è la stessa.

### Protitipazione

L'idea è di ciclare pià volte tra una fase di analisi, progettazione, e prototipazione.
Quindi dopo ogni test del prototipo tornare in fase di analisi, riprogettare l'interfaccia, produrre un nuovo prototipo e testarlo.

Ci sono diversi modi di mettere in atto questa prototipazione e dipendono da cosa vogliamo fare e dal progetto che abbiamo.

## Sviluppo e distribuzione

Ad un certo punto finiamo le risorse a disposizione per ciclare. A quel punto si esce dal ciclo e si rilascia il prodotto.
Per evitare di finire le risorse prima del tempo, si mettono tutti i problemi in ordine di priorità, correggendo per primi quelli più gravi.

Spesso le aziende rilasciano il prodotto dopo pochi cicli indipendentemente di cosa è stato già implementato. Se ne fregano dell'importanza dei problemi e pensano che risolveranno più avanti.
Ovviamente vogliamo farlo il meno possibile.

Le specifiche che abbiamo prodotto a questo punt odiventano le specifche finali del prodotto, salvo futuri aggiornamenti.

### Documentazione ed help

Le informazioni di Help e la documentazione devono essere prodotte durante lo sviluppo, non alla fine, ma quelle che abbiamo in mano alla fine sono quelle che verranno date all'utente finale.

È utile avere una checklist di quello che si deve inserire nella documentazione per avere un help funzinale:
* Esplorazione
  * Cosa posso fare con questo sistema?
  * In questa sezine è utile inserire dei tutorial del sistema
  * È tipico dei videogiochi, ma non solo
* Definizione/descrizione
  * Cosa fà questo strumento?
  * Si tratta dei tooltip
  * Spesso sono dei piccoli fumetti che compaiono quando posizioniamo il mouse sopra un tasto, devono essere scritti bene
  * Alcuni programmi vecchi avevano il tasto "?" che si trascinava sopra pulsanti o altre parti dell'interfaccia per visualizzare il tooltip
* Svolgimento dei compiti
  * Come faccio a fare questo?
  * Gli utenti inesperti adorano i wizard, procedure guidate pre-baked per non dover navigare tra infiniti parametri complicati
  * Altrimenti si possono avere delle funzioni di insegnamento che utilizzando degli highlight ti mostrano come fare le cose da te, senza bloccare l'interfaccia
* Diagnostica
  * Com'è successo questo?
  * L'interfaccia deve andare a controllare i parametri e le variabili per indicare all'utente cosa ha portato alla situazione attuale
  * Ad esempio: se la stampa viene in bianco e nero e ho selezionato a colori, il software deve indicare che ho finito l'inchiostro
* Indicazione di stato
  * Dove sono?
  * L'interfaccia mi dà sempre un'indicazione di dove sono e cosa sto facendo, se sono in un sottomenù, che menù ho aperto prima, eccetera

## Usabilità

Che cos'è l'usabilità? Ci sono modo diversi di vederla:
* Aumenta l'efficienza e la produttività
* Riduce gli errori, aumenta la sicurezza
* Riduce il tempo di apprentimento
* Riduce il bisogno di supporto, aumenta l'accettazione (da parte degli utenti)
* Aumenta le vendite ( ° ͜ʖ °)

Secondo lo standatd ISO:
* La misura in cui un prodotto può essere usato da utenti specifici per raggiungere obbiettivi specifici con efficacia, efficienza e soddisfazione in un certo contesto d'uso
  * Efficiacia: l'accuratezza e completessa con sui gli utenti possono raggiungere gli obbiettivi in ambienti particolari
  * Efficienza: le risorse spese in relazione all'accuratezza e completezza degli obbiettivi raggiunti
  * Soddisfazione: il comfort e l'accettabilità del sistema di lavoro per i suoi utenti e le altre persone influenzate dal suo uso
    * Nel caso della solita siringa elettronica gli utenti sono gli infermieri, e le persone influenzate sono medici, pazienti, manutentori, direzione, ...
    * I medici vogliono massimizzare efficienza e minimizzare l'errore (ed altre idee sull'interfaccia)
    * I pazienti vogliono minimizzare l'errore e massimizzare il comfort (dolore, rumori, etc) e l'efficacia
    * I manutentori vogliono riparabilità
    * Gli infermieri vogliono usabilità ed accettazione (non vogliono una machina che si comporti in modo diverso da tutte le altre macchine di questo tipo)
    * La direzione vuole massimizzare l'efficienza in termini di costi (monetari e di manutenzione) ed efficacia (se la macchina non funziona, costa nel lungo termine)
    * I familiari del paziente vogliono massimizzare il loro comfort psicologico (la macchina deve essere rassicurante) e l'efficacia (vogliono che il paziente guarisca, più del comfort e del costo)
    * Sono tutti stakeholder

### Modello di Normal

Ampliamo il modello del model human processor, che divideva il modo di interaggire in funzioni del sistema percettivo, cognitivo e motorio.

Ci interessa perché ci permette di dividere i problemi in categorie e scegliere come affrontarli.

Il modello passa dalle 3 fasi che conosciamo a 7, che vengono ciclate continuamente:
* Esecuzione (utente $\rightarrow$ computer)
  * Obbiettivo
    * L'utente vuole fare qualcosa (non necessariamente col computer)
    * Non ha ancora deciso come farlo
    * Es: Vuole annotare/evidenziare/rimarcare/etc una frase da un PDF che sta leggendo
  * Intenzione
    * Sceglie come fare per raggiungere l'obbiettivo
    * Non ha ancora in mente l'azione precisa
    * Es: Decide di evidenziare la frase usando il programma PDF che ha davanti (può metterla in grassetto, colorarla, etc)
  * Azione
    * In base a cosa offre l'interfaccia sceglie l'azione per realizzare l'intenzione
    * Es: Vede un ellisse gialla che suggerisce "evidenziare" e decide di cliccarla per evidenziare in giallo
  * Esecuzione
    * Esegue l'azione
    * Es: Clicca la famosa ellisse gialla
* Valutazione (utente $\leftarrow$ computer)
  * Percezione
    * Dopo avere elaborato, la macchia produce un feedback che viene percepito dall'utente
    * Es: Vede un fumetto giallo affianco alla frase che voglio evidenziare
  * Interpretazione
    * Cerco di capire il feedback che ho percepito
    * Es: Voleva evidenziare, non è successo, forse l'ellisse gialla significava "aggiungere una nota"
  * Valutazione
    * Mi chiedo se ho raggiunto l'obbiettivo
    * Es: No. Non hai evidenziato la frase
  * (obbiettivo)
    * Se ho raggiunto l'obbiettivo, cambia, altrimenti posso riprovare o cambiare obbiettivo
    * Es: Vuole ancora evidenziare, riprova
    * Es: Non riesce ad evidenziare, non cerca più di farlo

Assumiamo che un utente ha un problema con la nostra interfaccia, in base al livello a cui si verifica decidiamo cosa fare per risolverlo:
* Obbiettivo
  * L'obbiettivo non è supportato (problema di modello mentale)
    * Non dovrebbe dare l'idea che sia supportato
    * Dovrebbe supportarlo
* Intenzione
  * L'obbiettivo c'è, ma formula l'intenzione sbagliata
    * È sempre un problema di modello mentale, ma più leggero perché comunque la cosa si può fare, solo in modo diverso
* Azione
  * L'utente non capisce come deve fare per realizzare l'intenzione
    * Problema del sistema cognitivo
      * Dobbiamo rivedere il linguaggio dell'interfaccia
* Esecuzione
  * L'utente sa cosa deve fare, ma ha difficoltà a farlo (es: icona da cliccare troppo piccola)
    * Bisogna migliorare l'accessibilità del programma
* Percezione
  * Viene dato un feedback insufficiente (es: mentre stai evidenziando aspetta che finisci per mostrare l'evidenziatura, l'utente riprova dall'inizio)
    * Bisogna rendere il feedback più efficace
* Interpretazione
  * L'utente non capisce il feedback (es: cliccando compare un pennello per dipingere la frase, l'utente non capisce a cosa serve)
    * Dobbiamo rivedere il linguaggio dell'interfaccia
* Valutazione
  * È difficile che si verifichi, magari quando ci sono tanti dati che non stanno nello schermo, l'utente potrebbe perderesi dei cambiamenti e non riuscire a valutare
    * Devo fare in modo che l'interfaccia richiami all'attenzione il cambiamento

I due emicicli "Esecuzione" e "Valutazione" (le freccie nel modello di Normal) sono chiamate golfi, e separano quello che è in testa all'utente, da quello che viene comunicato all'utente.
Quanto più sono distanti (è alto il golfo), tanto più i linguaggi di macchina ed utente si discostano.

### Mapping

Se fossimo tutti programmatori, ed interagissimo con l'interfaccia cambiando i valori delle variabili il golfo di esecuzione sarebbe 0, l'utente ragiona come il computer. Non è un caso realistico.
Quindi, abbiamo sempre un golfo di esecuzione, vogliamo avvicinare il modo di pensare dell'utente al modo di presentare le opzioni della macchina.

Un modo per abbassare questo golfo è chiamato Mapping: Vedere il modello che ho in mente sull'interfaccia.

Un classico esempio di mapping è quello del fornello a gas.
La classica inerfaccia di un fornello a gas vede 4 fornelli (in quadrato) e 4 manopole (allineate), ciascuna associata ad un solo fornello.

Ogni manopola ha un classico disegnetto che indica quale dei fornelli accende (Sapete quale disegnetto), e a tutti capita di avere bisogno di controllare i disegnetti ogni tanto, anche dopo anni di utilizzo del fornello.
Questo significa che abbiamo un golfo, l'interfaccia non parla il mio linguaggio.

Come possiamo migliorare il mapping?
* Disporre le manopole in un quadrato e non una linea, così corrispondono ai fornelli
  * Occupa molto spazio
  * I fornelli ad induzione spesso non hanno manopole, hanno slider touch. Possono essere disposti in questo modo senza occupare troppo spazio, e viene fatto
* (qualcuno suggerisce di lasciarle orizziontali e usare un ordinamento più logico, ovviamente non cambia niente)
* Posizionare ogni manopola affianco al proprio fornello
  * È poco agibile, le manopole sono vicino al fuoco e quelle dietro sono difficili da raggiungere, altrimenti serve tanto spazio
* Disporre i fornelli in linea come le manopole
  * Si fa ogni tanto, funziona bene, si ottiene un piano più largo che lungo

Un altro caso in cui si presenta il problema del mapping è quello degli interruttori della luce.
In casi in cui ci sono sale molto grandi con molte luci (come teatri), a volt vengono posizionati gli interruttori direttamente su una pianta del teatro, in corrispondenza delle luci che accendono.

## Valutezione dell'usabilità

Abbiamo in mano un prototipo od un prodotto finale, qualsiasi cosa. Vogliamo sapere cosa ne pensa l'utente.

Cosa valutiamo?:
* Elementi iniziali di progettazione
* Protitipi
* Prodotti finali

Scopo della valutazione:
* Formativa:
  * Viene fatta soprattutto nelle fasi iniziali
  * Dà forma al progetto ed all'interfaccia
* Riassuntiva:
  * Viene fatta nelle fasi finali per sapere come è venuto il risultato
  * A volte si fà anche proprio sul prodotto finale
  * A volte si fà per motivi contrattuali ("un utente deve inserire un ordine in 30 secondi", testalo)
  * Serve a capire se per avviare gli utenti finali all'uso serve uan procedura particolare (una qualche formazione dell'utente)
  * A volte si fà per sapere cosa migliorare alla prossima versione

Approcci:
* Ossservazione degli utenti (osservo i comportamenti)
  * In laboratorio
  * Sul campo
  * In remoto
* Feedback degli utenti (chiedo agli utenti cosa pensano, pensieri non comportamenti)
  * Interviste
  * Questionari
  * Focus group
  * Diari
* Modelli (descrizioni astratte dei sistemi)
  * Prevedere le caratteristiche del sistema senza coinvolgere gli utenti
  * Coinvolgere gli utenti costa
  * Si usano tecniche analitiche che su alcune cose non funzionano, ma quando funziona, si può evitare di chiamare gli utenti
  * Se sbagli in bomba i colori di un interfaccia (testo grigio chiaro su sfondo bianco sporco) non serve una persona per dirtelo
* Ispezione da parte di esperti (valutazione analitica senza utenti)
  * Tecniche basate su regole o cammini
  * Si chiede ad esperti e non utenti, bastano pochi esperti, mentre di utenti servono centinaia

### Osservazione degli utenti

Dove facciamo questa osservazione?
* In laboratorio
  * Abbiamo una stanza adibita alle valutazioni sugli utenti
  * Convochiamo le persone in laboratorio e osserviamo mentre utilizzano il prodotto
  * Più comodo per noi, ci permette di tenere la situazione sotto controllo
  * Perde la naturalezza dell'utente, meno realistico il risultato, soprattutto se il software è molto personale (immagina che Netflix ti chiami per far finta di metterti a guardare serie in un loro laboratorio)
    * A volte usano anche gli specchi one-way per farti sentire meno osservato
    * È difficile che tu sia registrato *a tua insaputa* se sei in un laboratorio di usabilità, comunque devi firmare un consenso che dice che *potresti* essere registrato
* Sul campo
  * Andiamo noi dall'utente
  * Più scomodo e costoso per noi, gli spostamenti possono anche essere molto lunghi
  * Non abbiamo più tutto sotto controllo, l'osservazione viene interrotta da distrazioni
  * Questa è più realistica, l'utente è più naturale. Comunque Gli utenti possono sentirsi osservati e perdere parte della naturalezza (un tizio di Netflix viene in casa tua e ti guarda guardare serie o ti mette una telecamera), però man mano si abbitua
  * Se registrassimo le persone a loro insaputa otteremo la massima naturalezza
    * Non è particolarmente legale
    * Lo facevano nei supermercati con gli specchi one-way

Come organiziamo il test? Dobbiamo decidere:
* L'obbiettivo del test
  * Sembra banale, ma determina cosa conviene far fare all'utente
  * Perché voglio fare questa specifica valutazione?
* La durata del test
  * Le persone hanno dei limiti dell'attenzione
  * Non possiamo far usare per troppo tempo e chiedere troppi questionari
  * Si scelgono quelli più significativi
* Caratteristiche hardware e software
  * Se sto testanto un nuovo dispositivo non abbiamo molto da scegliere
  * Se sto testanto un software per una particolare piattaforma devo valutare su che hardware verrà utilizzato (pc nuovo/pc datato/tablet/iPad/...)
    * Stesso discorso se deve funzionare insieme ad altri software
  * Ha senso provare un software su dispositivi di diversa natura
* Le condizioni iniziali
  * Tutti gli utenti devono essere nelle stesse situazioni iniziali, per evitare influenze esterne sul risultato
* Gli utenti
  * Dobbiamo scegliere i tester perché rispecchino il target di utenti finali
* Il numero di utenti
  * Banalmente più sono meglio è, però siamo limitati dal budget e dalla gestione dei dati (prova a testare 100000 persone, non basta una mattinata)
  * In genere si dice di provare su **almeno** 10 utenti
    * Rappresentativi degli utenti finali
* I compiti che gli utenti dovranno compiere
  * Si devono scegliere dei compiti rappresentativi dell'utilizzo finale del sistema
  * Diamo lo stesso compito a tutti gli utenti
* Criteri di correttezza dell'esecuzione dei compiti
  * Come valutiamo se è stato portato a termine con successo il compito
* I comportametni osservati
  * Cosa dobbiamo notare nei comportamenti
  * Possibilmente vogliamo dei parametri quantitativi
    * Tempo (software per la produttività)
    * Numero di click
    * numerodi compiti completati in un tempo
    * Rapporto tra interazioni corrette ed errori
    * Numero di compiti svolti
    * Rapporto tra numero di utenti che hanno scelto la strategia migliore e che non l'hanno scelta
    * Tempi di attesa in cui l'utente cerca di capire come procedere
    * Frequenza di uso dei manuali
  * Dipende dall'obbiettivo del software, per esempio la maggior parte delle metriche di sopra non hanno senso per valutare un videogioco
* Se abbiamo più condizioni da confrontare (versioni diverse dell'interfaccia, interfaccia della concorrenza, etc)
  * Between subjects
    * Ogni utente è assegnto ad una sola condizione analizzata
    * Confrontiamo i risultati degli utenti assegnati ad una condizione con quelli assegnata alle altre
    * Richiede meno tempo per utente
    * Servono più utenti (almeno 10 per condizione)
    * Non subisce l'effetto di apprendimento
    * I gruppi devono essere omogenei
      * Non devono esserci differenze importanti tra i gruppi che potrebbero influenzare i risultai del test
      * Ad esempio dobbiamo distribuire l'età degli utenti
        * Distribuiamo anche genere, competenza tecnica, esperienza precedente, ...
  * Within subjects
    * Ogni utente è osservato in ciascuna condizione
    * Confrontiamo i risultati di ogni utente nelle diverse condizioni
      * Magari chiediamo a lui quale è migliore
    * Richiede molto tempo
    * Richiede meno persone (almeno 10, e basta)
    * Ha il difetto dell'effetto di apprendimento
      * Dopo il primo tentativo di completare un task gli altri andranno meglio perché apprende
      * Dopo il primo tentativo di completare un task gli altri andranno peggio perché si stufa
      * Soluzioni a questo problema:
        * Soluzione facile: Cambiamo l'ordine delle operazioni per bilanciare l'apprendimento tra gli utenti
          * Proviamo tutte le permutazioni di compiti
          * Si annullano tra di loro gli apprendimenti
        * Soluzione difficile: Scegliere compiti diversi per ogni condizione per vanificare l'apprendimento del tentativo precedente 
          * Es: trova le mascherine più economiche, trova le scarpe da trekking più economiche, ...
          * Si devono scegliere compiti con la stessa difficoltà

Si possono trasformare le considerazioni appena viste in un esperimento controllato, su cui ragionare con il metodo scientifico:
* I soggetti:
  * Devono essere rappresentativi dell'utenza generale ed in numero sufficiente
* Le variabili:
  * Indipendenti; Sono i valori che vogliamo provare, bisogna provare tutte le possibili combinazioni 
    * Le combinazioni aumentano esponenzialmente, limitatele
  * Dipendenti; sono l'elemento che andiamo a studiare
    * Sono quelle che misuriamo dall'utente, misuriamo in che modo le variabili indipendenti influiscono su quelle dipendenti
* Le ipotesi
  * Quello che vogliamo dimostrare con l'esperimento
  * Deve essere formulata prima di misurare le variabili dipendenti
* Procedura sperimentale
  * Prima di cominciare dobbiamo buttare giù la procedura precisa da seguire
    * Anche le frasi devono essere prestabilite (amichevoli con tutti, robotici con tutti)
  * Non dobbiamo mai uscire dalla procedura
* Analisi statistica
  * Bisogna valurare in che misura i risultati sono dovuti al caso per sapere se la qualità del responso è buona
    * Se un test che prevede il sesso del nascituro ha una precisione del 50% tanto vale lanciare una moneta
  * Non dobbiamo decidere noi dei test statistici speciali, usiamo quelli già forniti da alcuni strumenti come excel, od altri strumenti apposta per l'analisi statistica
    * Esempi:
      * Se chiediamo agli utenti quale interfaccia è meglio, contiamo cosa rispondono e calcoliamo il $\chi^2$ che ci dice la probabilità di ottenere per caso quel risultato
      * Se misuriamo quanto tempo ci mettono con due interfaccie si fa il T-Test
      * Abbiamo delle soglie di quanto vogliamo che sia dovuto al caso, 5% solitamente, 1% in contesti medici, non si scende mai tanto più giù di così

### Feedback dell'utente

È un'altra tipologia di valutazione che si basa non sull'osservare come si comporta l'utente, ma sul fare delle domande a quest ultimo.
Esistono diversi approcci per questa tecnica.

Approcci:
* Feedback informale
  * È l'unico di cui non c'è niente da dire, perché è l'unico informale
* Questionari
* Interviste
* Focus group

#### Questionario

Sono molto utilizzati perché non richiedono di assistere l'utente per la compilazione, quindi è facile farli compilare a molte perosone in poco tempo.

Il rischio è che se il questionario è fatto male il risultato viene sbagliato. Se possibile utilizziamo questionari standard, non inventiamoli.
Se serve per forza inventarlo dobbiamo farlo bene:

Tipi di questionari:
* Risposte categoriali
  * Singole (radio button)
  * Multiple (checkbox)
* Domande a scala di risposta
  * "Quanto sei daccordo?"
    * Sono dei radio button con una scala
    * Viene chiamata scala di Likert
    * È importante se sono pari o dispari
      * Se sono dispari consentite all'utente di mettersi in una posizione neutra
      * Se sono pari costringiamo l'utente a schierarsi in un lato
      * Non è ne bene ne male, bisogna considerarlo quando decidiamo
    * È importante il numero
      * Se sono pochi costringi l'utente a schierarsi parecchio
      * Se sono troppi rischi che gli utenti considerino i voti in modi diversi e il risultato si distribuisca troppo
  * "Cosa ne pensi di ___?: fantastico, ..., terribile"
    * Si chiama differenziale semantico
    * È una scala di Likert con agli estremi due aggettivi opposti
    * Valgono le stesse considerazioni di prima
* Ranking
  * Domande in cui si chiede di mettere in ordine alcuni elementi
    * Hai provato più sistemi, mettili in ordine dal migliore al peggiore
    * Hai provato diverse funzionalità di un sistema, mettile in ordine di importanza
  * Si può decidere di permettere pareggi e mettere più item nello stesso livello
    * Come per i differenziali, dipende se vogliamo costrigere gli utenti a schiararsi
* Risposte aperte
  * "Cosa ne pensi di ___?"
    * Hanno un valore notevole, permettono di catturare tutti gli aspetti che non avevamo previsto nei questionari
    * Ovviamente richiede tempo l'elaborazione del questionario, non possiamo lasciare al computer il compito di estrarne le informazioni
    * Spesso gli utenti non si impegnano abbastanza in questo tipo di domande

Un esempio classico di questionario è il QUIS, uno dei primi questionari di usabilità, pensato per essere generale ed applicabile per qualsiasi sistema.
È abbastanza lungo e contiene elementi tipici del periodo in cui è stato sviluppato (è abbastanza vecchio). Non è più molto usato, ci sono opzioni più moderne.

Una variante più moderna è il SUS (system usability scale), pensato per essere un test veloce, è composto di solo 10 domande.
Sono tutti differenziali semantici da Strongly disagree a Strongly agree.

#### Self-report

È problematico richiedere agli utenti di presentarsi da noi per compilare un questionario, quindi si sceglieva di inviare a casa degli utenti il questionario per posta (self-report).
Putroppo molti degli utenti non sono disposti a svolgere il questionario, quindi lo ignorano e basta.

Una tecnica per far tornare indietro più sondaggi è offrire degli incentivi, come degli sconti sui prodotti, per chi compila il questionario.

Adesso è molto più facile svolgere questi sondaggi online insereno il questionario sul proprio sito, od affidandosi a piattaforme esterne.

Per i questionari online esistono diverse soluzioni gratuite od a pagamento (google forms, surveymonkey, etc.).

I vantaggi dei questionari online sono la vasta quantità e distribusione degli utenti che rispondono.

Gli svantaggi sono un bias intrinseco nel fatto di essere online. In alcuni paesi solo le persone più ricche hanno accesso ad Internet.
In alcune nazioni povere in cui sanno bene l'inglese, molti utenti passano tutto il giorno a rispondere a sondaggi con ricompense in denaro.
È difficile controllare la veridicità, spesso si controllano i tempi di compilazione e le risposte contradditorie, ma soprattutto le seconde.
Si valutano di meno anche i questionari in cui le ripsoste sono troppo poco distribuite (tutti 0 e 1, tutti a metà, cose del genere).

#### Interviste

Le domande devono essere preparate in anticipo, devo trattare tutti gli utenti allo stesso modo perché anche questo potrebbe influire nelle risposte.

Biaogna costruire un interazione positiva per far capire all'utente che può rispondere la verità.
C'è il rischio che tenda a rispondere in modo diverso per dimostrare di essere bravo con l'informatica o perché crede di non potersi esprimere negativamente.

Bisogna saper ascoltare e parlare il meno possibile, stiamo intervistando l'utente, non noi stessi.

Se si blocca possiamo riformulare le domande o ripetere cosa ha detto finora.
Non dobbiamo esprimere giudizi sulle risposte, altrimenti potrebbe smettere di rispondere con naturalezza in risposta ai nostri giudizi.

Bisogna porsi in modo moderatamente amichevole per far sentire a proprio agio gli utenti, ma controllando la direzione della discussione senza farla sembrare un interrogatorio.

Mai fare domande chiuse.

Evitare di indirizzare le persone verso una risposta, normalmente tendiamo a farlo inconsciamente.

#### Focus Group

Come intervistare più persone alla volta, è la più difficile perche dobbiamo fare in modo che gli utenti si parlino tra di loro e non con noi.

### Ispezione

Mostriamo a un gruppo piccolo di persone, ma non persone qualsiasi, un gruppo di esperti di usabilità. Richiedono anche meno tempo, perché dobbiamo intervistare meno persone

Tendono ad avere un approccio analitico.

Obbiettivo:
* Nessun falso positivo
* Nessun problema mancato

Gli approcci che segue possono essere:
* Basati su cammini (walkthrough)
* Basati su regole
  * Principi
  * Euristiche
  * Linee guida
    * Definite dagli standard
  * Regole di stile
    * Sono come linee guida dell'azienda

#### Cognitive Walkthrough

Simulano il percorso di un utente davanti all'interfaccia.

Requisiti:
* Descrizione del prototipo
  * Cosa fa software
* Descrizione dei task
  * Quali sono i compiti che l'utente deve svolgere
* Lista delle azioni per eseguire il task
  * Sequenze d'uso che ci aspettiamo dagli utenti
* Indicazioni delle caratteristiche degli utenti
  * Target di utenza

Dopo ogni passo della simulazione compila un questionario:
* L'utente cercherà di svolgere l'azione? Identificherà cosa fare per raggiungere l'obbiettivo?
* L'utente noterà che l'azione coeertta è disponibile?
* L'utente associerà l'azione corretta con l'eggetto che vuole raggiungere?
* Una volta che l'azione è eseguita, l'utente sarà in grado di interpretare il feedback dell'interfaccia?

Permette di individuare tutti i problemi e dove si trovano. Ma è molto laboriosa, richiede molti questionari. È molto tediosa, per questo non è molto usata.

#### Ispezione basata su regole

Non costringiamo gli esperti a commentare ogni passaggi, li lasciamo liberi di esplorare, ed annotano i problemi quando li trovano.
Serve che usino tutti uan terminologia comune, quindi taggano i loro commenti con dei principi dell'HCI (Esempio: violazione di legge gestald, violazione di regola Apple ?...).

### Valutazione basata su modelli

Si cerca di scoprire gli errori senza coinvolgere gli utenti (es: analisi automatica). Non può essere usata per tutto, ma aiuta sicuramente.

Metodo GOMS (Goals, Operators, Methods, Selection rules) per predirre il tempo che ci mette un utente per svolgere un compito:
* Gli obbiettivi dell'utente
  * Risultati che vogliamo ottenere
* Operatori
  * Azioni elementari risultanti dalla scomposizione dell'obbiettivo
  * Saranno azioni del tipo: clicca quella icona, premi questo tastom, etc...
  * Si stima il tempo delle singole operazioni necessarie (esistono delle tabelle)
* Metodi
  * Per raggruppare gli oeratori necessari per raggiungere ogni obbiettivo
* Regole di selezione
  * Stabiliscono quando conviene seguire un metodo piuttosto che un altro

### Scelta del metodo di valutazione

Cosa dobbiamo valutare?
* Tempi di svolgimento
  * Osservazione
  * Modelli
* Quantificare la soddisfazione dell'utente
  * Questionari
* Primo feedback sul design
  * Interviste
* Valutare un prototipo completo
  * Osservazione
  * Ispezione

### Strumenti in supporto alla valutazione

#### Valutazione remota

* Valutazione di utenti lontani dai valutatori
  * Dobbiamo fare un prodotto per il CERN, dove troviamo fisici nucleari?
* Portare gli untenti in laboratorio può essere difficile e costoso
  * Dobbiamo valutare 1000 utenti, dove li mettiamo?
* Possibilità di valutare anche dopo la distribuzione
* Consente di valutare il comportamento degli utenti nel loro ambiente quotidiano
  * Se vengono in laboratiorio, od andiamo noi a casa loro, si comportano in modo innaturale

Esempio:

La beta di una versione di office era disponibile gratuitamente per il download, e veniva usata per la valutazione remota. Mentre usavi il programma comparivano due faccine ":)" ":(" che si potevano cliccare quando si incontra qualcosa di piacevole o spiacevole.
Quando clicchi sulla faccina compare una schermata in cui viene chiesto cosa ti piace/spiace e il permesso di inviare uno screenshot (oltre agli stati interni) a Microsoft.
Il testo libero è costoso perché deve essere valutato da umani, ma Microsoft è grossa, può permetterselo.
La quantità di utenti è grande e sono utenti reali. Considerato un importante passo nell'HCI.

Metodi per la valutazione remota:
* Osservazione remota
  * Si fa quello che si farebbe di persona, ma da remoto
* Questionari remoti
  * Altra volta
  * Esempio: Siti che chiedono "Help make us better"
* Incidenti critici riportati dall'utente
* Log automatico dei dati

#### Analisi Web Log

Servono dei sistemi automatici per analizzarli, perché raggiungono dimensioni troppo grandi, anche molti giga. 
Un possibile strumento di analisi è Google Analytics, maci sono anche molte altre alternative, anche di software libero.

Informazioni che possiamo ottenere dai log:
* Chi ha visto il sito
  * Anche usando i cookie per scoprire di più
* I cammini che seguono all'interno del sito
  * Per controllare se seguono quelli che abbiamo progettato noi
* Quanto tempo passano su ogni pagina
* Dove lasciano il sito
  * Esempio: escono quando vedono i prezzi o perché non capiscono cosa fare dopo
* Il successo delle attività
  * Esempio: alla fine comprano il prodotto o si fermano a metà pagamento

#### Analisi dei movimenti oculari

Negli anni scorsi i dispositivi di tracciamento oculare sono scesi notevolmente (sono comunque costosi). In ogni momento indicano dove stà guardando l'utente.

Quanod guardiamo qualcosa non abbiamo il totale controllo sui movimenti dell'occhio. Quando stiamo fissando qualcosa il nostro occhio fa dei rapidi movimenti strani.
Questi movimenti si chiamano saccadi, o movimenti saccadici (Non si può usare come periferica di controllo per operazioni precise).

In genere si associa ad un software di analisi che misura le saccadi e le pause tra l'una e l'altra per rimuoverle dal tracciamento.

Produce uno scanpath, un tracciamento bidimensionale dei movimenti. Un percorso, in pratica, con delle misurazioni del tempo che è stato fermo in un punto.
Spesso viene prodotto un video in cui è evidenziato lo scanpath, che è molto più utile rispetto ad una traccia statica che copre l'immagine.
Può essere utile una heatmap, anche statica, per riassumere i risultati di molti utenti.