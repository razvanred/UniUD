# Complessità computazionale

Ci concentriamo su problemi di decisione. Ci sarebbero anche problemi funzionali e di ottimizzazione.

Se ho un algoritmo veloce per la parte funzionale, abbiamo anche un algoritmo veloce per la decisione. Se ne ho uno veloce per l'ottimizzazione, ne ho anche uno veloce per la parte funzionale.
Viceversa, se la parte di decisione è difficile, lo saranno anche quella funzionale e di ottimizzazione.

Parliamo di algoritmi che leggono un messaggio e dicono se appartiene o meno ad un linguaggio.
Valuteremo sia la complessità di spazio che di tempo.

## Complessità di tempo

Siano un problema $P$ ed un modello di calcolo $M$.\
Cerchiamo in $M$ la più veloce macchina/algoritmo $m$ che risolve $P$. Più veloce significa che richiede meno istruzioni.\
Bisogna definire una *dimensione dell'input*. La dimensione dovrebbe essere definita dal modello di calcolo.

Non serve cambiare la dimensione dell'input e la complessità per ogni modello di calcolo che ci interessa, perché la tesi di Church-Turing riporta che tutti i modelli di calcolo ragionevoli sono legati polinomialmente.
Quindi Se un problema ha complessità $\Theta(f(n))$ nel modello ragionevole migliore per quel problema, sarà $\Theta(P(f(n)))$ per ogni altro modello ragionevole, dove $P$ è una qualche funzione polinomiale.

Ci serve un modello di calcolo ragionevole da usare come base.

### Unregistered Turing Machine (URM) (con prodotto)

Sono macchine con un set di registri illimitato, in ciascuno di questi registri $r_i$ si trova un naturale arbitrariamente grande.

Il set di istruzioni di queste macchine è:
* `S(i)` = incrementa il registro $r_i$
* `Z(i)` = azzera il registro $r_i$
* `T(i,j)` = copia il contenuto del registro $r_i$ nel registro $r_j$
* `J(i,j,k)` = se il contenuto di $r_i$ e $r_j$ è uguale, salta alla riga $k$

Se il problema è incrementare un intero, nelle MdT il problema ha complessità $O(n)$, nelle URM è una singola istruzione e la complessità è $O(1)$.

Questo succede perché le URM nascondono la dimensione dell'input, perché incrementare un numero ha sempre lo stesso costo a prescindere della lunghezza del numero. Per questo vengono costi troppo bassi.\
$O(n)$ e $O(1)$. sono molto diversi, ma sono comunque legati polinomialmente


Se ho una "URM con prodotto" diventa anche peggio. Aggiungiamo l'istruzione $P(i)$ che moltiplica il contenuto del registro $r_i$ a se stesso.

Possiamo scrivere il programma:
1. `T(0,1)`
2. `J(1,2,6)`
3. `P(0)`
4. `S(2)`
5. `J(3,3,2)`

Questo programma calcola $x^{2^i}$. Nelle URM con prodotto ha complessità $O(x)$, mentre nelle MdT ha costo $\Omega(2^x\log(x))$. Non sono legati polinomialmente.

Questo non significa che non possiamo usare le URM o non possiamo usare le moltiplicazioni, significa che il costo delle operazioni di base non dovrebbe essere uniforme.

#### Uniform Complexity Cost

Ogni istruzione del modello di calcolo ha complessità $\Theta(1)$.

Non è ragionevole quando una operazione di base fa crescere l'input troppo velocemente (ad esempio la moltiplicazione).\
Per le MdT è ragionevole.

#### Logarithmic Complexity Cost

Ogni istruzione del modello ha complessità che dipende dal numero di cifre che manipola.

Per le MdT questo metodo degenera nel costo uniforme, perché ogni istruzione manipola fino ad un numero costante di cifre (il numero di nastri).\
È utile quando ci sembra che il nostro modello possa essere troppo veloce.

* `S(i)` $O(\log(r_i))$
* `Z(i)` $O(1)$
* `T(i,j)` $O(\log(r_i))$
* `J(i,j,k)` $O(\min(\log(r_i),\log(r_j)))$
* `P(i)` $O((\log(r_i))^2)$

### Speed-up theorem

> Se $L\in TIME(f(n))$, allora\
> $\forall_{\varepsilon>0}~L\in TIME(\varepsilon f(n)+n+2)$\
> ($f'(n)=\varepsilon f(n)+2n+2$, non è una derivata)\
> Questo significa che possiamo ignorare le costanti moltiplicative e i termini di grado più basso.

***Dimostrazione***: Data una macchina $M$ ad 1 nastro che riconosce un linguaggio in tempo $f(n)$, esiste una macchina $M'$ a 2 nastri che lo riconosce in tempo $f'(n)$. (se fosse una macchina a più di 1 nastro, non avrei bisogno di nastri aggiuntivi)

la macchina $M'$ deve simulare $m$ passi di $M$ in un numero costante di step. 7 step di $M'$ sono un macro-step, e con questi devo simulare un numero $m$ arbitrariamente grande di step di $M$ ($\varepsilon=\frac7m$).

In $m$ step, la macchina $M$ può modificare al più $m$ simboli sul nastro. Perché la macchina $M'$ possa modificare $m$ simboli in circa un passaggio, serve che questi $m$ simboli di $M$ siano solo un macro-simbolo per $M'$. L'alfabeto di $M'$ è $\Sigma^m$. Inizio copiando i simboli in macro-simboli sul secondo nastro (entrambe le macchine devono riconoscere lo stesso linguaggio, che è scritto in $\Sigma$), le $2n+2$ operazioni servono per questa riscrittura.\
In $m$ step della macchina $M$, possono essere modificati al massimo 2 macro-simboli, quindi solo i due macro-simboli adiacenti possono influenzare la macro-operazione sul macro-simbolo corrente.\
La macchina $M'$ può prima leggere i 3 macro-simboli (corrente, a sinistra, a destra) in soli 3 passaggi, e ricorda i loro valori nello stato della macchina. Modifica al massimo 2 dei macro-simboli in altri 3 passaggi, in 1 ultimo passaggio potresti dover cambiare posizione.

## Complessità di spazio

Per la complessità di spazio serve definire le I/O-TM. È una MdT dove ho, oltre ai soliti nastri generici, due nastri speciali:
* Nastro di input:
  * Può essere letto quante volte voglio, ma mai scritto
  * Non posso andare oltre il primo blank
* Nastro di output:
  * Può essere scritto una sola volta e si può solo andare a destra
  * Non può essere letto

Per una MdT non I/O è semplicemente la somma delle lunghezze dei nastri nell'ultima configurazione. (Dopo che un certo nastro ha usato una cella, resta nella configurazione fino alla fine).\
Con questa definizione, tutte le macchine hanno costo almeno lineare. Potremmo fare di meglio, ma così non ce ne accorgeremmo mai.

Nelle I/O-TM non si contano i nastri di input ed output nella complessità di spazio.

Prendiamo come esempio i palindromi, abbiamo visto che per deciderlo con una MdT normale il costo di spazio è lineare.\
Con una I/O-TM con 4 nastri possiamo scrivere un carattere da controllare su un nastro, ed un contatore in un altro nastro per sapere quale carattere leggere. Ora il costo di spazio è logaritmico. Ovviamente il costo di tempo è aumentato, perché stavamo ottimizzando lo spazio.

Prendendo come esempio la somma, possiamo usare un metodo simile ed usare un contatore per sapere di quanto spostarci, ed il carry su un altro nastro.
Il nastro di output si può scrivere solo da sinistra a destra, quindi dobbiamo computare per ogni bit tutta la somma e poi scrivere solo il più significativo.\
Il costo è di nuovo logaritmico.

> Una I/O-k-MdT $M$ decide $L$ in spazio $f(n)$ se $\forall_x~|x|=n$, si ha che $M(x)\downarrow$ usando al massimo spazio $f(n)$.\
> $$L\in SPACE(f(n))\iff\exists_M~M~\text{decide}~L~\text{in spazio}~f(n)$$

Non è detto che esista un algoritmo efficiente sia in tempo che in spazio, a volte per ottimizzare uno bisogna rinunciare all'altro.

Esiste uno speed-up theorem per lo spazio, ma non lo vedremo. Dimostra che $L\in SPACE(f(n))\Rightarrow\forall_{\varepsilon>0}~L\in SPACE(\varepsilon f(n)+2)$.

## Random Access Machines (RAM)

Sono un modello di calcolo alternativo alle MdT, più facile da programmare.\
Una RAM ha dei set illimitati di registri illimitati: working set, ed input set.

Il set di istruzioni è:
* Input
  * `READ J` Assegna al registro 0 il contenuto del registro **di input** J
  * `READ !J` (doveva essere $\uparrow J$) Assegna al registro 0 il contenuto del registro **di input** scritto in J, indirizzamento indiretto
* Scrittura
  * `STORE J` Assegna a J il contenuto di 0
  * `STORE !J` Assegna al registro scritto in J il contenuto di 0
* Lettura
  * `LOAD J` Come `READ` ma legge dai registri di lavoro
  * `LOAD !J` Come `READ` ma legge dai registri di lavoro
  * `LOAD =J` Scrive il numero J in 0 (senza indirizzamento)
* Operazioni aritmetiche
  * `ADD J` Incrementa 0 del contenuto di J
  * `ADD !J` Incrementa 0 del contenuto del registro scritto in J
  * `ADD =J` Incrementa 0 di J
  * `SUB J` Decrementa 0 del contenuto di J
  * `SUB !J` Decrementa 0 del contenuto del registro scritto in J
  * `SUB =J` Decrementa 0 di J
  * `HALF` Dimezza (per difetto) il contenuto di 0
* Controllo di flusso
  * `JUMP J` Imposta il program counter a J
  * `JPOS J` Imposta il program counter a J se il contenuto di 0 è positivo (strettamente)
  * `JNEG J` Imposta il program counter a J se il contenuto di 0 è negativo
  * `JZERO J` Imposta il program counter a J se il contenuto di 0 è 0
  * `HALT` Imposta il program counter a 0 (stop)

In una RAM, la configurazione sono il program counter, ed il set di registri di lavoro: $C=(k,R)$. $k$ è il counter, mentre $R$ è il set di tutti i registri che sono stati modificati finora nella forma $(R_{J_i},r_{J_i})$, gli altri registri contengono 0.
I registri di input non fanno parte della configurazione.

Uno step di computazione del programma $P$ con input $I$ è una funzione che mappa $(k,R)\mapsto^{P,I}(k',R')$.
Uno step è definito dall'istruzione alla posizione $k$, ad esempio se alla posizione 4 abbiamo `ADD 7`, lo step è $(4,R)\mapsto^{P,I}(5,(R\setminus\{(R_0,r_0)\})\cup\{R_0,r_0+r_7\})$.\
Quando voglio indicare che sono eseguiti $l$ step posso scrivere $C\mapsto^{P,I^l}C'$. Quando non mi interessa il numero di step posso scrivere $C\mapsto^{P,I^*}C'$

La funzione eseguita da una RAM $P$ è $\Phi:D\mapsto\N$ dove il dominio $D\subseteq\N^h$, se $\forall_{I\in D}~(1,\emptyset)\mapsto^{P,I^l}(0,R)$ dove $l$ è finito e $(R_0,\Phi(I))\in R$.

Una RAM $P$ su un input $I$ termina in tempo $t$ se $(1,\emptyset)\mapsto^{P,I^t}(0,R)$.\
Una RAM $P$ opera in tempo $f(n)$ se per ogni input $I$ di lunghezza $n$ termina in tempo $f(n)$.\
*È un costo di tempo uniforme.*

### Simulare MdT con RAM

Una MdT opera su stringhe $\sigma_1,...,\sigma_n$ di un alfabeto $\Sigma$, devo definire $D_\Sigma=\{(i_1,...,i_n,0):n\geq0~\forall_{1\leq J\leq n}~1\leq i_J\leq l\}$. In pratica, le stringhe di $\Sigma$ sono codificate come tuple di interi e terminate da 0 (al posto del blank).

Una RAM $P$ simula la MdT $M$ (che decide $L$) se $P$ calcola $\Phi_L:D_\Sigma\mapsto\N$ dove $\Phi_L(i_1,...,i_n,0)=\begin{cases}1&\sigma_1,...,\sigma_n\in L\\0&\sigma_1,...,\sigma_n\notin L\end{cases}$.

> **Teorema**: Se $L\in TIME(f(n))$, allora esiste una RAM $P$ che calcola $\Phi_L$, che opera in tempo $O(f(n))$.
> 
> **Dimostrazione**: Sia $M=(\Sigma, K, \delta, o)$ la MdT che decide $L$ in tempo $f(n)$. Vogliamo descrivere una RAM $P$ che la simuli (codice sotto).
> $P$ deve iniziare copiando i simboli dai registri di input a quelli di lavoro, userà quelli di lavoro come il nastro di $M$.
> Dopo di che, visto che $|\Sigma|$ e $|K|$ sono prestabiliti, ad ogni step posso fare un loop che legge un simbolo ad una posizione, confronta tutti i simboli con quello corrente, aggiorna la posizione del nastro, e salta al blocco di codice che gestisce un altro stato tutto questo in tempo $O(1)$ (perché appunto le cardinalità sono fisse). Eseguo questi step fino alla fine della computazione.\
> La RAM opera in $O(f(n))+O(n)=O(f(n))+O(|x|)=O(f(n))$

1. -- (configurazione iniziale)
2. STORE 1
3. LOAD =$x$ ($x$ è il numero di registri che mi servono per decidere ogni step)
4. STORE 2
5. -- (loop che copia l'input)
6. READ !1
7. STORE !2
8. STORE 3
9. LOAD 1
10. ADD =1
11. STORE 1
12. LOAD 2
13. ADD =1
14. STORE 2
15. LOAD 3
16. SUB =$\sigma_0$ ($\sigma_0$ è il naturale che rappresenta il carattere 0)
17. JZERO 19
18. JUMP 5
19. -- (configurazione stato iniziale)
20. LOAD =k (stato iniziale di $M$)
21. STORE 1
22. LOAD =$x+1$ (posizione iniziale)
23. STORE 2
24. LOAD =$\sigma_\triangleright$ (carattere iniziale)
25. STORE 3
26. -- (blocco di codice dello stato iniziale)
27. ...
28. -- (blocco dello stato 2)
29. ...
30. ...

### Simulare RAM con MdT

> **Teorema**: Se $P$ è una RAM che calcola una funzione $\Phi$ in tempo $f(n)$, esiste una 7-I/O-TM che calcola $\Phi$ in tempo $O(f(n)^3)$.
> 
> **Dimostrazione**: Il primo nastro è input. Il secondo nastro contiene $R$ (l'insieme di coppie registro-valore che contiene i registri modificati finora), può essere codificato come un elenco di stringhe separate da blank e finisce dove ci sono due blank. Il terzo nastro contiene il program counter. Quarto, quinto e sesto sono per le operazioni aritmetiche. Settimo è output, quindi al termine della computazione conterrà $r_0$.\
> Possiamo costruire una macchina $M$ che simuli ogni istruzione di una RAM su questi nastri. Descrizione sotto.

Le operazioni più difficili sono quelle aritmetiche con indirizzamento indiretto, il resto segue. L'esempio sarà `ADD !J` che calcola $r_0=r_0+r_{r_j}$, tutte le altre impiegheranno meno tempo:
1. Scansiono il secondo nastro per trovare $r_0$ e lo copio sul nastro 4.
2. Scansiono il secondo nastro per trovare $r_j$ e lo copio sul nastro 6.
3. Scansiono il secondo nastro per trovare $r_{r_j}$ e lo copio sul nastro 5.
4. Eseguo la somma tra i nastri 4 e 5, scrivendo il risultato sul nastro 6.
5. Scansiono il secondo nastro per copiare il contenuto del nastro 6 nel registro $r_0$

Nastri:
1. $\triangleright b(\pi_1)\sqcup b(\pi_2)\sqcup... \sqcup\sqcup$ input
2. $\triangleright b(i)\sqcup b(r_i)\sqcup ... \sqcup\sqcup$ memoria
3. $\triangleright b(k)\sqcup$ program counter
4. $\triangleright (r_0)\sqcup$
5. $\triangleright b(r_{r_j})\sqcup$
6. $\triangleright b(r_j)\sqcup$ poi diventa $\triangleright b(r'_0)\sqcup$
7. $\triangleright b(r_0)\sqcup$ valore finale

Ad un passo $t$ che manipola $r_i$, la ***lunghezza*** di $i$ ed $r_i$ non può superare (per eccesso, molto grossolanamente) $l(I)+l(B)+t$, dove $l(I)$ è la lunghezza dell'input (in "bit"), ed $l(B)$ è la lunghezza della più grande costante che compare nel programma. Perché l'operazione più potente che ho è la somma, ed al massimo aggiunge un bit al valore più grande che la macchina conosce.\
Il secondo nastro di $M$ alla fine della computazione contiene al massimo $f(n)$ registri lunghi $f(n)$, quindi in totale è lungo $O(f(n)^2)$.\
In totale servono $f(n)$ macro-passi di costo $O(f(n)^2)$, per un costo complessivo di $O(f(n)^3)$.

La moltiplicazione è un'operazione pericolosa, permette ai valori dei registri di crescere troppo. Ma la nostra RAM ha solo la somma, quindi (non solo per questo) è correlata polinomialmente alle MdT.\
Se avesse la moltiplicazione non lo sarebbe.