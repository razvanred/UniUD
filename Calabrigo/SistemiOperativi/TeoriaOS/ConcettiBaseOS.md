# OS concepts
Il sistema operativo è un software che fornisce delle astrazione all'utente (come i file,...) e gestisce l'hardware (come la memoria virtuale, gli interrupt, ...).\
Fanno parte dell'OS:
* Processi: i processi sono dei programmi in esecuzione. Ogni processo dispone di un'area di memoria in RAM e può essere eventualmente swappato nel disco (mem. virtuale). Se un processore ha più processi da gestire, questi ultimi vengono eseguiti un po' a testa.I processori per pc moderni possono gestire molti processori utilizzando la multiprogrammazione. Quando un processo deve essere sospeso, bisogna salvare tutti i valori dei registri oltre che allo spazio di indirizzi (in RAM), quindi serve una struttura che tenga conto della sospensione di un processo; questa struttura si chiama Tabella di Processo, e contiene tutte le informazioni che non riguardano lo spazio di indirizzi di un processo, è un array di strutture. Un processo sospeso è costituito dal suo elemento nella tabella di processo, e dal suo spazio di indirizzi. I processi su Unix vengono generati dal padre, e si possono far comunicare grazie a pipe (dei file che vengono aperti in scrittura da un processo, e in lettura da un altro). Ad ogni processo viene assegnato un UID (user ID) e un GID(group ID).
* Spazio degli Indirizzi: Ad ogni processo viene assegnato uno spazio degli indirizzi, che indica l'area di memoria ad esso assegnata, quindi ogni processo avtrà a disposizione la memoria da k a m, dove k < m. Se un processo richiede più memoria della memoria RAM fisica, allora interviene la memoria virtuale, che mi permette di avere uno spazio di indirizzi 2^32 o 2^64 in base al sistema.
* Protezione e Permessi: Per fare in modo che un programma in RAM che abbia il suo spazio di indirizzi non possa andare a leggere lo spazio di indirizzi di un altro programma, ci sono dei sistemi di protezione hardware. Un altro tipo di protezione lo possiamo offrire ai file, tramite i permessi. I permessi servono ad evitare che utenti che non vorresti che accedessero ad un file, vi accedano. I permessi sono scritture, lettura ed esecuzione (rwx).
* File: Un file è un'astrazione fornita dall'OS, ed è un modo comodo di salvare i dati. Normalmente, per salvare dei dati su disco, bisognerebbe comunicare direttamente con il controller del disco, tuttavia questo richiederebbe una conoscenza enorme, quindi viene utilizzata una semplice astrazione, in modo tale da non dover scrivere comandi complessi per la scrittura su disco, inoltre l'OS gestisce gli spazi di memoria, e quindi non serve che l'utente specifichi in che area salvare (altrimenti, per il disco, dovrei indicare blocco, settore, sezione). I file vengono gestiti dal file system, che crea una gerarchia di file. Ogni file possiede un descrittore del file, ovvero un numero intero che lo identifica. In UNIX esistono i file speciali. Come il disco viene visto come una cartella (che è un file), anche gli altri dispositivi di I/O, quando installati, vengono visti come file. In questo modo abbiamo una comodissima astrazione che ci permette di inviargli dei comandi e di riceverli.

## TRAP
La chiamata di procedura Trap viene chiamata ogni volta che l'utente fa una chiamata di sistema. Quando faccio una chiamata di sistema qualunque (es. read, exec, fork,...), per prima cosa nello stack metterò i parametri della chiamata di sistema e poi metterò una Trap. La trap è system call che, preso l'identificativo della chiamata di sistema(read, exec, ...) che voglio usare, e cambiata la modalità da utente a kernel, và ad un indirizzo fisso in memoria dove si trova una tabella di puntatori a procedure, dove ogni procedura è una chiamata di sistema (read, exec, fork,...). A questo punto la chiamata di sistema viene eseguita (utilizzando i parametri forniti dalla Trap), e la Trap termina, restituendo il controllo al programma applicativo, e cambiando la modalità da kernel a utente.

Quindi ogni volta che uso una qualsiasi chiamata di sistema, in realtà uso sempre Trap(SystemCallID, parametriSystemCall). E poi la trap chiamerà la procedura giusta e la farà eseguire in modalità kernel.